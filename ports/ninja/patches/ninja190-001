diff -Naur ninja-1.9.0.orig/.gitignore ninja/.gitignore
--- ninja-1.9.0.orig/.gitignore	2019-01-30 13:58:59.000000000 +0000
+++ ninja/.gitignore	2019-09-24 19:51:29.561026538 +0000
@@ -7,10 +7,8 @@
 /build
 /build.ninja
 /ninja
-/ninja.bootstrap
 /build_log_perftest
 /canon_perftest
-/clparser_perftest
 /depfile_parser_perftest
 /hash_collision_bench
 /ninja_test
@@ -32,6 +30,3 @@
 # Ninja output
 .ninja_deps
 .ninja_log
-
-# Visual Studio Code project files
-/.vscode/
diff -Naur ninja-1.9.0.orig/.travis.yml ninja/.travis.yml
--- ninja-1.9.0.orig/.travis.yml	2019-01-30 13:58:59.000000000 +0000
+++ ninja/.travis.yml	2019-09-24 19:51:29.561508938 +0000
@@ -1,15 +1,5 @@
-matrix:
-  include:
-    - os: linux
-      compiler: gcc
-    - os: linux
-      compiler: clang
-    - os: osx
-sudo: false
 language: cpp
-script:
-  - ./configure.py --bootstrap
-  - ./ninja all
-  - ./ninja_test --gtest_filter=-SubprocessTest.SetWithLots
-  - ./misc/ninja_syntax_test.py
-  - ./misc/output_test.py
+compiler:
+  - gcc
+  - clang
+script: ./configure.py --bootstrap && ./ninja ninja_test && ./ninja_test --gtest_filter=-SubprocessTest.SetWithLots && ./misc/ninja_syntax_test.py
diff -Naur ninja-1.9.0.orig/HACKING.md ninja/HACKING.md
--- ninja-1.9.0.orig/HACKING.md	2019-01-30 13:58:59.000000000 +0000
+++ ninja/HACKING.md	2019-09-24 19:51:29.562775338 +0000
@@ -2,61 +2,10 @@
 
 `./configure.py` generates the `build.ninja` files used to build
 ninja.  It accepts various flags to adjust build parameters.
-Run './configure.py --help' for more configuration options.
 
 The primary build target of interest is `ninja`, but when hacking on
-Ninja your changes should be testable so it's more useful to build and
-run `ninja_test` when developing.
-
-### Bootstrapping
-
-Ninja is built using itself.  To bootstrap the first binary, run the
-configure script as `./configure.py --bootstrap`.  This first compiles
-all non-test source files together, then re-builds Ninja using itself.
-You should end up with a `ninja` binary (or `ninja.exe`) in the project root.
-
-#### Windows
-
-On Windows, you'll need to install Python to run `configure.py`, and
-run everything under a Visual Studio Tools Command Prompt (or after
-running `vcvarsall` in a normal command prompt).
-
-For other combinations such as gcc/clang you will need the compiler
-(gcc/cl) in your PATH and you will have to set the appropriate
-platform configuration script.
-
-See below if you want to use mingw or some other compiler instead of
-Visual Studio.
-
-##### Using Visual Studio
-Assuming that you now have Python installed, then the steps for building under
-Windows using Visual Studio are:
-
-Clone and checkout the latest release (or whatever branch you want). You
-can do this in either a command prompt or by opening a git bash prompt:
-
-```
-    $ git clone git://github.com/ninja-build/ninja.git && cd ninja
-    $ git checkout release
-```
-
-Then:
-
-1. Open a Windows command prompt in the folder where you checked out ninja.
-2. Select the Microsoft build environment by running
-`vcvarsall.bat` with the appropriate environment.
-3. Build ninja and test it.
-
-The steps for a Visual Studio 2015 64-bit build are outlined here:
-
-```
-    > "C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\vcvarsall.bat" x64
-    > python configure.py --bootstrap
-    > ninja --help
-```
-Copy the ninja executable to another location, if desired, e.g. C:\local\Ninja.
-
-Finally add the path where ninja.exe is to the PATH variable.
+Ninja your changes should be testable so it's more useful to build
+and run `ninja_test` when developing.
 
 ### Adjusting build flags
 
@@ -89,11 +38,11 @@
 
 I am very wary of changes that increase the complexity of Ninja (in
 particular, new build file syntax or command-line flags) or increase
-the maintenance burden of Ninja.  Ninja is already successfully used
+the maintenance burden of Ninja.  Ninja is already successfully in use
 by hundreds of developers for large projects and it already achieves
 (most of) the goals I set out for it to do.  It's probably best to
-discuss new feature ideas on the [mailing list](https://groups.google.com/forum/#!forum/ninja-build)
-before I shoot down your patch.
+discuss new feature ideas on the mailing list before I shoot down your
+patch.
 
 ## Testing
 
@@ -109,9 +58,17 @@
 
 ## Testing performance impact of changes
 
-If you have a Chrome build handy, it's a good test case.  There's a
-script at `misc/measure.py` that repeatedly runs a command (to address
-variance) and summarizes its runtime.  E.g.
+If you have a Chrome build handy, it's a good test case.  Otherwise,
+[the github downoads page](https://github.com/martine/ninja/downloads)
+has a copy of the Chrome build files (and depfiles). You can untar
+that, then run
+
+    path/to/my/ninja chrome
+
+and compare that against a baseline Ninja.
+
+There's a script at `misc/measure.py` that repeatedly runs a command like
+the above (to address variance) and summarizes its runtime.  E.g.
 
     path/to/misc/measure.py path/to/my/ninja chrome
 
@@ -123,7 +80,7 @@
 Generally it's the [Google C++ coding style][], but in brief:
 
 * Function name are camelcase.
-* Member methods are camelcase, except for trivial getters which are
+* Member methods are camelcase, expect for trivial getters which are
   underscore separated.
 * Local variables are underscore separated.
 * Member variables are underscore separated and suffixed by an extra
@@ -133,7 +90,7 @@
 * Lines are 80 columns maximum.
 * All source files should have the Google Inc. license header.
 
-[Google C++ coding style]: https://google.github.io/styleguide/cppguide.html
+[Google C++ coding style]: http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml
 
 ## Documentation
 
@@ -219,7 +176,7 @@
     ./ninja_test
     gcov build/*.o
 
-Look at the generated `.gcov` files directly, or use your favorite gcov viewer.
+Look at the generated `.gcov` files directly, or use your favorit gcov viewer.
 
 ### Using afl-fuzz
 
diff -Naur ninja-1.9.0.orig/README ninja/README
--- ninja-1.9.0.orig/README	2019-01-30 13:58:59.000000000 +0000
+++ ninja/README	2019-09-24 19:51:29.563304938 +0000
@@ -1,19 +1,18 @@
 Ninja is a small build system with a focus on speed.
-https://ninja-build.org/
+http://martine.github.com/ninja/
 
-See the manual -- https://ninja-build.org/manual.html or
+See the manual -- http://martine.github.com/ninja/manual.html or
 doc/manual.asciidoc included in the distribution -- for background
 and more details.
 
-Binaries for Linux, Mac, and Windows are available at
-  https://github.com/ninja-build/ninja/releases
-Run './ninja -h' for Ninja help.
+To build, run ./configure.py --bootstrap.  It first compiles all non-test
+source files together, then re-builds Ninja using itself.  You should
+end up with a 'ninja' binary in the source root.
 
-To build your own binary, on many platforms it should be sufficient to
-just run `./configure.py --bootstrap`; for more details see HACKING.md.
-(Also read that before making changes to Ninja, as it has advice.)
+Run './configure.py --help' for more configuration options.
+Run './ninja -h' for Ninja help.
 
-Installation is not necessary because the only required file is the
+Installation is not necessary because the only required file is is the
 resulting ninja binary. However, to enable features like Bash
 completion and Emacs and Vim editing modes, some files in misc/ must be
 copied to appropriate locations.
diff -Naur ninja-1.9.0.orig/RELEASING ninja/RELEASING
--- ninja-1.9.0.orig/RELEASING	2019-01-30 13:58:59.000000000 +0000
+++ ninja/RELEASING	2019-09-24 19:51:29.563864938 +0000
@@ -1,33 +1,31 @@
 Notes to myself on all the steps to make for a Ninja release.
 
 Push new release branch:
-1. Run afl-fuzz for a day or so (see HACKING.md) and run ninja_test
-2. Consider sending a heads-up to the ninja-build mailing list first
-3. Make sure branches 'master' and 'release' are synced up locally
-4. Update src/version.cc with new version (with ".git"), then
-       git commit -am 'mark this 1.5.0.git'
-5. git checkout release; git merge master
-6. Fix version number in src/version.cc (it will likely conflict in the above)
-7. Fix version in doc/manual.asciidoc (exists only on release branch)
-8. commit, tag, push (don't forget to push --tags)
-       git commit -am v1.5.0; git push origin release
+1. Consider sending a heads-up to the ninja-build mailing list first
+2. update src/version.cc with new version (with ".git"), then
+       git commit -a -m 'mark this 1.5.0.git'
+3. git checkout release; git merge master
+4. fix version number in src/version.cc (it will likely conflict in the above)
+5. fix version in doc/manual.asciidoc
+6. commit, tag, push (don't forget to push --tags)
+       git commit -a -m v1.5.0; git push origin release
        git tag v1.5.0; git push --tags
        # Push the 1.5.0.git change on master too:
        git checkout master; git push origin master
-9. Construct release notes from prior notes
+7. construct release notes from prior notes
    credits: git shortlog -s --no-merges REV..
 
 Release on github:
 1. https://github.com/blog/1547-release-your-software
-   Add binaries to https://github.com/ninja-build/ninja/releases
+   Add binaries to https://github.com/martine/ninja/releases
 
 Make announcement on mailing list:
 1. copy old mail
 
 Update website:
 1. Make sure your ninja checkout is on the v1.5.0 tag
-2. Clone https://github.com/ninja-build/ninja-build.github.io
-3. In that repo, `./update-docs.sh`
+2. Clone https://github.com/martine/martine.github.io
+3. In that repo, `cd ninja && ./update-docs.sh`
 4. Update index.html with newest version and link to release notes
 5. git commit -m 'run update-docs.sh, 1.5.0 release'
 6. git push origin master
diff -Naur ninja-1.9.0.orig/appveyor.yml ninja/appveyor.yml
--- ninja-1.9.0.orig/appveyor.yml	2019-01-30 13:58:59.000000000 +0000
+++ ninja/appveyor.yml	1969-12-31 19:00:00.000000000 +0000
@@ -1,40 +0,0 @@
-version: 1.0.{build}
-image: Visual Studio 2017
-
-environment:
-  CLICOLOR_FORCE: 1
-  CHERE_INVOKING: 1 # Tell Bash to inherit the current working directory
-  matrix:
-    - MSYSTEM: MINGW64
-    - MSYSTEM: MSVC
-
-for:
-  -
-    matrix:
-      only:
-        - MSYSTEM: MINGW64
-    build_script:
-      ps: "C:\\msys64\\usr\\bin\\bash -lc @\"\n
-      pacman -S --quiet --noconfirm --needed re2c 2>&1\n
-      sed -i 's|cmd /c $ar cqs $out.tmp $in && move /Y $out.tmp $out|$ar crs $out $in|g' configure.py\n
-      ./configure.py --bootstrap --platform mingw 2>&1\n
-      ./ninja all\n
-      ./ninja_test 2>&1\n
-      ./misc/ninja_syntax_test.py 2>&1\n\"@"
-  -
-    matrix:
-      only:
-        - MSYSTEM: MSVC
-    build_script:
-    - cmd: >-
-        call "C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Auxiliary\Build\vcvars64.bat"
-
-        python configure.py --bootstrap
-
-        ninja.bootstrap.exe all
-
-        ninja_test
-
-        python misc/ninja_syntax_test.py
-
-test: off
diff -Naur ninja-1.9.0.orig/configure.py ninja/configure.py
--- ninja-1.9.0.orig/configure.py	2019-01-30 13:58:59.000000000 +0000
+++ ninja/configure.py	2019-09-24 19:51:29.567788938 +0000
@@ -28,8 +28,7 @@
 import subprocess
 import sys
 
-sourcedir = os.path.dirname(os.path.realpath(__file__))
-sys.path.insert(0, os.path.join(sourcedir, 'misc'))
+sys.path.insert(0, 'misc')
 import ninja_syntax
 
 
@@ -58,16 +57,11 @@
             self._platform = 'bitrig'
         elif self._platform.startswith('netbsd'):
             self._platform = 'netbsd'
-        elif self._platform.startswith('aix'):
-            self._platform = 'aix'
-        elif self._platform.startswith('dragonfly'):
-            self._platform = 'dragonfly'
 
     @staticmethod
     def known_platforms():
       return ['linux', 'darwin', 'freebsd', 'openbsd', 'solaris', 'sunos5',
-              'mingw', 'msvc', 'gnukfreebsd', 'bitrig', 'netbsd', 'aix',
-              'dragonfly']
+              'mingw', 'msvc', 'gnukfreebsd', 'bitrig', 'netbsd']
 
     def platform(self):
         return self._platform
@@ -86,7 +80,7 @@
                                  stdout=subprocess.PIPE,
                                  stderr=subprocess.PIPE)
         out, err = popen.communicate()
-        return b'/FS' in out
+        return '/FS ' in str(out)
 
     def is_windows(self):
         return self.is_mingw() or self.is_msvc()
@@ -94,23 +88,15 @@
     def is_solaris(self):
         return self._platform == 'solaris'
 
-    def is_aix(self):
-        return self._platform == 'aix'
-
     def uses_usr_local(self):
-        return self._platform in ('freebsd', 'openbsd', 'bitrig', 'dragonfly', 'netbsd')
+        return self._platform in ('freebsd', 'openbsd', 'bitrig')
 
     def supports_ppoll(self):
-        return self._platform in ('freebsd', 'linux', 'openbsd', 'bitrig',
-                                  'dragonfly')
+        return self._platform in ('linux', 'openbsd', 'bitrig')
 
     def supports_ninja_browse(self):
-        return (not self.is_windows()
-                and not self.is_solaris()
-                and not self.is_aix())
+        return not self.is_windows() and not self.is_solaris()
 
-    def can_rebuild_in_place(self):
-        return not (self.is_windows() or self.is_aix())
 
 class Bootstrap:
     """API shim for ninja_syntax.Writer that instead runs the commands.
@@ -137,9 +123,7 @@
         return self.writer.newline()
 
     def variable(self, key, val):
-        # In bootstrap mode, we have no ninja process to catch /showIncludes
-        # output.
-        self.vars[key] = self._expand(val).replace('/showIncludes', '')
+        self.vars[key] = self._expand(val)
         return self.writer.variable(key, val)
 
     def rule(self, name, **kwargs):
@@ -171,16 +155,12 @@
     def _expand_paths(self, paths):
         """Expand $vars in an array of paths, e.g. from a 'build' block."""
         paths = ninja_syntax.as_list(paths)
-        return ' '.join(map(self._shell_escape, (map(self._expand, paths))))
+        return ' '.join(map(self._expand, paths))
 
     def _expand(self, str, local_vars={}):
         """Expand $vars in a string."""
         return ninja_syntax.expand(str, self.vars, local_vars)
 
-    def _shell_escape(self, path):
-        """Quote paths containing spaces."""
-        return '"%s"' % path if ' ' in path else path
-
     def _run_command(self, cmdline):
         """Run a subcommand, quietly.  Prints the full command on error."""
         try:
@@ -256,7 +236,7 @@
 if '--bootstrap' in configure_args:
     configure_args.remove('--bootstrap')
 n.variable('configure_args', ' '.join(configure_args))
-env_keys = set(['CXX', 'AR', 'CFLAGS', 'CXXFLAGS', 'LDFLAGS'])
+env_keys = set(['CXX', 'AR', 'CFLAGS', 'LDFLAGS'])
 configure_env = dict((k, os.environ[k]) for k in os.environ if k in env_keys)
 if configure_env:
     config_str = ' '.join([k + '=' + pipes.quote(configure_env[k])
@@ -271,11 +251,11 @@
     objext = '.obj'
 
 def src(filename):
-    return os.path.join('$root', 'src', filename)
+    return os.path.join('src', filename)
 def built(filename):
     return os.path.join('$builddir', filename)
 def doc(filename):
-    return os.path.join('$root', 'doc', filename)
+    return os.path.join('doc', filename)
 def cc(name, **kwargs):
     return n.build(built(name + objext), 'cxx', src(name + '.c'), **kwargs)
 def cxx(name, **kwargs):
@@ -287,12 +267,6 @@
         return exe
     return name
 
-root = sourcedir
-if root == os.getcwd():
-    # In the common case where we're building directly in the source
-    # tree, simplify all the paths to just be cwd-relative.
-    root = '.'
-n.variable('root', root)
 n.variable('builddir', 'build')
 n.variable('cxx', CXX)
 if platform.is_msvc():
@@ -306,10 +280,8 @@
               '/Zi',  # Create pdb with debug info.
               '/W4',  # Highest warning level.
               '/WX',  # Warnings as errors.
-              '/wd4530', '/wd4100', '/wd4706', '/wd4244',
+              '/wd4530', '/wd4100', '/wd4706',
               '/wd4512', '/wd4800', '/wd4702', '/wd4819',
-              # Disable warnings about constant conditional expressions.
-              '/wd4127',
               # Disable warnings about passing "this" during initialization.
               '/wd4355',
               # Disable warnings about ignored typedef in DbgHelp.h
@@ -319,8 +291,11 @@
               # We never have strings or arrays larger than 2**31.
               '/wd4267',
               '/DNOMINMAX', '/D_CRT_SECURE_NO_WARNINGS',
-              '/D_HAS_EXCEPTIONS=0',
               '/DNINJA_PYTHON="%s"' % options.with_python]
+    if options.bootstrap:
+        # In bootstrap mode, we have no ninja process to catch /showIncludes
+        # output.
+        cflags.remove('/showIncludes')
     if platform.msvc_needs_fs():
         cflags.append('/FS')
     ldflags = ['/DEBUG', '/libpath:$builddir']
@@ -330,11 +305,11 @@
 else:
     cflags = ['-g', '-Wall', '-Wextra',
               '-Wno-deprecated',
-              '-Wno-missing-field-initializers',
               '-Wno-unused-parameter',
               '-fno-rtti',
               '-fno-exceptions',
               '-fvisibility=hidden', '-pipe',
+              '-Wno-missing-field-initializers',
               '-DNINJA_PYTHON="%s"' % options.with_python]
     if options.debug:
         cflags += ['-D_GLIBCXX_DEBUG', '-D_GLIBCXX_DEBUG_PEDANTIC']
@@ -343,8 +318,7 @@
         cflags += ['-O2', '-DNDEBUG']
     try:
         proc = subprocess.Popen(
-            [CXX, '-fdiagnostics-color', '-c', '-x', 'c++', '/dev/null',
-             '-o', '/dev/null'],
+            [CXX, '-fdiagnostics-color', '-c', '-x', 'c++', '/dev/null'],
             stdout=open(os.devnull, 'wb'), stderr=subprocess.STDOUT)
         if proc.wait() == 0:
             cflags += ['-fdiagnostics-color']
@@ -356,11 +330,6 @@
     if platform.uses_usr_local():
         cflags.append('-I/usr/local/include')
         ldflags.append('-L/usr/local/lib')
-    if platform.is_aix():
-        # printf formats for int64_t, uint64_t; large file support
-        cflags.append('-D__STDC_FORMAT_MACROS')
-        cflags.append('-D_LARGE_FILES')
-
 
 libs = []
 
@@ -369,8 +338,6 @@
     ldflags.append('-static')
 elif platform.is_solaris():
     cflags.remove('-fvisibility=hidden')
-elif platform.is_aix():
-    cflags.remove('-fvisibility=hidden')
 elif platform.is_msvc():
     pass
 else:
@@ -386,9 +353,6 @@
 if platform.supports_ninja_browse():
     cflags.append('-DNINJA_HAVE_BROWSE')
 
-# Search for generated headers relative to build dir.
-cflags.append('-I.')
-
 def shell_escape(str):
     """Escape str such that it's interpreted as a single argument by
     the shell."""
@@ -402,10 +366,6 @@
 
 if 'CFLAGS' in configure_env:
     cflags.append(configure_env['CFLAGS'])
-    ldflags.append(configure_env['CFLAGS'])
-if 'CXXFLAGS' in configure_env:
-    cflags.append(configure_env['CXXFLAGS'])
-    ldflags.append(configure_env['CXXFLAGS'])
 n.variable('cflags', ' '.join(shell_escape(flag) for flag in cflags))
 if 'LDFLAGS' in configure_env:
     ldflags.append(configure_env['LDFLAGS'])
@@ -414,7 +374,7 @@
 
 if platform.is_msvc():
     n.rule('cxx',
-        command='$cxx $cflags -c $in /Fo$out /Fd' + built('$pdb'),
+        command='$cxx $cflags -c $in /Fo$out',
         description='CXX $out',
         deps='msvc'  # /showIncludes is included in $cflags.
     )
@@ -455,10 +415,10 @@
 if platform.supports_ninja_browse():
     n.comment('browse_py.h is used to inline browse.py.')
     n.rule('inline',
-           command='"%s"' % src('inline.sh') + ' $varname < $in > $out',
+           command='src/inline.sh $varname < $in > $out',
            description='INLINE $out')
     n.build(built('browse_py.h'), 'inline', src('browse.py'),
-            implicit=src('inline.sh'),
+            implicit='src/inline.sh',
             variables=[('varname', 'kBrowsePy')])
     n.newline()
 
@@ -485,13 +445,9 @@
 n.newline()
 
 n.comment('Core source files all build into ninja library.')
-cxxvariables = []
-if platform.is_msvc():
-    cxxvariables = [('pdb', 'ninja.pdb')]
 for name in ['build',
              'build_log',
              'clean',
-             'clparser',
              'debug_flags',
              'depfile_parser',
              'deps_log',
@@ -505,23 +461,20 @@
              'manifest_parser',
              'metrics',
              'state',
-             'string_piece_util',
              'util',
              'version']:
-    objs += cxx(name, variables=cxxvariables) 
+    objs += cxx(name)
 if platform.is_windows():
     for name in ['subprocess-win32',
                  'includes_normalize-win32',
                  'msvc_helper-win32',
                  'msvc_helper_main-win32']:
-        objs += cxx(name, variables=cxxvariables)
+        objs += cxx(name)
     if platform.is_msvc():
-        objs += cxx('minidump-win32', variables=cxxvariables)
+        objs += cxx('minidump-win32')
     objs += cc('getopt')
 else:
     objs += cxx('subprocess-posix')
-if platform.is_aix():
-    objs += cc('getopt')
 if platform.is_msvc():
     ninja_lib = n.build(built('ninja.lib'), 'ar', objs)
 else:
@@ -533,13 +486,10 @@
 else:
     libs.append('-lninja')
 
-if platform.is_aix():
-    libs.append('-lperfstat')
-
 all_targets = []
 
 n.comment('Main executable is library plus main() function.')
-objs = cxx('ninja', variables=cxxvariables)
+objs = cxx('ninja')
 ninja = n.build(binary('ninja'), 'link', objs, implicit=ninja_lib,
                 variables=[('libs', libs)])
 n.newline()
@@ -554,13 +504,10 @@
 n.comment('Tests all build into ninja_test executable.')
 
 objs = []
-if platform.is_msvc():
-    cxxvariables = [('pdb', 'ninja_test.pdb')]
 
 for name in ['build_log_test',
              'build_test',
              'clean_test',
-             'clparser_test',
              'depfile_parser_test',
              'deps_log_test',
              'disk_interface_test',
@@ -570,14 +517,13 @@
              'manifest_parser_test',
              'ninja_test',
              'state_test',
-             'string_piece_util_test',
              'subprocess_test',
              'test',
              'util_test']:
-    objs += cxx(name, variables=cxxvariables)
+    objs += cxx(name)
 if platform.is_windows():
     for name in ['includes_normalize_test', 'msvc_helper_test']:
-        objs += cxx(name, variables=cxxvariables)
+        objs += cxx(name)
 
 ninja_test = n.build(binary('ninja_test'), 'link', objs, implicit=ninja_lib,
                      variables=[('libs', libs)])
@@ -586,19 +532,21 @@
 
 
 n.comment('Ancillary executables.')
-
-for name in ['build_log_perftest',
-             'canon_perftest',
-             'depfile_parser_perftest',
-             'hash_collision_bench',
-             'manifest_parser_perftest',
-             'clparser_perftest']:
-  if platform.is_msvc():
-    cxxvariables = [('pdb', name + '.pdb')]
-  objs = cxx(name, variables=cxxvariables)
-  all_targets += n.build(binary(name), 'link', objs,
-                         implicit=ninja_lib, variables=[('libs', libs)])
-
+objs = cxx('build_log_perftest')
+all_targets += n.build(binary('build_log_perftest'), 'link', objs,
+                       implicit=ninja_lib, variables=[('libs', libs)])
+objs = cxx('canon_perftest')
+all_targets += n.build(binary('canon_perftest'), 'link', objs,
+                       implicit=ninja_lib, variables=[('libs', libs)])
+objs = cxx('depfile_parser_perftest')
+all_targets += n.build(binary('depfile_parser_perftest'), 'link', objs,
+                       implicit=ninja_lib, variables=[('libs', libs)])
+objs = cxx('hash_collision_bench')
+all_targets += n.build(binary('hash_collision_bench'), 'link', objs,
+                              implicit=ninja_lib, variables=[('libs', libs)])
+objs = cxx('manifest_parser_perftest')
+all_targets += n.build(binary('manifest_parser_perftest'), 'link', objs,
+                              implicit=ninja_lib, variables=[('libs', libs)])
 n.newline()
 
 n.comment('Generate a graph using the "graph" tool.')
@@ -617,19 +565,13 @@
 n.rule('xsltproc',
        command='xsltproc --nonet doc/docbook.xsl $in > $out',
        description='XSLTPROC $out')
-docbookxml = n.build(built('manual.xml'), 'asciidoc', doc('manual.asciidoc'))
-manual = n.build(doc('manual.html'), 'xsltproc', docbookxml,
-                 implicit=[doc('style.css'), doc('docbook.xsl')])
+xml = n.build(built('manual.xml'), 'asciidoc', doc('manual.asciidoc'))
+manual = n.build(doc('manual.html'), 'xsltproc', xml,
+                 implicit=doc('style.css'))
 n.build('manual', 'phony',
         order_only=manual)
 n.newline()
 
-n.rule('dblatex',
-       command='dblatex -q -o $out -p doc/dblatex.xsl $in',
-       description='DBLATEX $out')
-n.build(doc('manual.pdf'), 'dblatex', docbookxml,
-        implicit=[doc('dblatex.xsl')])
-
 n.comment('Generate Doxygen.')
 n.rule('doxygen',
        command='doxygen $in',
@@ -649,12 +591,11 @@
 if not host.is_mingw():
     n.comment('Regenerate build files if build script changes.')
     n.rule('configure',
-           command='${configure_env}%s $root/configure.py $configure_args' %
+           command='${configure_env}%s configure.py $configure_args' %
                options.with_python,
            generator=True)
     n.build('build.ninja', 'configure',
-            implicit=['$root/configure.py',
-                      os.path.normpath('$root/misc/ninja_syntax.py')])
+            implicit=['configure.py', os.path.normpath('misc/ninja_syntax.py')])
     n.newline()
 
 n.default(ninja)
@@ -673,28 +614,17 @@
 n.close()
 print('wrote %s.' % BUILD_FILENAME)
 
+verbose = ''
+if options.verbose:
+    verbose = ' -v'
+
 if options.bootstrap:
     print('bootstrap complete.  rebuilding...')
-
-    rebuild_args = []
-
-    if platform.can_rebuild_in_place():
-        rebuild_args.append('./ninja')
-    else:
-        if platform.is_windows():
-            bootstrap_exe = 'ninja.bootstrap.exe'
-            final_exe = 'ninja.exe'
-        else:
-            bootstrap_exe = './ninja.bootstrap'
-            final_exe = './ninja'
-
+    if platform.is_windows():
+        bootstrap_exe = 'ninja.bootstrap.exe'
         if os.path.exists(bootstrap_exe):
             os.unlink(bootstrap_exe)
-        os.rename(final_exe, bootstrap_exe)
-
-        rebuild_args.append(bootstrap_exe)
-
-    if options.verbose:
-        rebuild_args.append('-v')
-
-    subprocess.check_call(rebuild_args)
+        os.rename('ninja.exe', bootstrap_exe)
+        subprocess.check_call('ninja.bootstrap.exe%s' % verbose, shell=True)
+    else:
+        subprocess.check_call('./ninja%s' % verbose, shell=True)
diff -Naur ninja-1.9.0.orig/doc/README.md ninja/doc/README.md
--- ninja-1.9.0.orig/doc/README.md	2019-01-30 13:58:59.000000000 +0000
+++ ninja/doc/README.md	1969-12-31 19:00:00.000000000 +0000
@@ -1,11 +0,0 @@
-This directory contains the Ninja manual and support files used in
-building it.  Here's a brief overview of how it works.
-
-The source text, `manual.asciidoc`, is written in the AsciiDoc format.
-AsciiDoc can generate HTML but it doesn't look great; instead, we use
-AsciiDoc to generate the Docbook XML format and then provide our own
-Docbook XSL tweaks to produce HTML from that.
-
-In theory using AsciiDoc and DocBook allows us to produce nice PDF
-documentation etc.  In reality it's not clear anyone wants that, but the
-build rules are in place to generate it if you install dblatex.
diff -Naur ninja-1.9.0.orig/doc/dblatex.xsl ninja/doc/dblatex.xsl
--- ninja-1.9.0.orig/doc/dblatex.xsl	2019-01-30 13:58:59.000000000 +0000
+++ ninja/doc/dblatex.xsl	1969-12-31 19:00:00.000000000 +0000
@@ -1,7 +0,0 @@
-<!-- This custom XSL tweaks the dblatex XML settings. -->
-<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>
-  <!-- These parameters disable the list of collaborators and revisions.
-       Together remove a useless page from the front matter. -->
-  <xsl:param name='doc.collab.show'>0</xsl:param>
-  <xsl:param name='latex.output.revhistory'>0</xsl:param>
-</xsl:stylesheet>
diff -Naur ninja-1.9.0.orig/doc/docbook.xsl ninja/doc/docbook.xsl
--- ninja-1.9.0.orig/doc/docbook.xsl	2019-01-30 13:58:59.000000000 +0000
+++ ninja/doc/docbook.xsl	2019-09-24 19:51:29.568335338 +0000
@@ -1,29 +1,15 @@
-<!-- This custom XSL tweaks the DocBook XML -> HTML settings to produce
-     an OK-looking manual.  -->
+<!-- This soup of XML is the minimum customization necessary to make the
+     autogenerated manual look ok. -->
 <!DOCTYPE xsl:stylesheet [
 <!ENTITY css SYSTEM "style.css">
 ]>
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
 		version='1.0'>
   <xsl:import href="http://docbook.sourceforge.net/release/xsl/current/html/docbook.xsl"/>
-
-  <!-- Embed our stylesheet as the user-provided <head> content. -->
   <xsl:template name="user.head.content"><style>&css;</style></xsl:template>
-
-  <!-- Remove the body.attributes block, which specifies a bunch of
-       useless bgcolor etc. attrs on the <body> tag. -->
   <xsl:template name="body.attributes"></xsl:template>
-
-  <!-- Specify that in "book" form (which we're using), we only want a
-       single table of contents at the beginning of the document. -->
-  <xsl:param name="generate.toc">book toc</xsl:param>
-
-  <!-- Don't put the "Chapter 1." prefix on the "chapters". -->
-  <xsl:param name="chapter.autolabel">0</xsl:param>
-
-  <!-- Use <ul> for the table of contents.  By default DocBook uses a
-       <dl>, which makes no semantic sense.  I imagine they just did
-       it because it looks nice? -->
+  <xsl:param name="generate.toc" select="'book toc'"/>
+  <xsl:param name="chapter.autolabel" select="0" />
   <xsl:param name="toc.list.type">ul</xsl:param>
 
   <xsl:output method="html" encoding="utf-8" indent="no"
diff -Naur ninja-1.9.0.orig/doc/manual.asciidoc ninja/doc/manual.asciidoc
--- ninja-1.9.0.orig/doc/manual.asciidoc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/doc/manual.asciidoc	2019-09-24 19:51:29.572601738 +0000
@@ -1,6 +1,7 @@
-The Ninja build system
-======================
-v1.9.0, Jan 2019
+Ninja
+=====
+Evan Martin <martine@danga.com>
+v1.6.0, Jun 2015
 
 
 Introduction
@@ -155,16 +156,21 @@
 Ninja's benefit comes from using it in conjunction with a smarter
 meta-build system.
 
-https://gn.googlesource.com/gn/[gn]:: The meta-build system used to
+http://code.google.com/p/gyp/[gyp]:: The meta-build system used to
 generate build files for Google Chrome and related projects (v8,
-node.js), as well as Google Fuschia.  gn can generate Ninja files for
-all platforms supported by Chrome.
+node.js).  gyp can generate Ninja files for all platforms supported by
+Chrome. See the
+http://code.google.com/p/chromium/wiki/NinjaBuild[Chromium Ninja
+documentation for more details].
+
+http://www.cmake.org/[CMake]:: A widely used meta-build system that
+can generate Ninja files on Linux as of CMake version 2.8.8.  (There
+is some Mac and Windows support -- http://www.reactos.org[ReactOS]
+uses Ninja on Windows for their buildbots, but those platforms are not
+yet officially supported by CMake as the full test suite doesn't
+pass.)
 
-https://cmake.org/[CMake]:: A widely used meta-build system that
-can generate Ninja files on Linux as of CMake version 2.8.8.  Newer versions
-of CMake support generating Ninja files on Windows and Mac OS X too.
-
-https://github.com/ninja-build/ninja/wiki/List-of-generators-producing-ninja-build-files[others]:: Ninja ought to fit perfectly into other meta-build software
+others:: Ninja ought to fit perfectly into other meta-build software
 like http://industriousone.com/premake[premake].  If you do this work,
 please let us know!
 
@@ -208,7 +214,7 @@
 `%e`:: Elapsed time in seconds.  _(Available since Ninja 1.2.)_
 `%%`:: A plain `%` character.
 
-The default progress status is `"[%f/%t] "` (note the trailing space
+The default progress status is `"[%s/%t] "` (note the trailing space
 to separate from the build rule). Another example of possible progress status
 could be `"[%u/%r/%f] "`.
 
@@ -223,13 +229,8 @@
 
 `browse`:: browse the dependency graph in a web browser.  Clicking a
 file focuses the view on that file, showing inputs and outputs.  This
-feature requires a Python installation. By default port 8000 is used
-and a web browser will be opened. This can be changed as follows:
-+
-----
-ninja -t browse --port=8000 --no-browser mytarget
-----
-+
+feature requires a Python installation.
+
 `graph`:: output a file in the syntax used by `graphviz`, a automatic
 graph layout tool.  Use it like:
 +
@@ -279,11 +280,6 @@
 by the Clang tooling interface.
 _Available since Ninja 1.2._
 
-`deps`:: show all dependencies stored in the `.ninja_deps` file. When given a
-target, show just the target's dependencies. _Available since Ninja 1.4._
-
-`recompact`:: recompact the `.ninja_deps` file. _Available since Ninja 1.4._
-
 
 Writing your own Ninja files
 ----------------------------
@@ -593,7 +589,7 @@
    to its stdout.  Ninja then filters these lines from the displayed
    output.  No `depfile` attribute is necessary, but the localized string
    in front of the the header file path. For instance
-   `msvc_deps_prefix = Note: including file:`
+   `msvc_deps_prefix = Note: including file: `
    for a English Visual Studio (the default). Should be globally defined.
 +
 ----
@@ -603,11 +599,6 @@
   command = cl /showIncludes -c $in /Fo$out
 ----
 
-If the include directory directives are using absolute paths, your depfile
-may result in a mixture of relative and absolute paths. Paths used by other
-build rules need to match exactly. Therefore, it is recommended to use
-relative paths in these cases.
-
 [[ref_pool]]
 Pools
 ~~~~~
@@ -695,10 +686,6 @@
    Order-only dependencies may be tacked on the end with +||
    _dependency1_ _dependency2_+.  (See <<ref_dependencies,the reference on
    dependency types>>.)
-+
-Implicit outputs _(available since Ninja 1.7)_ may be added before
-the `:` with +| _output1_ _output2_+ and do not appear in `$out`.
-(See <<ref_outputs,the reference on output types>>.)
 
 3. Variable declarations, which look like +_variable_ = _value_+.
 
@@ -727,6 +714,7 @@
 There is only one escape character, `$`, and it has the following
 behaviors:
 
+[horizontal]
 `$` followed by a newline:: escape the newline (continue the current line
 across a line break).
 
@@ -791,9 +779,11 @@
 affect the processing of the rule.  Here is a full list of special
 keys.
 
-`command` (_required_):: the command line to run.  Each `rule` may
-  have only one `command` declaration. See <<ref_rule_command,the next
-  section>> for more details on quoting and executing multiple commands.
+`command` (_required_):: the command line to run.  This string (after
+  $variables are expanded) is passed directly to `sh -c` without
+  interpretation by Ninja. Each `rule` may have only one `command`
+  declaration. To specify multiple commands use `&&` (or similar) to
+  concatenate operations.
 
 `depfile`:: path to an optional `Makefile` that contains extra
   _implicit dependencies_ (see <<ref_dependencies,the reference on
@@ -861,49 +851,6 @@
 build myapp.exe: link a.obj b.obj [possibly many other .obj files]
 ----
 
-[[ref_rule_command]]
-Interpretation of the `command` variable
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-Fundamentally, command lines behave differently on Unixes and Windows.
-
-On Unixes, commands are arrays of arguments.  The Ninja `command`
-variable is passed directly to `sh -c`, which is then responsible for
-interpreting that string into an argv array.  Therefore the quoting
-rules are those of the shell, and you can use all the normal shell
-operators, like `&&` to chain multiple commands, or `VAR=value cmd` to
-set environment variables.
-
-On Windows, commands are strings, so Ninja passes the `command` string
-directly to `CreateProcess`.  (In the common case of simply executing
-a compiler this means there is less overhead.)  Consequently the
-quoting rules are deterimined by the called program, which on Windows
-are usually provided by the C library.  If you need shell
-interpretation of the command (such as the use of `&&` to chain
-multiple commands), make the command execute the Windows shell by
-prefixing the command with `cmd /c`. Ninja may error with "invalid parameter"
-which usually indicates that the command line length has been exceeded.
-
-[[ref_outputs]]
-Build outputs
-~~~~~~~~~~~~~
-
-There are two types of build outputs which are subtly different.
-
-1. _Explicit outputs_, as listed in a build line.  These are
-   available as the `$out` variable in the rule.
-+
-This is the standard form of output to be used for e.g. the
-object file of a compile command.
-
-2. _Implicit outputs_, as listed in a build line with the syntax +|
-   _out1_ _out2_+ + before the `:` of a build line _(available since
-   Ninja 1.7)_.  The semantics are identical to explicit outputs,
-  the only difference is that implicit outputs don't show up in the
-  `$out` variable.
-+
-This is for expressing outputs that don't show up on the
-command line of the command.
-
 [[ref_dependencies]]
 Build dependencies
 ~~~~~~~~~~~~~~~~~~
@@ -915,7 +862,7 @@
    cause the output to be rebuilt; if these file are missing and
    Ninja doesn't know how to build them, the build is aborted.
 +
-This is the standard form of dependency to be used e.g. for the
+This is the standard form of dependency to be used for e.g. the
 source file of a compile command.
 
 2. _Implicit dependencies_, either as picked up from
@@ -943,9 +890,6 @@
 header is used in compilation, a generated dependency file will then
 express the implicit dependency.)
 
-File paths are compared as is, which means that an absolute path and a
-relative path, pointing to the same file, are considered different by Ninja.
-
 Variable expansion
 ~~~~~~~~~~~~~~~~~~
 
@@ -1004,3 +948,4 @@
 
 5. Variables from the file that included that file using the
    `subninja` keyword.
+
diff -Naur ninja-1.9.0.orig/doc/style.css ninja/doc/style.css
--- ninja-1.9.0.orig/doc/style.css	2019-01-30 13:58:59.000000000 +0000
+++ ninja/doc/style.css	2019-09-24 19:51:29.573087338 +0000
@@ -24,6 +24,12 @@
     margin-top: 4em;
     border-top: solid 2px black;
 }
+.section .title {
+    font-size: 1.3em;
+}
+.section .section .title {
+    font-size: 1.2em;
+}
 p {
     margin-top: 0;
 }
diff -Naur ninja-1.9.0.orig/misc/bash-completion ninja/misc/bash-completion
--- ninja-1.9.0.orig/misc/bash-completion	2019-01-30 13:58:59.000000000 +0000
+++ ninja/misc/bash-completion	2019-09-24 19:51:29.573918538 +0000
@@ -49,8 +49,9 @@
 		C) eval dir="$OPTARG" ;;
 	    esac
 	done;
-	targets_command="eval ninja -C \"${dir}\" -t targets all 2>/dev/null | cut -d: -f1"
-	COMPREPLY=($(compgen -W '`${targets_command}`' -- "$cur"))
+	targets_command="eval ninja -C \"${dir}\" -t targets all"
+	targets=$(${targets_command} 2>/dev/null | awk -F: '{print $1}')
+	COMPREPLY=($(compgen -W "$targets" -- "$cur"))
     fi
     return
 }
diff -Naur ninja-1.9.0.orig/misc/measure.py ninja/misc/measure.py
--- ninja-1.9.0.orig/misc/measure.py	2019-01-30 13:58:59.000000000 +0000
+++ ninja/misc/measure.py	2019-09-24 19:51:29.574524138 +0000
@@ -17,8 +17,6 @@
 """measure the runtime of a command by repeatedly running it.
 """
 
-from __future__ import print_function
-
 import time
 import subprocess
 import sys
@@ -26,7 +24,7 @@
 devnull = open('/dev/null', 'w')
 
 def run(cmd, repeat=10):
-    print('sampling:', end=' ')
+    print 'sampling:',
     sys.stdout.flush()
 
     samples = []
@@ -35,10 +33,10 @@
         subprocess.call(cmd, stdout=devnull, stderr=devnull)
         end = time.time()
         dt = (end - start) * 1000
-        print('%dms' % int(dt), end=' ')
+        print '%dms' % int(dt),
         sys.stdout.flush()
         samples.append(dt)
-    print()
+    print
 
     # We're interested in the 'pure' runtime of the code, which is
     # conceptually the smallest time we'd see if we ran it enough times
@@ -47,10 +45,10 @@
     # Also print how varied the outputs were in an attempt to make it
     # more obvious if something has gone terribly wrong.
     err = sum(s - best for s in samples) / float(len(samples))
-    print('estimate: %dms (mean err %.1fms)' % (best, err))
+    print 'estimate: %dms (mean err %.1fms)' % (best, err)
 
 if __name__ == '__main__':
     if len(sys.argv) < 2:
-        print('usage: measure.py command args...')
+        print 'usage: measure.py command args...'
         sys.exit(1)
     run(cmd=sys.argv[1:])
diff -Naur ninja-1.9.0.orig/misc/ninja-mode.el ninja/misc/ninja-mode.el
--- ninja-1.9.0.orig/misc/ninja-mode.el	2019-01-30 13:58:59.000000000 +0000
+++ ninja/misc/ninja-mode.el	2019-09-24 19:51:29.575246538 +0000
@@ -56,7 +56,7 @@
                (save-excursion
                  (goto-char (line-end-position 0))
                  (or
-                  ;; If we're continuing the previous line, it's not a
+                  ;; If we're continuting the previous line, it's not a
                   ;; comment.
                   (not (eq ?$ (char-before)))
                   ;; Except if the previous line is a comment as well, as the
diff -Naur ninja-1.9.0.orig/misc/ninja.vim ninja/misc/ninja.vim
--- ninja-1.9.0.orig/misc/ninja.vim	2019-01-30 13:58:59.000000000 +0000
+++ ninja/misc/ninja.vim	2019-09-24 19:51:29.575924938 +0000
@@ -1,16 +1,16 @@
 " ninja build file syntax.
 " Language: ninja build file as described at
-"           http://ninja-build.org/manual.html
-" Version: 1.5
-" Last Change: 2018/04/05
+"           http://martine.github.com/ninja/manual.html
+" Version: 1.4
+" Last Change: 2014/05/13
 " Maintainer: Nicolas Weber <nicolasweber@gmx.de>
 " Version 1.4 of this script is in the upstream vim repository and will be
 " included in the next vim release. If you change this, please send your change
 " upstream.
 
 " ninja lexer and parser are at
-" https://github.com/ninja-build/ninja/blob/master/src/lexer.in.cc
-" https://github.com/ninja-build/ninja/blob/master/src/manifest_parser.cc
+" https://github.com/martine/ninja/blob/master/src/lexer.in.cc
+" https://github.com/martine/ninja/blob/master/src/manifest_parser.cc
 
 if exists("b:current_syntax")
   finish
@@ -21,10 +21,7 @@
 
 syn case match
 
-" Comments are only matched when the # is at the beginning of the line (with
-" optional whitespace), as long as the prior line didn't end with a $
-" continuation.
-syn match ninjaComment /\(\$\n\)\@<!\_^\s*#.*$/  contains=@Spell
+syn match ninjaComment /#.*/  contains=@Spell
 
 " Toplevel statements are the ones listed here and
 " toplevel variable assignments (ident '=' value).
@@ -41,13 +38,12 @@
 " limited set of magic variables, 'build' allows general
 " let assignments.
 " manifest_parser.cc, ParseRule()
-syn region ninjaRule start="^rule" end="^\ze\S" contains=TOP transparent
-syn keyword ninjaRuleCommand contained containedin=ninjaRule command
-                                     \ deps depfile description generator
+syn region ninjaRule start="^rule" end="^\ze\S" contains=ALL transparent
+syn keyword ninjaRuleCommand contained command deps depfile description generator
                                      \ pool restat rspfile rspfile_content
 
-syn region ninjaPool start="^pool" end="^\ze\S" contains=TOP transparent
-syn keyword ninjaPoolCommand contained containedin=ninjaPool  depth
+syn region ninjaPool start="^pool" end="^\ze\S" contains=ALL transparent
+syn keyword ninjaPoolCommand contained depth
 
 " Strings are parsed as follows:
 " lexer.in.cc, ReadEvalString()
diff -Naur ninja-1.9.0.orig/misc/ninja_syntax.py ninja/misc/ninja_syntax.py
--- ninja-1.9.0.orig/misc/ninja_syntax.py	2019-01-30 13:58:59.000000000 +0000
+++ ninja/misc/ninja_syntax.py	2019-09-24 19:51:29.577003338 +0000
@@ -22,8 +22,7 @@
         self.output.write('\n')
 
     def comment(self, text):
-        for line in textwrap.wrap(text, self.width - 2, break_long_words=False,
-                                  break_on_hyphens=False):
+        for line in textwrap.wrap(text, self.width - 2):
             self.output.write('# ' + line + '\n')
 
     def variable(self, key, value, indent=0):
@@ -60,7 +59,7 @@
             self.variable('deps', deps, indent=1)
 
     def build(self, outputs, rule, inputs=None, implicit=None, order_only=None,
-              variables=None, implicit_outputs=None, pool=None):
+              variables=None):
         outputs = as_list(outputs)
         out_outputs = [escape_path(x) for x in outputs]
         all_inputs = [escape_path(x) for x in as_list(inputs)]
@@ -73,16 +72,9 @@
             order_only = [escape_path(x) for x in as_list(order_only)]
             all_inputs.append('||')
             all_inputs.extend(order_only)
-        if implicit_outputs:
-            implicit_outputs = [escape_path(x)
-                                for x in as_list(implicit_outputs)]
-            out_outputs.append('|')
-            out_outputs.extend(implicit_outputs)
 
         self._line('build %s: %s' % (' '.join(out_outputs),
                                      ' '.join([rule] + all_inputs)))
-        if pool is not None:
-            self._line('  pool = %s' % pool)
 
         if variables:
             if isinstance(variables, dict):
diff -Naur ninja-1.9.0.orig/misc/ninja_syntax_test.py ninja/misc/ninja_syntax_test.py
--- ninja-1.9.0.orig/misc/ninja_syntax_test.py	2019-01-30 13:58:59.000000000 +0000
+++ ninja/misc/ninja_syntax_test.py	2019-09-24 19:51:29.577952938 +0000
@@ -45,14 +45,8 @@
                                       INDENT + 'y']) + '\n',
                          self.out.getvalue())
 
-    def test_comment_wrap(self):
-        # Filenames should not be wrapped
-        self.n.comment('Hello /usr/local/build-tools/bin')
-        self.assertEqual('# Hello\n# /usr/local/build-tools/bin\n',
-                         self.out.getvalue())
-
     def test_short_words_indented(self):
-        # Test that indent is taking into account when breaking subsequent lines.
+        # Test that indent is taking into acount when breaking subsequent lines.
         # The second line should not be '    to tree', as that's longer than the
         # test layout width of 8.
         self.n._line('line_one to tree')
@@ -154,13 +148,6 @@
 ''',
                          self.out.getvalue())
 
-    def test_implicit_outputs(self):
-        self.n.build('o', 'cc', 'i', implicit_outputs='io')
-        self.assertEqual('''\
-build o | io: cc i
-''',
-                         self.out.getvalue())
-
 class TestExpand(unittest.TestCase):
     def test_basic(self):
         vars = {'x': 'X'}
diff -Naur ninja-1.9.0.orig/misc/output_test.py ninja/misc/output_test.py
--- ninja-1.9.0.orig/misc/output_test.py	2019-01-30 13:58:59.000000000 +0000
+++ ninja/misc/output_test.py	1969-12-31 19:00:00.000000000 +0000
@@ -1,103 +0,0 @@
-#!/usr/bin/env python3
-
-"""Runs ./ninja and checks if the output is correct.
-
-In order to simulate a smart terminal it uses the 'script' command.
-"""
-
-import os
-import platform
-import subprocess
-import sys
-import tempfile
-import unittest
-
-default_env = dict(os.environ)
-if 'NINJA_STATUS' in default_env:
-    del default_env['NINJA_STATUS']
-if 'CLICOLOR_FORCE' in default_env:
-    del default_env['CLICOLOR_FORCE']
-default_env['TERM'] = ''
-
-def run(build_ninja, flags='', pipe=False, env=default_env):
-    with tempfile.NamedTemporaryFile('w') as f:
-        f.write(build_ninja)
-        f.flush()
-        ninja_cmd = './ninja {} -f {}'.format(flags, f.name)
-        try:
-            if pipe:
-                output = subprocess.check_output([ninja_cmd], shell=True, env=env)
-            elif platform.system() == 'Darwin':
-                output = subprocess.check_output(['script', '-q', '/dev/null', 'bash', '-c', ninja_cmd],
-                                                 env=env)
-            else:
-                output = subprocess.check_output(['script', '-qfec', ninja_cmd, '/dev/null'],
-                                                 env=env)
-        except subprocess.CalledProcessError as err:
-            sys.stdout.buffer.write(err.output)
-            raise err
-    final_output = ''
-    for line in output.decode('utf-8').splitlines(True):
-        if len(line) > 0 and line[-1] == '\r':
-            continue
-        final_output += line.replace('\r', '')
-    return final_output
-
-class Output(unittest.TestCase):
-    def test_issue_1418(self):
-        self.assertEqual(run(
-'''rule echo
-  command = sleep $delay && echo $out
-  description = echo $out
-
-build a: echo
-  delay = 3
-build b: echo
-  delay = 2
-build c: echo
-  delay = 1
-'''),
-'''[1/3] echo c\x1b[K
-c
-[2/3] echo b\x1b[K
-b
-[3/3] echo a\x1b[K
-a
-''')
-
-    def test_issue_1214(self):
-        print_red = '''rule echo
-  command = printf '\x1b[31mred\x1b[0m'
-  description = echo $out
-
-build a: echo
-'''
-        # Only strip color when ninja's output is piped.
-        self.assertEqual(run(print_red),
-'''[1/1] echo a\x1b[K
-\x1b[31mred\x1b[0m
-''')
-        self.assertEqual(run(print_red, pipe=True),
-'''[1/1] echo a
-red
-''')
-        # Even in verbose mode, colors should still only be stripped when piped.
-        self.assertEqual(run(print_red, flags='-v'),
-'''[1/1] printf '\x1b[31mred\x1b[0m'
-\x1b[31mred\x1b[0m
-''')
-        self.assertEqual(run(print_red, flags='-v', pipe=True),
-'''[1/1] printf '\x1b[31mred\x1b[0m'
-red
-''')
-
-        # CLICOLOR_FORCE=1 can be used to disable escape code stripping.
-        env = default_env.copy()
-        env['CLICOLOR_FORCE'] = '1'
-        self.assertEqual(run(print_red, pipe=True, env=env),
-'''[1/1] echo a
-\x1b[31mred\x1b[0m
-''')
-
-if __name__ == '__main__':
-    unittest.main()
diff -Naur ninja-1.9.0.orig/misc/packaging/ninja.spec ninja/misc/packaging/ninja.spec
--- ninja-1.9.0.orig/misc/packaging/ninja.spec	2019-01-30 13:58:59.000000000 +0000
+++ ninja/misc/packaging/ninja.spec	2019-09-24 19:51:29.578747338 +0000
@@ -4,7 +4,7 @@
 Release: %{rel}%{?dist}
 Group: Development/Tools
 License: Apache 2.0
-URL: https://github.com/ninja-build/ninja
+URL: https://github.com/martine/ninja
 Source0: %{name}-%{version}-%{rel}.tar.gz
 BuildRoot: %{_tmppath}/%{name}-%{version}-%{rel}
 
diff -Naur ninja-1.9.0.orig/misc/write_fake_manifests.py ninja/misc/write_fake_manifests.py
--- ninja-1.9.0.orig/misc/write_fake_manifests.py	2019-01-30 13:58:59.000000000 +0000
+++ ninja/misc/write_fake_manifests.py	2019-09-24 19:51:29.579732138 +0000
@@ -50,10 +50,9 @@
 
 
 class GenRandom(object):
-    def __init__(self, src_dir):
+    def __init__(self):
         self.seen_names = set([None])
         self.seen_defines = set([None])
-        self.src_dir = src_dir
 
     def _unique_string(self, seen, avg_options=1.3, p_suffix=0.1):
         s = None
@@ -77,7 +76,7 @@
 
     def src_obj_pairs(self, path, name):
         num_sources = paretoint(55, alpha=2) + 1
-        return [(os.path.join(self.src_dir, path, s + '.cc'),
+        return [(os.path.join('..', '..', path, s + '.cc'),
                  os.path.join('obj', path, '%s.%s.o' % (name, s)))
                 for s in self._n_unique_strings(num_sources)]
 
@@ -104,8 +103,12 @@
         self.kind = kind
         self.has_compile_depends = random.random() < 0.4
 
+    @property
+    def includes(self):
+        return ['-I' + dep.dir_path for dep in self.deps]
 
-def write_target_ninja(ninja, target, src_dir):
+
+def write_target_ninja(ninja, target):
     compile_depends = None
     if target.has_compile_depends:
       compile_depends = os.path.join(
@@ -114,7 +117,8 @@
       ninja.newline()
 
     ninja.variable('defines', target.defines)
-    ninja.variable('includes', '-I' + src_dir)
+    if target.deps:
+        ninja.variable('includes', target.includes)
     ninja.variable('cflags', ['-Wall', '-fno-rtti', '-fno-exceptions'])
     ninja.newline()
 
@@ -125,63 +129,17 @@
     deps = [dep.output for dep in target.deps]
     libs = [dep.output for dep in target.deps if dep.kind == LIB]
     if target.kind == EXE:
+        ninja.variable('ldflags', '-Wl,pie')
         ninja.variable('libs', libs)
-        if sys.platform == "darwin":
-            ninja.variable('ldflags', '-Wl,-pie')
     link = { LIB: 'alink', EXE: 'link'}[target.kind]
     ninja.build(target.output, link, [obj for _, obj in target.src_obj_pairs],
                 implicit=deps)
 
 
-def write_sources(target, root_dir):
-    need_main = target.kind == EXE
-
-    includes = []
-
-    # Include siblings.
-    for cc_filename, _ in target.src_obj_pairs:
-        h_filename = os.path.basename(os.path.splitext(cc_filename)[0] + '.h')
-        includes.append(h_filename)
-
-    # Include deps.
-    for dep in target.deps:
-        for cc_filename, _ in dep.src_obj_pairs:
-            h_filename = os.path.basename(
-                os.path.splitext(cc_filename)[0] + '.h')
-            includes.append("%s/%s" % (dep.dir_path, h_filename))
-
-    for cc_filename, _ in target.src_obj_pairs:
-        cc_path = os.path.join(root_dir, cc_filename)
-        h_path = os.path.splitext(cc_path)[0] + '.h'
-        namespace = os.path.basename(target.dir_path)
-        class_ = os.path.splitext(os.path.basename(cc_filename))[0]
-        try:
-            os.makedirs(os.path.dirname(cc_path))
-        except OSError:
-            pass
-
-        with open(h_path, 'w') as f:
-            f.write('namespace %s { struct %s { %s(); }; }' % (namespace,
-                                                               class_, class_))
-        with open(cc_path, 'w') as f:
-            for include in includes:
-                f.write('#include "%s"\n' % include)
-            f.write('\n')
-            f.write('namespace %s { %s::%s() {} }' % (namespace,
-                                                      class_, class_))
-
-            if need_main:
-                f.write('int main(int argc, char **argv) {}\n')
-                need_main = False
-
 def write_master_ninja(master_ninja, targets):
     """Writes master build.ninja file, referencing all given subninjas."""
     master_ninja.variable('cxx', 'c++')
     master_ninja.variable('ld', '$cxx')
-    if sys.platform == 'darwin':
-        master_ninja.variable('alink', 'libtool -static')
-    else:
-        master_ninja.variable('alink', 'ar rcs')
     master_ninja.newline()
 
     master_ninja.pool('link_pool', depth=4)
@@ -190,8 +148,8 @@
     master_ninja.rule('cxx', description='CXX $out',
       command='$cxx -MMD -MF $out.d $defines $includes $cflags -c $in -o $out',
       depfile='$out.d', deps='gcc')
-    master_ninja.rule('alink', description='ARCHIVE $out',
-      command='rm -f $out && $alink -o $out $in')
+    master_ninja.rule('alink', description='LIBTOOL-STATIC $out',
+      command='rm -f $out && libtool -static -o $out $in')
     master_ninja.rule('link', description='LINK $out', pool='link_pool',
       command='$ld $ldflags -o $out $in $libs')
     master_ninja.rule('stamp', description='STAMP $out', command='touch $out')
@@ -223,8 +181,9 @@
     f.close()
 
 
-def random_targets(num_targets, src_dir):
-    gen = GenRandom(src_dir)
+def random_targets():
+    num_targets = 1500
+    gen = GenRandom()
 
     # N-1 static libraries, and 1 executable depending on all of them.
     targets = [Target(gen, LIB) for i in xrange(num_targets - 1)]
@@ -240,28 +199,16 @@
 
 def main():
     parser = argparse.ArgumentParser()
-    parser.add_argument('-s', '--sources', nargs="?", const="src",
-        help='write sources to directory (relative to output directory)')
-    parser.add_argument('-t', '--targets', type=int, default=1500,
-                        help='number of targets (default: 1500)')
-    parser.add_argument('-S', '--seed', type=int, help='random seed',
-                        default=12345)
     parser.add_argument('outdir', help='output directory')
     args = parser.parse_args()
     root_dir = args.outdir
 
-    random.seed(args.seed)
-
-    do_write_sources = args.sources is not None
-    src_dir = args.sources if do_write_sources else "src"
+    random.seed(12345)
 
-    targets = random_targets(args.targets, src_dir)
+    targets = random_targets()
     for target in targets:
         with FileWriter(os.path.join(root_dir, target.ninja_file_path)) as n:
-            write_target_ninja(n, target, src_dir)
-
-        if do_write_sources:
-            write_sources(target, root_dir)
+            write_target_ninja(n, target)
 
     with FileWriter(os.path.join(root_dir, 'build.ninja')) as master_ninja:
         master_ninja.width = 120
diff -Naur ninja-1.9.0.orig/misc/zsh-completion ninja/misc/zsh-completion
--- ninja-1.9.0.orig/misc/zsh-completion	2019-01-30 13:58:59.000000000 +0000
+++ ninja/misc/zsh-completion	2019-09-24 19:51:29.580420138 +0000
@@ -14,7 +14,7 @@
 # limitations under the License.
 
 # Add the following to your .zshrc to tab-complete ninja targets
-#   fpath=(path/to/ninja/misc/zsh-completion $fpath)
+#   . path/to/ninja/misc/zsh-completion
 
 __get_targets() {
   dir="."
@@ -22,13 +22,9 @@
   then
     eval dir="${opt_args[-C]}"
   fi
-  file="build.ninja"
-  if [ -n "${opt_args[-f]}" ];
-  then
-    eval file="${opt_args[-f]}"
-  fi
-  targets_command="ninja -f \"${file}\" -C \"${dir}\" -t targets all"
-  eval ${targets_command} 2>/dev/null | cut -d: -f1
+  targets_command="ninja -C \"${dir}\" -t targets"
+  eval ${targets_command} 2>/dev/null | while read -r a b; do echo $a | cut -d ':' -f1; done;
+
 }
 
 __get_tools() {
@@ -70,3 +66,4 @@
   '-d+[Enable debugging (use -d list to list modes)]:modes:__modes' \
   '-t+[Run a subtool (use -t list to list subtools)]:tools:__tools' \
   '*::targets:__targets'
+
diff -Naur ninja-1.9.0.orig/src/browse.cc ninja/src/browse.cc
--- ninja-1.9.0.orig/src/browse.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/browse.cc	2019-09-24 19:51:29.581166538 +0000
@@ -14,16 +14,14 @@
 
 #include "browse.h"
 
-#include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
-#include <vector>
 
-#include "build/browse_py.h"
+#include "../build/browse_py.h"
 
 void RunBrowsePython(State* state, const char* ninja_command,
-                     const char* input_file, int argc, char* argv[]) {
+                     const char* initial_target) {
   // Fork off a Python process and have it run our code via its stdin.
   // (Actually the Python process becomes the parent.)
   int pipefd[2];
@@ -46,23 +44,12 @@
         break;
       }
 
-      std::vector<const char *> command;
-      command.push_back(NINJA_PYTHON);
-      command.push_back("-");
-      command.push_back("--ninja-command");
-      command.push_back(ninja_command);
-      command.push_back("-f");
-      command.push_back(input_file);
-      for (int i = 0; i < argc; i++) {
-          command.push_back(argv[i]);
-      }
-      command.push_back(NULL);
-      execvp(command[0], (char**)&command[0]);
-      if (errno == ENOENT) {
-        printf("ninja: %s is required for the browse tool\n", NINJA_PYTHON);
-      } else {
-        perror("ninja: execvp");
-      }
+      // exec Python, telling it to run the program from stdin.
+      const char* command[] = {
+        NINJA_PYTHON, "-", ninja_command, initial_target, NULL
+      };
+      execvp(command[0], (char**)command);
+      perror("ninja: execvp");
     } while (false);
     _exit(1);
   } else {  // Child.
diff -Naur ninja-1.9.0.orig/src/browse.h ninja/src/browse.h
--- ninja-1.9.0.orig/src/browse.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/browse.h	2019-09-24 19:51:29.581776138 +0000
@@ -19,10 +19,9 @@
 
 /// Run in "browse" mode, which execs a Python webserver.
 /// \a ninja_command is the command used to invoke ninja.
-/// \a args are the number of arguments to be passed to the Python script.
-/// \a argv are arguments to be passed to the Python script.
+/// \a initial_target is the first target to load.
 /// This function does not return if it runs successfully.
 void RunBrowsePython(State* state, const char* ninja_command,
-                     const char* input_file, int argc, char* argv[]);
+                     const char* initial_target);
 
 #endif  // NINJA_BROWSE_H_
diff -Naur ninja-1.9.0.orig/src/browse.py ninja/src/browse.py
--- ninja-1.9.0.orig/src/browse.py	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/browse.py	2019-09-24 19:51:29.582909738 +0000
@@ -24,21 +24,14 @@
 
 try:
     import http.server as httpserver
-    import socketserver
 except ImportError:
     import BaseHTTPServer as httpserver
-    import SocketServer as socketserver
-import argparse
-import cgi
 import os
 import socket
 import subprocess
 import sys
 import webbrowser
-try:
-    from urllib.request import unquote
-except ImportError:
-    from urllib2 import unquote
+import urllib2
 from collections import namedtuple
 
 Node = namedtuple('Node', ['inputs', 'rule', 'target', 'outputs'])
@@ -61,9 +54,6 @@
         return (False, line)
     return (True, line[len(prefix):])
 
-def html_escape(text):
-    return cgi.escape(text, quote=True)
-
 def parse(text):
     lines = iter(text.split('\n'))
 
@@ -130,19 +120,19 @@
 ''' + body
 
 def generate_html(node):
-    document = ['<h1><tt>%s</tt></h1>' % html_escape(node.target)]
+    document = ['<h1><tt>%s</tt></h1>' % node.target]
 
     if node.inputs:
         document.append('<h2>target is built using rule <tt>%s</tt> of</h2>' %
-                        html_escape(node.rule))
+                        node.rule)
         if len(node.inputs) > 0:
             document.append('<div class=filelist>')
             for input, type in sorted(node.inputs):
                 extra = ''
                 if type:
-                    extra = ' (%s)' % html_escape(type)
+                    extra = ' (%s)' % type
                 document.append('<tt><a href="?%s">%s</a>%s</tt><br>' %
-                                (html_escape(input), html_escape(input), extra))
+                                (input, input, extra))
             document.append('</div>')
 
     if node.outputs:
@@ -150,25 +140,25 @@
         document.append('<div class=filelist>')
         for output in sorted(node.outputs):
             document.append('<tt><a href="?%s">%s</a></tt><br>' %
-                            (html_escape(output), html_escape(output)))
+                            (output, output))
         document.append('</div>')
 
     return '\n'.join(document)
 
 def ninja_dump(target):
-    cmd = [args.ninja_command, '-f', args.f, '-t', 'query', target]
-    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
+    proc = subprocess.Popen([sys.argv[1], '-t', 'query', target],
+                            stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                             universal_newlines=True)
     return proc.communicate() + (proc.returncode,)
 
 class RequestHandler(httpserver.BaseHTTPRequestHandler):
     def do_GET(self):
         assert self.path[0] == '/'
-        target = unquote(self.path[1:])
+        target = urllib2.unquote(self.path[1:])
 
         if target == '':
             self.send_response(302)
-            self.send_header('Location', '?' + args.initial_target)
+            self.send_header('Location', '?' + sys.argv[2])
             self.end_headers()
             return
 
@@ -183,7 +173,7 @@
             page_body = generate_html(parse(ninja_output.strip()))
         else:
             # Relay ninja's error message.
-            page_body = '<h1><tt>%s</tt></h1>' % html_escape(ninja_error)
+            page_body = '<h1><tt>%s</tt></h1>' % ninja_error
 
         self.send_response(200)
         self.end_headers()
@@ -192,36 +182,13 @@
     def log_message(self, format, *args):
         pass  # Swallow console spam.
 
-parser = argparse.ArgumentParser(prog='ninja -t browse')
-parser.add_argument('--port', '-p', default=8000, type=int,
-    help='Port number to use (default %(default)d)')
-parser.add_argument('--hostname', '-a', default='localhost', type=str,
-    help='Hostname to bind to (default %(default)s)')
-parser.add_argument('--no-browser', action='store_true',
-    help='Do not open a webbrowser on startup.')
-
-parser.add_argument('--ninja-command', default='ninja',
-    help='Path to ninja binary (default %(default)s)')
-parser.add_argument('-f', default='build.ninja',
-    help='Path to build.ninja file (default %(default)s)')
-parser.add_argument('initial_target', default='all', nargs='?',
-    help='Initial target to show (default %(default)s)')
-
-class HTTPServer(socketserver.ThreadingMixIn, httpserver.HTTPServer):
-    # terminate server immediately when Python exits.
-    daemon_threads = True
-
-args = parser.parse_args()
-port = args.port
-hostname = args.hostname
-httpd = HTTPServer((hostname,port), RequestHandler)
+port = 8000
+httpd = httpserver.HTTPServer(('',port), RequestHandler)
 try:
-    if hostname == "":
-        hostname = socket.gethostname()
+    hostname = socket.gethostname()
     print('Web server running on %s:%d, ctl-C to abort...' % (hostname,port) )
     print('Web server pid %d' % os.getpid(), file=sys.stderr )
-    if not args.no_browser:
-        webbrowser.open_new('http://%s:%s' % (hostname, port) )
+    webbrowser.open_new('http://%s:%s' % (hostname, port) )
     httpd.serve_forever()
 except KeyboardInterrupt:
     print()
diff -Naur ninja-1.9.0.orig/src/build.cc ninja/src/build.cc
--- ninja-1.9.0.orig/src/build.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/build.cc	2019-09-24 19:51:29.587829738 +0000
@@ -20,22 +20,17 @@
 #include <stdlib.h>
 #include <functional>
 
-#ifdef _WIN32
-#include <fcntl.h>
-#include <io.h>
-#endif
-
 #if defined(__SVR4) && defined(__sun)
 #include <sys/termios.h>
 #endif
 
 #include "build_log.h"
-#include "clparser.h"
 #include "debug_flags.h"
 #include "depfile_parser.h"
 #include "deps_log.h"
 #include "disk_interface.h"
 #include "graph.h"
+#include "msvc_helper.h"
 #include "state.h"
 #include "subprocess.h"
 #include "util.h"
@@ -89,7 +84,7 @@
 
   progress_status_format_ = getenv("NINJA_STATUS");
   if (!progress_status_format_)
-    progress_status_format_ = "[%f/%t] ";
+    progress_status_format_ = "[%s/%t] ";
 }
 
 void BuildStatus::PlanHasTotalEdges(int total) {
@@ -101,8 +96,7 @@
   running_edges_.insert(make_pair(edge, start_time));
   ++started_edges_;
 
-  if (edge->use_console() || printer_.is_smart_terminal())
-    PrintStatus(edge, kEdgeStarted);
+  PrintStatus(edge);
 
   if (edge->use_console())
     printer_.SetConsoleLocked(true);
@@ -114,7 +108,6 @@
                                     int* start_time,
                                     int* end_time) {
   int64_t now = GetTimeMillis();
-
   ++finished_edges_;
 
   RunningEdgeMap::iterator i = running_edges_.find(edge);
@@ -128,19 +121,12 @@
   if (config_.verbosity == BuildConfig::QUIET)
     return;
 
-  if (!edge->use_console())
-    PrintStatus(edge, kEdgeFinished);
+  if (!edge->use_console() && printer_.is_smart_terminal())
+    PrintStatus(edge);
 
   // Print the command that is spewing before printing its output.
-  if (!success) {
-    string outputs;
-    for (vector<Node*>::const_iterator o = edge->outputs_.begin();
-         o != edge->outputs_.end(); ++o)
-      outputs += (*o)->path() + " ";
-
-    printer_.PrintOnNewLine("FAILED: " + outputs + "\n");
-    printer_.PrintOnNewLine(edge->EvaluateCommand() + "\n");
-  }
+  if (!success)
+    printer_.PrintOnNewLine("FAILED: " + edge->EvaluateCommand() + "\n");
 
   if (!output.empty()) {
     // ninja sets stdout and stderr of subprocesses to a pipe, to be able to
@@ -154,37 +140,23 @@
     // (Launching subprocesses in pseudo ttys doesn't work because there are
     // only a few hundred available on some systems, and ninja can launch
     // thousands of parallel compile commands.)
+    // TODO: There should be a flag to disable escape code stripping.
     string final_output;
-    if (!printer_.supports_color())
+    if (!printer_.is_smart_terminal())
       final_output = StripAnsiEscapeCodes(output);
     else
       final_output = output;
-
-#ifdef _WIN32
-    // Fix extra CR being added on Windows, writing out CR CR LF (#773)
-    _setmode(_fileno(stdout), _O_BINARY);  // Begin Windows extra CR fix
-#endif
-
     printer_.PrintOnNewLine(final_output);
-
-#ifdef _WIN32
-    _setmode(_fileno(stdout), _O_TEXT);  // End Windows extra CR fix
-#endif
   }
 }
 
-void BuildStatus::BuildStarted() {
-  overall_rate_.Restart();
-  current_rate_.Restart();
-}
-
 void BuildStatus::BuildFinished() {
   printer_.SetConsoleLocked(false);
   printer_.PrintOnNewLine("");
 }
 
 string BuildStatus::FormatProgressStatus(
-    const char* progress_status_format, EdgeStatus status) const {
+    const char* progress_status_format) const {
   string out;
   char buf[32];
   int percent;
@@ -209,15 +181,10 @@
         break;
 
         // Running edges.
-      case 'r': {
-        int running_edges = started_edges_ - finished_edges_;
-        // count the edge that just finished as a running edge
-        if (status == kEdgeFinished)
-          running_edges++;
-        snprintf(buf, sizeof(buf), "%d", running_edges);
+      case 'r':
+        snprintf(buf, sizeof(buf), "%d", started_edges_ - finished_edges_);
         out += buf;
         break;
-      }
 
         // Unstarted edges.
       case 'u':
@@ -234,20 +201,20 @@
         // Overall finished edges per second.
       case 'o':
         overall_rate_.UpdateRate(finished_edges_);
-        SnprintfRate(overall_rate_.rate(), buf, "%.1f");
+        snprinfRate(overall_rate_.rate(), buf, "%.1f");
         out += buf;
         break;
 
         // Current rate, average over the last '-j' jobs.
       case 'c':
         current_rate_.UpdateRate(finished_edges_);
-        SnprintfRate(current_rate_.rate(), buf, "%.1f");
+        snprinfRate(current_rate_.rate(), buf, "%.1f");
         out += buf;
         break;
 
         // Percentage
       case 'p':
-        percent = (100 * finished_edges_) / total_edges_;
+        percent = (100 * started_edges_) / total_edges_;
         snprintf(buf, sizeof(buf), "%3i%%", percent);
         out += buf;
         break;
@@ -271,7 +238,7 @@
   return out;
 }
 
-void BuildStatus::PrintStatus(Edge* edge, EdgeStatus status) {
+void BuildStatus::PrintStatus(Edge* edge) {
   if (config_.verbosity == BuildConfig::QUIET)
     return;
 
@@ -281,7 +248,11 @@
   if (to_print.empty() || force_full_command)
     to_print = edge->GetBinding("command");
 
-  to_print = FormatProgressStatus(progress_status_format_, status) + to_print;
+  if (finished_edges_ == 0) {
+    overall_rate_.Restart();
+    current_rate_.Restart();
+  }
+  to_print = FormatProgressStatus(progress_status_format_) + to_print;
 
   printer_.Print(to_print,
                  force_full_command ? LinePrinter::FULL : LinePrinter::ELIDE);
@@ -289,46 +260,43 @@
 
 Plan::Plan() : command_edges_(0), wanted_edges_(0) {}
 
-void Plan::Reset() {
-  command_edges_ = 0;
-  wanted_edges_ = 0;
-  ready_.clear();
-  want_.clear();
-}
-
 bool Plan::AddTarget(Node* node, string* err) {
-  return AddSubTarget(node, NULL, err);
+  vector<Node*> stack;
+  return AddSubTarget(node, &stack, err);
 }
 
-bool Plan::AddSubTarget(Node* node, Node* dependent, string* err) {
+bool Plan::AddSubTarget(Node* node, vector<Node*>* stack, string* err) {
   Edge* edge = node->in_edge();
   if (!edge) {  // Leaf node.
     if (node->dirty()) {
       string referenced;
-      if (dependent)
-        referenced = ", needed by '" + dependent->path() + "',";
+      if (!stack->empty())
+        referenced = ", needed by '" + stack->back()->path() + "',";
       *err = "'" + node->path() + "'" + referenced + " missing "
              "and no known rule to make it";
     }
     return false;
   }
 
+  if (CheckDependencyCycle(node, *stack, err))
+    return false;
+
   if (edge->outputs_ready())
     return false;  // Don't need to do anything.
 
   // If an entry in want_ does not already exist for edge, create an entry which
-  // maps to kWantNothing, indicating that we do not want to build this entry itself.
-  pair<map<Edge*, Want>::iterator, bool> want_ins =
-    want_.insert(make_pair(edge, kWantNothing));
-  Want& want = want_ins.first->second;
+  // maps to false, indicating that we do not want to build this entry itself.
+  pair<map<Edge*, bool>::iterator, bool> want_ins =
+    want_.insert(make_pair(edge, false));
+  bool& want = want_ins.first->second;
 
   // If we do need to build edge and we haven't already marked it as wanted,
   // mark it now.
-  if (node->dirty() && want == kWantNothing) {
-    want = kWantToStart;
+  if (node->dirty() && !want) {
+    want = true;
     ++wanted_edges_;
     if (edge->AllInputsReady())
-      ScheduleWork(want_ins.first);
+      ScheduleWork(edge);
     if (!edge->is_phony())
       ++command_edges_;
   }
@@ -336,12 +304,47 @@
   if (!want_ins.second)
     return true;  // We've already processed the inputs.
 
+  stack->push_back(node);
   for (vector<Node*>::iterator i = edge->inputs_.begin();
        i != edge->inputs_.end(); ++i) {
-    if (!AddSubTarget(*i, node, err) && !err->empty())
+    if (!AddSubTarget(*i, stack, err) && !err->empty())
       return false;
   }
+  assert(stack->back() == node);
+  stack->pop_back();
+
+  return true;
+}
+
+bool Plan::CheckDependencyCycle(Node* node, const vector<Node*>& stack,
+                                string* err) {
+  vector<Node*>::const_iterator start = stack.begin();
+  while (start != stack.end() && (*start)->in_edge() != node->in_edge())
+    ++start;
+  if (start == stack.end())
+    return false;
 
+  // Build error string for the cycle.
+  vector<Node*> cycle(start, stack.end());
+  cycle.push_back(node);
+
+  if (cycle.front() != cycle.back()) {
+    // Consider
+    //   build a b: cat c
+    //   build c: cat a
+    // stack will contain [b, c], node will be a.  To not print b -> c -> a,
+    // shift by one to get c -> a -> c which makes the cycle clear.
+    cycle.erase(cycle.begin());
+    cycle.push_back(cycle.front());
+    assert(cycle.front() == cycle.back());
+  }
+
+  *err = "dependency cycle: ";
+  for (vector<Node*>::const_iterator i = cycle.begin(); i != cycle.end(); ++i) {
+    if (i != cycle.begin())
+      err->append(" -> ");
+    err->append((*i)->path());
+  }
   return true;
 }
 
@@ -354,20 +357,15 @@
   return edge;
 }
 
-void Plan::ScheduleWork(map<Edge*, Want>::iterator want_e) {
-  if (want_e->second == kWantToFinish) {
-    // This edge has already been scheduled.  We can get here again if an edge
-    // and one of its dependencies share an order-only input, or if a node
-    // duplicates an out edge (see https://github.com/ninja-build/ninja/pull/519).
-    // Avoid scheduling the work again.
-    return;
-  }
-  assert(want_e->second == kWantToStart);
-  want_e->second = kWantToFinish;
-
-  Edge* edge = want_e->first;
+void Plan::ScheduleWork(Edge* edge) {
   Pool* pool = edge->pool();
   if (pool->ShouldDelayEdge()) {
+    // The graph is not completely clean. Some Nodes have duplicate Out edges.
+    // We need to explicitly ignore these here, otherwise their work will get
+    // scheduled twice (see https://github.com/martine/ninja/pull/519)
+    if (ready_.count(edge)) {
+      return;
+    }
     pool->DelayEdge(edge);
     pool->RetrieveReadyEdges(&ready_);
   } else {
@@ -376,25 +374,20 @@
   }
 }
 
-void Plan::EdgeFinished(Edge* edge, EdgeResult result) {
-  map<Edge*, Want>::iterator e = want_.find(edge);
+void Plan::EdgeFinished(Edge* edge) {
+  map<Edge*, bool>::iterator e = want_.find(edge);
   assert(e != want_.end());
-  bool directly_wanted = e->second != kWantNothing;
+  bool directly_wanted = e->second;
+  if (directly_wanted)
+    --wanted_edges_;
+  want_.erase(e);
+  edge->outputs_ready_ = true;
 
   // See if this job frees up any delayed jobs.
   if (directly_wanted)
     edge->pool()->EdgeFinished(*edge);
   edge->pool()->RetrieveReadyEdges(&ready_);
 
-  // The rest of this function only applies to successful commands.
-  if (result != kEdgeSucceeded)
-    return;
-
-  if (directly_wanted)
-    --wanted_edges_;
-  want_.erase(e);
-  edge->outputs_ready_ = true;
-
   // Check off any nodes we were waiting for with this edge.
   for (vector<Node*>::iterator o = edge->outputs_.begin();
        o != edge->outputs_.end(); ++o) {
@@ -406,18 +399,18 @@
   // See if we we want any edges from this node.
   for (vector<Edge*>::const_iterator oe = node->out_edges().begin();
        oe != node->out_edges().end(); ++oe) {
-    map<Edge*, Want>::iterator want_e = want_.find(*oe);
+    map<Edge*, bool>::iterator want_e = want_.find(*oe);
     if (want_e == want_.end())
       continue;
 
     // See if the edge is now ready.
     if ((*oe)->AllInputsReady()) {
-      if (want_e->second != kWantNothing) {
-        ScheduleWork(want_e);
+      if (want_e->second) {
+        ScheduleWork(*oe);
       } else {
         // We do not need to build this edge, but we might need to build one of
         // its dependents.
-        EdgeFinished(*oe, kEdgeSucceeded);
+        EdgeFinished(*oe);
       }
     }
   }
@@ -429,8 +422,8 @@
   for (vector<Edge*>::const_iterator oe = node->out_edges().begin();
        oe != node->out_edges().end(); ++oe) {
     // Don't process edges that we don't actually want.
-    map<Edge*, Want>::iterator want_e = want_.find(*oe);
-    if (want_e == want_.end() || want_e->second == kWantNothing)
+    map<Edge*, bool>::iterator want_e = want_.find(*oe);
+    if (want_e == want_.end() || !want_e->second)
       continue;
 
     // Don't attempt to clean an edge if it failed to load deps.
@@ -442,12 +435,7 @@
     vector<Node*>::iterator
         begin = (*oe)->inputs_.begin(),
         end = (*oe)->inputs_.end() - (*oe)->order_only_deps_;
-#if __cplusplus < 201703L
-#define MEM_FN mem_fun
-#else
-#define MEM_FN mem_fn  // mem_fun was removed in C++17.
-#endif
-    if (find_if(begin, end, MEM_FN(&Node::dirty)) == end) {
+    if (find_if(begin, end, mem_fun(&Node::dirty)) == end) {
       // Recompute most_recent_input.
       Node* most_recent_input = NULL;
       for (vector<Node*>::iterator i = begin; i != end; ++i) {
@@ -470,7 +458,7 @@
             return false;
         }
 
-        want_e->second = kWantNothing;
+        want_e->second = false;
         --wanted_edges_;
         if (!(*oe)->is_phony())
           --command_edges_;
@@ -482,8 +470,8 @@
 
 void Plan::Dump() {
   printf("pending: %d\n", (int)want_.size());
-  for (map<Edge*, Want>::iterator e = want_.begin(); e != want_.end(); ++e) {
-    if (e->second != kWantNothing)
+  for (map<Edge*, bool>::iterator e = want_.begin(); e != want_.end(); ++e) {
+    if (e->second)
       printf("want ");
     e->first->Dump();
   }
@@ -557,8 +545,7 @@
                  BuildLog* build_log, DepsLog* deps_log,
                  DiskInterface* disk_interface)
     : state_(state), config_(config), disk_interface_(disk_interface),
-      scan_(state, build_log, deps_log, disk_interface,
-            &config_.depfile_parser_options) {
+      scan_(state, build_log, deps_log, disk_interface) {
   status_ = new BuildStatus(config);
 }
 
@@ -608,10 +595,9 @@
 }
 
 bool Builder::AddTarget(Node* node, string* err) {
-  if (!scan_.RecomputeDirty(node, err))
-    return false;
-
   if (Edge* in_edge = node->in_edge()) {
+    if (!scan_.RecomputeDirty(in_edge, err))
+      return false;
     if (in_edge->outputs_ready())
       return true;  // Nothing to do.
   }
@@ -641,9 +627,6 @@
       command_runner_.reset(new RealCommandRunner(config_));
   }
 
-  // We are about to start the build process.
-  status_->BuildStarted();
-
   // This main loop runs the entire build process.
   // It is structured like this:
   // First, we attempt to start as many commands as allowed by the
@@ -660,7 +643,7 @@
         }
 
         if (edge->is_phony()) {
-          plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+          plan_.EdgeFinished(edge);
         } else {
           ++pending_commands;
         }
@@ -779,15 +762,12 @@
                              &start_time, &end_time);
 
   // The rest of this function only applies to successful commands.
-  if (!result->success()) {
-    plan_.EdgeFinished(edge, Plan::kEdgeFailed);
+  if (!result->success())
     return true;
-  }
 
-  // Restat the edge outputs
-  TimeStamp output_mtime = 0;
-  bool restat = edge->GetBindingBool("restat");
-  if (!config_.dry_run) {
+  // Restat the edge outputs, if necessary.
+  TimeStamp restat_mtime = 0;
+  if (edge->GetBindingBool("restat") && !config_.dry_run) {
     bool node_cleaned = false;
 
     for (vector<Node*>::iterator o = edge->outputs_.begin();
@@ -795,9 +775,7 @@
       TimeStamp new_mtime = disk_interface_->Stat((*o)->path(), err);
       if (new_mtime == -1)
         return false;
-      if (new_mtime > output_mtime)
-        output_mtime = new_mtime;
-      if ((*o)->mtime() == new_mtime && restat) {
+      if ((*o)->mtime() == new_mtime) {
         // The rule command did not change the output.  Propagate the clean
         // state through the build graph.
         // Note that this also applies to nonexistent outputs (mtime == 0).
@@ -808,7 +786,6 @@
     }
 
     if (node_cleaned) {
-      TimeStamp restat_mtime = 0;
       // If any output was cleaned, find the most recent mtime of any
       // (existing) non-order-only input or the depfile.
       for (vector<Node*>::iterator i = edge->inputs_.begin();
@@ -832,12 +809,10 @@
       // The total number of edges in the plan may have changed as a result
       // of a restat.
       status_->PlanHasTotalEdges(plan_.command_edge_count());
-
-      output_mtime = restat_mtime;
     }
   }
 
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   // Delete any left over response file.
   string rspfile = edge->GetUnescapedRspfile();
@@ -846,7 +821,7 @@
 
   if (scan_.build_log()) {
     if (!scan_.build_log()->RecordCommand(edge, start_time, end_time,
-                                          output_mtime)) {
+                                          restat_mtime)) {
       *err = string("Error writing to build log: ") + strerror(errno);
       return false;
     }
@@ -871,12 +846,10 @@
                           const string& deps_prefix,
                           vector<Node*>* deps_nodes,
                           string* err) {
+#ifdef _WIN32
   if (deps_type == "msvc") {
     CLParser parser;
-    string output;
-    if (!parser.Parse(result->output, deps_prefix, &output, err))
-      return false;
-    result->output = output;
+    result->output = parser.Parse(result->output, deps_prefix);
     for (set<string>::iterator i = parser.includes_.begin();
          i != parser.includes_.end(); ++i) {
       // ~0 is assuming that with MSVC-parsed headers, it's ok to always make
@@ -886,6 +859,7 @@
       deps_nodes->push_back(state_->GetNode(*i, ~0u));
     }
   } else
+#endif
   if (deps_type == "gcc") {
     string depfile = result->edge->GetUnescapedDepfile();
     if (depfile.empty()) {
@@ -893,21 +867,13 @@
       return false;
     }
 
-    // Read depfile content.  Treat a missing depfile as empty.
-    string content;
-    switch (disk_interface_->ReadFile(depfile, &content, err)) {
-    case DiskInterface::Okay:
-      break;
-    case DiskInterface::NotFound:
-      err->clear();
-      break;
-    case DiskInterface::OtherError:
+    string content = disk_interface_->ReadFile(depfile, err);
+    if (!err->empty())
       return false;
-    }
     if (content.empty())
       return true;
 
-    DepfileParser deps(config_.depfile_parser_options);
+    DepfileParser deps;
     if (!deps.Parse(&content, err))
       return false;
 
@@ -915,18 +881,16 @@
     deps_nodes->reserve(deps.ins_.size());
     for (vector<StringPiece>::iterator i = deps.ins_.begin();
          i != deps.ins_.end(); ++i) {
-      uint64_t slash_bits;
+      unsigned int slash_bits;
       if (!CanonicalizePath(const_cast<char*>(i->str_), &i->len_, &slash_bits,
                             err))
         return false;
       deps_nodes->push_back(state_->GetNode(*i, slash_bits));
     }
 
-    if (!g_keep_depfile) {
-      if (disk_interface_->RemoveFile(depfile) < 0) {
-        *err = string("deleting depfile: ") + strerror(errno) + string("\n");
-        return false;
-      }
+    if (disk_interface_->RemoveFile(depfile) < 0) {
+      *err = string("deleting depfile: ") + strerror(errno) + string("\n");
+      return false;
     }
   } else {
     Fatal("unknown deps type '%s'", deps_type.c_str());
diff -Naur ninja-1.9.0.orig/src/build.h ninja/src/build.h
--- ninja-1.9.0.orig/src/build.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/build.h	2019-09-24 19:51:29.589078538 +0000
@@ -23,7 +23,6 @@
 #include <string>
 #include <vector>
 
-#include "depfile_parser.h"
 #include "graph.h"  // XXX needed for DependencyScan; should rearrange.
 #include "exit_status.h"
 #include "line_printer.h"
@@ -57,13 +56,9 @@
   /// Dumps the current state of the plan.
   void Dump();
 
-  enum EdgeResult {
-    kEdgeFailed,
-    kEdgeSucceeded
-  };
-
-  /// Mark an edge as done building (whether it succeeded or failed).
-  void EdgeFinished(Edge* edge, EdgeResult result);
+  /// Mark an edge as done building.  Used internally and by
+  /// tests.
+  void EdgeFinished(Edge* edge);
 
   /// Clean the given node during the build.
   /// Return false on error.
@@ -72,36 +67,23 @@
   /// Number of edges with commands to run.
   int command_edge_count() const { return command_edges_; }
 
-  /// Reset state.  Clears want and ready sets.
-  void Reset();
-
 private:
-  bool AddSubTarget(Node* node, Node* dependent, string* err);
+  bool AddSubTarget(Node* node, vector<Node*>* stack, string* err);
+  bool CheckDependencyCycle(Node* node, const vector<Node*>& stack,
+                            string* err);
   void NodeFinished(Node* node);
 
-  /// Enumerate possible steps we want for an edge.
-  enum Want
-  {
-    /// We do not want to build the edge, but we might want to build one of
-    /// its dependents.
-    kWantNothing,
-    /// We want to build the edge, but have not yet scheduled it.
-    kWantToStart,
-    /// We want to build the edge, have scheduled it, and are waiting
-    /// for it to complete.
-    kWantToFinish
-  };
-
   /// Submits a ready edge as a candidate for execution.
   /// The edge may be delayed from running, for example if it's a member of a
   /// currently-full pool.
-  void ScheduleWork(map<Edge*, Want>::iterator want_e);
+  void ScheduleWork(Edge* edge);
 
   /// Keep track of which edges we want to build in this plan.  If this map does
   /// not contain an entry for an edge, we do not want to build the entry or its
-  /// dependents.  If it does contain an entry, the enumeration indicates what
-  /// we want for the edge.
-  map<Edge*, Want> want_;
+  /// dependents.  If an entry maps to false, we do not want to build it, but we
+  /// might want to build one of its dependents.  If the entry maps to true, we
+  /// want to build it.
+  map<Edge*, bool> want_;
 
   set<Edge*> ready_;
 
@@ -152,7 +134,6 @@
   /// The maximum load average we must not exceed. A negative value
   /// means that we do not have any limit.
   double max_load_average;
-  DepfileParserOptions depfile_parser_options;
 };
 
 /// Builder wraps the build process: starting commands, updating status.
@@ -192,11 +173,7 @@
   State* state_;
   const BuildConfig& config_;
   Plan plan_;
-#if __cplusplus < 201703L
   auto_ptr<CommandRunner> command_runner_;
-#else
-  unique_ptr<CommandRunner> command_runner_;  // auto_ptr was removed in C++17.
-#endif
   BuildStatus* status_;
 
  private:
@@ -219,24 +196,16 @@
   void BuildEdgeStarted(Edge* edge);
   void BuildEdgeFinished(Edge* edge, bool success, const string& output,
                          int* start_time, int* end_time);
-  void BuildStarted();
   void BuildFinished();
 
-  enum EdgeStatus {
-    kEdgeStarted,
-    kEdgeFinished,
-  };
-
   /// Format the progress status string by replacing the placeholders.
   /// See the user manual for more information about the available
   /// placeholders.
   /// @param progress_status_format The format of the progress status.
-  /// @param status The status of the edge.
-  string FormatProgressStatus(const char* progress_status_format,
-                              EdgeStatus status) const;
+  string FormatProgressStatus(const char* progress_status_format) const;
 
  private:
-  void PrintStatus(Edge* edge, EdgeStatus status);
+  void PrintStatus(Edge* edge);
 
   const BuildConfig& config_;
 
@@ -256,11 +225,9 @@
   const char* progress_status_format_;
 
   template<size_t S>
-  void SnprintfRate(double rate, char(&buf)[S], const char* format) const {
-    if (rate == -1)
-      snprintf(buf, S, "?");
-    else
-      snprintf(buf, S, format, rate);
+  void snprinfRate(double rate, char(&buf)[S], const char* format) const {
+    if (rate == -1) snprintf(buf, S, "?");
+    else            snprintf(buf, S, format, rate);
   }
 
   struct RateInfo {
diff -Naur ninja-1.9.0.orig/src/build_log.cc ninja/src/build_log.cc
--- ninja-1.9.0.orig/src/build_log.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/build_log.cc	2019-09-24 19:51:29.591700138 +0000
@@ -12,14 +12,6 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-// On AIX, inttypes.h gets indirectly included by build_log.h.
-// It's easiest just to ask for the printf format macros right away.
-#ifndef _WIN32
-#ifndef __STDC_FORMAT_MACROS
-#define __STDC_FORMAT_MACROS
-#endif
-#endif
-
 #include "build_log.h"
 
 #include <errno.h>
@@ -27,6 +19,7 @@
 #include <string.h>
 
 #ifndef _WIN32
+#define __STDC_FORMAT_MACROS
 #include <inttypes.h>
 #include <unistd.h>
 #endif
@@ -35,9 +28,6 @@
 #include "graph.h"
 #include "metrics.h"
 #include "util.h"
-#if defined(_MSC_VER) && (_MSC_VER < 1800)
-#define strtoll _strtoi64
-#endif
 
 // Implementation details:
 // Each run's log appends to the log file.
@@ -79,17 +69,11 @@
   switch (len & 7)
   {
   case 7: h ^= uint64_t(data[6]) << 48;
-          NINJA_FALLTHROUGH;
   case 6: h ^= uint64_t(data[5]) << 40;
-          NINJA_FALLTHROUGH;
   case 5: h ^= uint64_t(data[4]) << 32;
-          NINJA_FALLTHROUGH;
   case 4: h ^= uint64_t(data[3]) << 24;
-          NINJA_FALLTHROUGH;
   case 3: h ^= uint64_t(data[2]) << 16;
-          NINJA_FALLTHROUGH;
   case 2: h ^= uint64_t(data[1]) << 8;
-          NINJA_FALLTHROUGH;
   case 1: h ^= uint64_t(data[0]);
           h *= m;
   };
@@ -114,7 +98,7 @@
 BuildLog::LogEntry::LogEntry(const string& output, uint64_t command_hash,
   int start_time, int end_time, TimeStamp restat_mtime)
   : output(output), command_hash(command_hash),
-    start_time(start_time), end_time(end_time), mtime(restat_mtime)
+    start_time(start_time), end_time(end_time), restat_mtime(restat_mtime)
 {}
 
 BuildLog::BuildLog()
@@ -154,7 +138,7 @@
 }
 
 bool BuildLog::RecordCommand(Edge* edge, int start_time, int end_time,
-                             TimeStamp mtime) {
+                             TimeStamp restat_mtime) {
   string command = edge->EvaluateCommand(true);
   uint64_t command_hash = LogEntry::HashCommand(command);
   for (vector<Node*>::iterator out = edge->outputs_.begin();
@@ -171,14 +155,11 @@
     log_entry->command_hash = command_hash;
     log_entry->start_time = start_time;
     log_entry->end_time = end_time;
-    log_entry->mtime = mtime;
+    log_entry->restat_mtime = restat_mtime;
 
     if (log_file_) {
       if (!WriteEntry(log_file_, *log_entry))
         return false;
-      if (fflush(log_file_) != 0) {
-          return false;
-      }
     }
   }
   return true;
@@ -302,7 +283,7 @@
     if (!end)
       continue;
     *end = 0;
-    restat_mtime = strtoll(start, NULL, 10);
+    restat_mtime = atol(start);
     start = end + 1;
 
     end = (char*)memchr(start, kFieldSeparator, line_end - start);
@@ -326,7 +307,7 @@
 
     entry->start_time = start_time;
     entry->end_time = end_time;
-    entry->mtime = restat_mtime;
+    entry->restat_mtime = restat_mtime;
     if (log_version >= 5) {
       char c = *end; *end = '\0';
       entry->command_hash = (uint64_t)strtoull(start, NULL, 16);
@@ -365,8 +346,8 @@
 }
 
 bool BuildLog::WriteEntry(FILE* f, const LogEntry& entry) {
-  return fprintf(f, "%d\t%d\t%" PRId64 "\t%s\t%" PRIx64 "\n",
-          entry.start_time, entry.end_time, entry.mtime,
+  return fprintf(f, "%d\t%d\t%d\t%s\t%" PRIx64 "\n",
+          entry.start_time, entry.end_time, entry.restat_mtime,
           entry.output.c_str(), entry.command_hash) > 0;
 }
 
diff -Naur ninja-1.9.0.orig/src/build_log.h ninja/src/build_log.h
--- ninja-1.9.0.orig/src/build_log.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/build_log.h	2019-09-24 19:51:29.592816938 +0000
@@ -27,7 +27,7 @@
 
 /// Can answer questions about the manifest for the BuildLog.
 struct BuildLogUser {
-  /// Return if a given output is no longer part of the build manifest.
+  /// Return if a given output no longer part of the build manifest.
   /// This is only called during recompaction and doesn't have to be fast.
   virtual bool IsPathDead(StringPiece s) const = 0;
 };
@@ -45,7 +45,7 @@
 
   bool OpenForWrite(const string& path, const BuildLogUser& user, string* err);
   bool RecordCommand(Edge* edge, int start_time, int end_time,
-                     TimeStamp mtime = 0);
+                     TimeStamp restat_mtime = 0);
   void Close();
 
   /// Load the on-disk log.
@@ -56,7 +56,7 @@
     uint64_t command_hash;
     int start_time;
     int end_time;
-    TimeStamp mtime;
+    TimeStamp restat_mtime;
 
     static uint64_t HashCommand(StringPiece command);
 
@@ -64,7 +64,7 @@
     bool operator==(const LogEntry& o) {
       return output == o.output && command_hash == o.command_hash &&
           start_time == o.start_time && end_time == o.end_time &&
-          mtime == o.mtime;
+          restat_mtime == o.restat_mtime;
     }
 
     explicit LogEntry(const string& output);
diff -Naur ninja-1.9.0.orig/src/build_log_perftest.cc ninja/src/build_log_perftest.cc
--- ninja-1.9.0.orig/src/build_log_perftest.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/build_log_perftest.cc	2019-09-24 19:51:29.593748938 +0000
@@ -92,7 +92,7 @@
     log.RecordCommand(state.edges_[i],
                       /*start_time=*/100 * i,
                       /*end_time=*/100 * i + 1,
-                      /*mtime=*/0);
+                      /*restat_mtime=*/0);
   }
 
   return true;
diff -Naur ninja-1.9.0.orig/src/build_log_test.cc ninja/src/build_log_test.cc
--- ninja-1.9.0.orig/src/build_log_test.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/build_log_test.cc	2019-09-24 19:51:29.595458538 +0000
@@ -121,15 +121,13 @@
 "build out: cat mid\n"
 "build mid: cat in\n");
 
-  {
-    BuildLog log1;
-    string err;
-    EXPECT_TRUE(log1.OpenForWrite(kTestFilename, *this, &err));
-    ASSERT_EQ("", err);
-    log1.RecordCommand(state_.edges_[0], 15, 18);
-    log1.RecordCommand(state_.edges_[1], 20, 25);
-    log1.Close();
-  }
+  BuildLog log1;
+  string err;
+  EXPECT_TRUE(log1.OpenForWrite(kTestFilename, *this, &err));
+  ASSERT_EQ("", err);
+  log1.RecordCommand(state_.edges_[0], 15, 18);
+  log1.RecordCommand(state_.edges_[1], 20, 25);
+  log1.Close();
 
   struct stat statbuf;
   ASSERT_EQ(0, stat(kTestFilename, &statbuf));
@@ -181,7 +179,7 @@
   ASSERT_TRUE(e);
   ASSERT_EQ(123, e->start_time);
   ASSERT_EQ(456, e->end_time);
-  ASSERT_EQ(456, e->mtime);
+  ASSERT_EQ(456, e->restat_mtime);
   ASSERT_NO_FATAL_FAILURE(AssertHash("command", e->command_hash));
 }
 
@@ -205,14 +203,14 @@
   ASSERT_TRUE(e);
   ASSERT_EQ(123, e->start_time);
   ASSERT_EQ(456, e->end_time);
-  ASSERT_EQ(456, e->mtime);
+  ASSERT_EQ(456, e->restat_mtime);
   ASSERT_NO_FATAL_FAILURE(AssertHash("command", e->command_hash));
 
   e = log.LookupByOutput("out2");
   ASSERT_TRUE(e);
   ASSERT_EQ(456, e->start_time);
   ASSERT_EQ(789, e->end_time);
-  ASSERT_EQ(789, e->mtime);
+  ASSERT_EQ(789, e->restat_mtime);
   ASSERT_NO_FATAL_FAILURE(AssertHash("command2", e->command_hash));
 }
 
@@ -240,7 +238,7 @@
   ASSERT_TRUE(e);
   ASSERT_EQ(456, e->start_time);
   ASSERT_EQ(789, e->end_time);
-  ASSERT_EQ(789, e->mtime);
+  ASSERT_EQ(789, e->restat_mtime);
   ASSERT_NO_FATAL_FAILURE(AssertHash("command2", e->command_hash));
 }
 
diff -Naur ninja-1.9.0.orig/src/build_test.cc ninja/src/build_test.cc
--- ninja-1.9.0.orig/src/build_test.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/build_test.cc	2019-09-24 19:51:29.602805738 +0000
@@ -68,14 +68,14 @@
 
   ASSERT_FALSE(plan_.FindWork());
 
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);
   ASSERT_EQ("mid", edge->inputs_[0]->path());
   ASSERT_EQ("out", edge->outputs_[0]->path());
 
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   ASSERT_FALSE(plan_.more_to_do());
   edge = plan_.FindWork();
@@ -99,11 +99,11 @@
   Edge* edge;
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);  // cat in
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);  // cat mid1 mid2
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_FALSE(edge);  // done
@@ -129,19 +129,19 @@
   Edge* edge;
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);  // cat in
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);  // cat a1
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);  // cat a2
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);  // cat b1 b2
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_FALSE(edge);  // done
@@ -167,24 +167,77 @@
   Edge* edge;
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);  // cat in
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);  // cat mid
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);  // cat mid
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);  // cat a1 a2
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_FALSE(edge);  // done
 }
 
+TEST_F(PlanTest, DependencyCycle) {
+  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
+"build out: cat mid\n"
+"build mid: cat in\n"
+"build in: cat pre\n"
+"build pre: cat out\n"));
+  GetNode("out")->MarkDirty();
+  GetNode("mid")->MarkDirty();
+  GetNode("in")->MarkDirty();
+  GetNode("pre")->MarkDirty();
+
+  string err;
+  EXPECT_FALSE(plan_.AddTarget(GetNode("out"), &err));
+  ASSERT_EQ("dependency cycle: out -> mid -> in -> pre -> out", err);
+}
+
+TEST_F(PlanTest, CycleInEdgesButNotInNodes1) {
+  string err;
+  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
+"build a b: cat a\n"));
+  EXPECT_FALSE(plan_.AddTarget(GetNode("b"), &err));
+  ASSERT_EQ("dependency cycle: a -> a", err);
+}
+
+TEST_F(PlanTest, CycleInEdgesButNotInNodes2) {
+  string err;
+  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
+"build b a: cat a\n"));
+  EXPECT_FALSE(plan_.AddTarget(GetNode("b"), &err));
+  ASSERT_EQ("dependency cycle: a -> a", err);
+}
+
+TEST_F(PlanTest, CycleInEdgesButNotInNodes3) {
+  string err;
+  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
+"build a b: cat c\n"
+"build c: cat a\n"));
+  EXPECT_FALSE(plan_.AddTarget(GetNode("b"), &err));
+  ASSERT_EQ("dependency cycle: c -> a -> c", err);
+}
+
+TEST_F(PlanTest, CycleInEdgesButNotInNodes4) {
+  string err;
+  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
+"build d: cat c\n"
+"build c: cat b\n"
+"build b: cat a\n"
+"build a e: cat d\n"
+"build f: cat e\n"));
+  EXPECT_FALSE(plan_.AddTarget(GetNode("f"), &err));
+  ASSERT_EQ("dependency cycle: d -> c -> b -> a -> d", err);
+}
+
 void PlanTest::TestPoolWithDepthOne(const char* test_case) {
   ASSERT_NO_FATAL_FAILURE(AssertParse(&state_, test_case));
   GetNode("out1")->MarkDirty();
@@ -204,7 +257,7 @@
   // This will be false since poolcat is serialized
   ASSERT_FALSE(plan_.FindWork());
 
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);
@@ -213,7 +266,7 @@
 
   ASSERT_FALSE(plan_.FindWork());
 
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   ASSERT_FALSE(plan_.more_to_do());
   edge = plan_.FindWork();
@@ -289,7 +342,7 @@
   ASSERT_EQ("outb3", edge->outputs_[0]->path());
 
   // finish out1
-  plan_.EdgeFinished(edges.front(), Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edges.front());
   edges.pop_front();
 
   // out3 should be available
@@ -300,19 +353,19 @@
 
   ASSERT_FALSE(plan_.FindWork());
 
-  plan_.EdgeFinished(out3, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(out3);
 
   ASSERT_FALSE(plan_.FindWork());
 
   for (deque<Edge*>::iterator it = edges.begin(); it != edges.end(); ++it) {
-    plan_.EdgeFinished(*it, Plan::kEdgeSucceeded);
+    plan_.EdgeFinished(*it);
   }
 
   Edge* last = plan_.FindWork();
   ASSERT_TRUE(last);
   ASSERT_EQ("allTheThings", last->outputs_[0]->path());
 
-  plan_.EdgeFinished(last, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(last);
 
   ASSERT_FALSE(plan_.more_to_do());
   ASSERT_FALSE(plan_.FindWork());
@@ -354,7 +407,7 @@
 
   edge = initial_edges[1];  // Foo first
   ASSERT_EQ("foo.cpp", edge->outputs_[0]->path());
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);
@@ -362,11 +415,11 @@
   ASSERT_EQ("foo.cpp", edge->inputs_[0]->path());
   ASSERT_EQ("foo.cpp", edge->inputs_[1]->path());
   ASSERT_EQ("foo.cpp.obj", edge->outputs_[0]->path());
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = initial_edges[0];  // Now for bar
   ASSERT_EQ("bar.cpp", edge->outputs_[0]->path());
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);
@@ -374,7 +427,7 @@
   ASSERT_EQ("bar.cpp", edge->inputs_[0]->path());
   ASSERT_EQ("bar.cpp", edge->inputs_[1]->path());
   ASSERT_EQ("bar.cpp.obj", edge->outputs_[0]->path());
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);
@@ -382,62 +435,20 @@
   ASSERT_EQ("foo.cpp.obj", edge->inputs_[0]->path());
   ASSERT_EQ("bar.cpp.obj", edge->inputs_[1]->path());
   ASSERT_EQ("libfoo.a", edge->outputs_[0]->path());
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_TRUE(edge);
   ASSERT_FALSE(plan_.FindWork());
   ASSERT_EQ("libfoo.a", edge->inputs_[0]->path());
   ASSERT_EQ("all", edge->outputs_[0]->path());
-  plan_.EdgeFinished(edge, Plan::kEdgeSucceeded);
+  plan_.EdgeFinished(edge);
 
   edge = plan_.FindWork();
   ASSERT_FALSE(edge);
   ASSERT_FALSE(plan_.more_to_do());
 }
 
-TEST_F(PlanTest, PoolWithFailingEdge) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-    "pool foobar\n"
-    "  depth = 1\n"
-    "rule poolcat\n"
-    "  command = cat $in > $out\n"
-    "  pool = foobar\n"
-    "build out1: poolcat in\n"
-    "build out2: poolcat in\n"));
-  GetNode("out1")->MarkDirty();
-  GetNode("out2")->MarkDirty();
-  string err;
-  EXPECT_TRUE(plan_.AddTarget(GetNode("out1"), &err));
-  ASSERT_EQ("", err);
-  EXPECT_TRUE(plan_.AddTarget(GetNode("out2"), &err));
-  ASSERT_EQ("", err);
-  ASSERT_TRUE(plan_.more_to_do());
-
-  Edge* edge = plan_.FindWork();
-  ASSERT_TRUE(edge);
-  ASSERT_EQ("in",  edge->inputs_[0]->path());
-  ASSERT_EQ("out1", edge->outputs_[0]->path());
-
-  // This will be false since poolcat is serialized
-  ASSERT_FALSE(plan_.FindWork());
-
-  plan_.EdgeFinished(edge, Plan::kEdgeFailed);
-
-  edge = plan_.FindWork();
-  ASSERT_TRUE(edge);
-  ASSERT_EQ("in", edge->inputs_[0]->path());
-  ASSERT_EQ("out2", edge->outputs_[0]->path());
-
-  ASSERT_FALSE(plan_.FindWork());
-
-  plan_.EdgeFinished(edge, Plan::kEdgeFailed);
-
-  ASSERT_TRUE(plan_.more_to_do()); // Jobs have failed
-  edge = plan_.FindWork();
-  ASSERT_EQ(0, edge);
-}
-
 /// Fake implementation of CommandRunner, useful for tests.
 struct FakeCommandRunner : public CommandRunner {
   explicit FakeCommandRunner(VirtualFileSystem* fs) :
@@ -555,8 +566,7 @@
       edge->rule().name() == "cat_rsp_out" ||
       edge->rule().name() == "cc" ||
       edge->rule().name() == "touch" ||
-      edge->rule().name() == "touch-interrupt" ||
-      edge->rule().name() == "touch-fail-tick2") {
+      edge->rule().name() == "touch-interrupt") {
     for (vector<Node*>::iterator out = edge->outputs_.begin();
          out != edge->outputs_.end(); ++out) {
       fs_->Create((*out)->path(), "");
@@ -597,8 +607,7 @@
     return true;
   }
 
-  if (edge->rule().name() == "fail" ||
-      (edge->rule().name() == "touch-fail-tick2" && fs_->now_ == 2))
+  if (edge->rule().name() == "fail")
     result->status = ExitFailure;
   else
     result->status = ExitSuccess;
@@ -708,24 +717,8 @@
   EXPECT_EQ("touch out1 out2", command_runner_.commands_ran_[0]);
 }
 
-TEST_F(BuildTest, ImplicitOutput) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-"rule touch\n"
-"  command = touch $out $out.imp\n"
-"build out | out.imp: touch in.txt\n"));
-  fs_.Create("in.txt", "");
-
-  string err;
-  EXPECT_TRUE(builder_.AddTarget("out.imp", &err));
-  ASSERT_EQ("", err);
-  EXPECT_TRUE(builder_.Build(&err));
-  EXPECT_EQ("", err);
-  ASSERT_EQ(1u, command_runner_.commands_ran_.size());
-  EXPECT_EQ("touch out out.imp", command_runner_.commands_ran_[0]);
-}
-
 // Test case from
-//   https://github.com/ninja-build/ninja/issues/148
+//   https://github.com/martine/ninja/issues/148
 TEST_F(BuildTest, MultiOutIn) {
   ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
 "rule touch\n"
@@ -866,29 +859,6 @@
   EXPECT_EQ("foo.o.d: expected ':' in depfile", err);
 }
 
-TEST_F(BuildTest, EncounterReadyTwice) {
-  string err;
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-"rule touch\n"
-"  command = touch $out\n"
-"build c: touch\n"
-"build b: touch || c\n"
-"build a: touch | b || c\n"));
-
-  vector<Edge*> c_out = GetNode("c")->out_edges();
-  ASSERT_EQ(2u, c_out.size());
-  EXPECT_EQ("b", c_out[0]->outputs_[0]->path());
-  EXPECT_EQ("a", c_out[1]->outputs_[0]->path());
-
-  fs_.Create("b", "");
-  EXPECT_TRUE(builder_.AddTarget("a", &err));
-  ASSERT_EQ("", err);
-
-  EXPECT_TRUE(builder_.Build(&err));
-  ASSERT_EQ("", err);
-  ASSERT_EQ(2u, command_runner_.commands_ran_.size());
-}
-
 TEST_F(BuildTest, OrderOnlyDeps) {
   string err;
   ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
@@ -1068,19 +1038,6 @@
   EXPECT_TRUE(builder_.AlreadyUpToDate());
 }
 
-// Test a self-referencing phony.  Ideally this should not work, but
-// ninja 1.7 and below tolerated and CMake 2.8.12.x and 3.0.x both
-// incorrectly produce it.  We tolerate it for compatibility.
-TEST_F(BuildTest, PhonySelfReference) {
-  string err;
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-"build a: phony a\n"));
-
-  EXPECT_TRUE(builder_.AddTarget("a", &err));
-  ASSERT_EQ("", err);
-  EXPECT_TRUE(builder_.AlreadyUpToDate());
-}
-
 TEST_F(BuildTest, Fail) {
   ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
 "rule fail\n"
@@ -1138,30 +1095,6 @@
   ASSERT_EQ("cannot make progress due to previous errors", err);
 }
 
-TEST_F(BuildTest, SwallowFailuresPool) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-"pool failpool\n"
-"  depth = 1\n"
-"rule fail\n"
-"  command = fail\n"
-"  pool = failpool\n"
-"build out1: fail\n"
-"build out2: fail\n"
-"build out3: fail\n"
-"build final: cat out1 out2 out3\n"));
-
-  // Swallow ten failures; we should stop before building final.
-  config_.failures_allowed = 11;
-
-  string err;
-  EXPECT_TRUE(builder_.AddTarget("final", &err));
-  ASSERT_EQ("", err);
-
-  EXPECT_FALSE(builder_.Build(&err));
-  ASSERT_EQ(3u, command_runner_.commands_ran_.size());
-  ASSERT_EQ("cannot make progress due to previous errors", err);
-}
-
 TEST_F(BuildTest, PoolEdgesReadyButNotWanted) {
   fs_.Create("x", "");
 
@@ -1220,82 +1153,6 @@
   EXPECT_TRUE(builder_.AlreadyUpToDate());
 }
 
-TEST_F(BuildWithLogTest, RebuildAfterFailure) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-"rule touch-fail-tick2\n"
-"  command = touch-fail-tick2\n"
-"build out1: touch-fail-tick2 in\n"));
-
-  string err;
-
-  fs_.Create("in", "");
-
-  // Run once successfully to get out1 in the log
-  EXPECT_TRUE(builder_.AddTarget("out1", &err));
-  EXPECT_TRUE(builder_.Build(&err));
-  EXPECT_EQ("", err);
-  EXPECT_EQ(1u, command_runner_.commands_ran_.size());
-
-  command_runner_.commands_ran_.clear();
-  state_.Reset();
-  builder_.Cleanup();
-  builder_.plan_.Reset();
-
-  fs_.Tick();
-  fs_.Create("in", "");
-
-  // Run again with a failure that updates the output file timestamp
-  EXPECT_TRUE(builder_.AddTarget("out1", &err));
-  EXPECT_FALSE(builder_.Build(&err));
-  EXPECT_EQ("subcommand failed", err);
-  EXPECT_EQ(1u, command_runner_.commands_ran_.size());
-
-  command_runner_.commands_ran_.clear();
-  state_.Reset();
-  builder_.Cleanup();
-  builder_.plan_.Reset();
-
-  fs_.Tick();
-
-  // Run again, should rerun even though the output file is up to date on disk
-  EXPECT_TRUE(builder_.AddTarget("out1", &err));
-  EXPECT_FALSE(builder_.AlreadyUpToDate());
-  EXPECT_TRUE(builder_.Build(&err));
-  EXPECT_EQ(1u, command_runner_.commands_ran_.size());
-  EXPECT_EQ("", err);
-}
-
-TEST_F(BuildWithLogTest, RebuildWithNoInputs) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-"rule touch\n"
-"  command = touch\n"
-"build out1: touch\n"
-"build out2: touch in\n"));
-
-  string err;
-
-  fs_.Create("in", "");
-
-  EXPECT_TRUE(builder_.AddTarget("out1", &err));
-  EXPECT_TRUE(builder_.AddTarget("out2", &err));
-  EXPECT_TRUE(builder_.Build(&err));
-  EXPECT_EQ("", err);
-  EXPECT_EQ(2u, command_runner_.commands_ran_.size());
-
-  command_runner_.commands_ran_.clear();
-  state_.Reset();
-
-  fs_.Tick();
-
-  fs_.Create("in", "");
-
-  EXPECT_TRUE(builder_.AddTarget("out1", &err));
-  EXPECT_TRUE(builder_.AddTarget("out2", &err));
-  EXPECT_TRUE(builder_.Build(&err));
-  EXPECT_EQ("", err);
-  EXPECT_EQ(1u, command_runner_.commands_ran_.size());
-}
-
 TEST_F(BuildWithLogTest, RestatTest) {
   ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
 "rule true\n"
@@ -1324,8 +1181,7 @@
   ASSERT_EQ("", err);
   EXPECT_TRUE(builder_.Build(&err));
   ASSERT_EQ("", err);
-  EXPECT_EQ("[3/3]", builder_.status_->FormatProgressStatus("[%s/%t]",
-      BuildStatus::kEdgeStarted));
+  EXPECT_EQ("[3/3]", builder_.status_->FormatProgressStatus("[%s/%t]"));
   command_runner_.commands_ran_.clear();
   state_.Reset();
 
@@ -1443,7 +1299,7 @@
 }
 
 // Test scenario, in which an input file is removed, but output isn't changed
-// https://github.com/ninja-build/ninja/issues/295
+// https://github.com/martine/ninja/issues/295
 TEST_F(BuildWithLogTest, RestatMissingInput) {
   ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
     "rule true\n"
@@ -1476,7 +1332,7 @@
   // the right mtime
   BuildLog::LogEntry* log_entry = build_log_.LookupByOutput("out1");
   ASSERT_TRUE(NULL != log_entry);
-  ASSERT_EQ(restat_mtime, log_entry->mtime);
+  ASSERT_EQ(restat_mtime, log_entry->restat_mtime);
 
   // Now remove a file, referenced from depfile, so that target becomes
   // dirty, but the output does not change
@@ -1493,7 +1349,7 @@
   // Check that the logfile entry remains correctly set
   log_entry = build_log_.LookupByOutput("out1");
   ASSERT_TRUE(NULL != log_entry);
-  ASSERT_EQ(restat_mtime, log_entry->mtime);
+  ASSERT_EQ(restat_mtime, log_entry->restat_mtime);
 }
 
 struct BuildDryRun : public BuildWithLogTest {
@@ -1707,8 +1563,8 @@
 TEST_F(BuildTest, StatFailureAbortsBuild) {
   const string kTooLongToStat(400, 'i');
   ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-("build " + kTooLongToStat + ": cat in\n").c_str()));
-  fs_.Create("in", "");
+("build " + kTooLongToStat + ": cat " + kTooLongToStat + "\n").c_str()));
+  // Also cyclic, for good measure.
 
   // This simulates a stat failure:
   fs_.files_[kTooLongToStat].mtime = -1;
@@ -1763,18 +1619,9 @@
   ASSERT_EQ(1u, command_runner_.commands_ran_.size());
 }
 
-TEST_F(BuildTest, StatusFormatElapsed) {
-  status_.BuildStarted();
-  // Before any task is done, the elapsed time must be zero.
-  EXPECT_EQ("[%/e0.000]",
-            status_.FormatProgressStatus("[%%/e%e]",
-                BuildStatus::kEdgeStarted));
-}
-
 TEST_F(BuildTest, StatusFormatReplacePlaceholder) {
   EXPECT_EQ("[%/s0/t0/r0/u0/f0]",
-            status_.FormatProgressStatus("[%%/s%s/t%t/r%r/u%u/f%f]",
-                BuildStatus::kEdgeStarted));
+            status_.FormatProgressStatus("[%%/s%s/t%t/r%r/u%u/f%f]"));
 }
 
 TEST_F(BuildTest, FailedDepsParse) {
@@ -2200,7 +2047,7 @@
 #endif
 
 /// Check that a restat rule doesn't clear an edge if the depfile is missing.
-/// Follows from: https://github.com/ninja-build/ninja/issues/603
+/// Follows from: https://github.com/martine/ninja/issues/603
 TEST_F(BuildTest, RestatMissingDepfile) {
 const char* manifest =
 "rule true\n"
@@ -2224,7 +2071,7 @@
 }
 
 /// Check that a restat rule doesn't clear an edge if the deps are missing.
-/// https://github.com/ninja-build/ninja/issues/603
+/// https://github.com/martine/ninja/issues/603
 TEST_F(BuildWithDepsLogTest, RestatMissingDepfileDepslog) {
   string err;
   const char* manifest =
diff -Naur ninja-1.9.0.orig/src/canon_perftest.cc ninja/src/canon_perftest.cc
--- ninja-1.9.0.orig/src/canon_perftest.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/canon_perftest.cc	2019-09-24 19:51:29.603792938 +0000
@@ -33,7 +33,7 @@
   for (int j = 0; j < 5; ++j) {
     const int kNumRepetitions = 2000000;
     int64_t start = GetTimeMillis();
-    uint64_t slash_bits;
+    unsigned int slash_bits;
     for (int i = 0; i < kNumRepetitions; ++i) {
       CanonicalizePath(buf, &len, &slash_bits, &err);
     }
diff -Naur ninja-1.9.0.orig/src/clean.cc ninja/src/clean.cc
--- ninja-1.9.0.orig/src/clean.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/clean.cc	2019-09-24 19:51:29.605266538 +0000
@@ -101,7 +101,6 @@
     printf("\n");
   else
     printf(" ");
-  fflush(stdout);
 }
 
 void Cleaner::PrintFooter() {
@@ -181,22 +180,15 @@
   Reset();
   PrintHeader();
   for (int i = 0; i < target_count; ++i) {
-    string target_name = targets[i];
-    uint64_t slash_bits;
-    string err;
-    if (!CanonicalizePath(&target_name, &slash_bits, &err)) {
-      Error("failed to canonicalize '%s': %s", target_name.c_str(), err.c_str());
-      status_ = 1;
+    const char* target_name = targets[i];
+    Node* target = state_->LookupNode(target_name);
+    if (target) {
+      if (IsVerbose())
+        printf("Target %s\n", target_name);
+      DoCleanTarget(target);
     } else {
-      Node* target = state_->LookupNode(target_name);
-      if (target) {
-        if (IsVerbose())
-          printf("Target %s\n", target_name.c_str());
-        DoCleanTarget(target);
-      } else {
-        Error("unknown target '%s'", target_name.c_str());
-        status_ = 1;
-      }
+      Error("unknown target '%s'", target_name);
+      status_ = 1;
     }
   }
   PrintFooter();
diff -Naur ninja-1.9.0.orig/src/clparser.cc ninja/src/clparser.cc
--- ninja-1.9.0.orig/src/clparser.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/clparser.cc	1969-12-31 19:00:00.000000000 +0000
@@ -1,126 +0,0 @@
-// Copyright 2015 Google Inc. All Rights Reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "clparser.h"
-
-#include <algorithm>
-#include <assert.h>
-#include <string.h>
-
-#include "metrics.h"
-#include "string_piece_util.h"
-
-#ifdef _WIN32
-#include "includes_normalize.h"
-#include "string_piece.h"
-#else
-#include "util.h"
-#endif
-
-namespace {
-
-/// Return true if \a input ends with \a needle.
-bool EndsWith(const string& input, const string& needle) {
-  return (input.size() >= needle.size() &&
-          input.substr(input.size() - needle.size()) == needle);
-}
-
-}  // anonymous namespace
-
-// static
-string CLParser::FilterShowIncludes(const string& line,
-                                    const string& deps_prefix) {
-  const string kDepsPrefixEnglish = "Note: including file: ";
-  const char* in = line.c_str();
-  const char* end = in + line.size();
-  const string& prefix = deps_prefix.empty() ? kDepsPrefixEnglish : deps_prefix;
-  if (end - in > (int)prefix.size() &&
-      memcmp(in, prefix.c_str(), (int)prefix.size()) == 0) {
-    in += prefix.size();
-    while (*in == ' ')
-      ++in;
-    return line.substr(in - line.c_str());
-  }
-  return "";
-}
-
-// static
-bool CLParser::IsSystemInclude(string path) {
-  transform(path.begin(), path.end(), path.begin(), ToLowerASCII);
-  // TODO: this is a heuristic, perhaps there's a better way?
-  return (path.find("program files") != string::npos ||
-          path.find("microsoft visual studio") != string::npos);
-}
-
-// static
-bool CLParser::FilterInputFilename(string line) {
-  transform(line.begin(), line.end(), line.begin(), ToLowerASCII);
-  // TODO: other extensions, like .asm?
-  return EndsWith(line, ".c") ||
-      EndsWith(line, ".cc") ||
-      EndsWith(line, ".cxx") ||
-      EndsWith(line, ".cpp");
-}
-
-// static
-bool CLParser::Parse(const string& output, const string& deps_prefix,
-                     string* filtered_output, string* err) {
-  METRIC_RECORD("CLParser::Parse");
-
-  // Loop over all lines in the output to process them.
-  assert(&output != filtered_output);
-  size_t start = 0;
-#ifdef _WIN32
-  IncludesNormalize normalizer(".");
-#endif
-
-  while (start < output.size()) {
-    size_t end = output.find_first_of("\r\n", start);
-    if (end == string::npos)
-      end = output.size();
-    string line = output.substr(start, end - start);
-
-    string include = FilterShowIncludes(line, deps_prefix);
-    if (!include.empty()) {
-      string normalized;
-#ifdef _WIN32
-      if (!normalizer.Normalize(include, &normalized, err))
-        return false;
-#else
-      // TODO: should this make the path relative to cwd?
-      normalized = include;
-      uint64_t slash_bits;
-      if (!CanonicalizePath(&normalized, &slash_bits, err))
-        return false;
-#endif
-      if (!IsSystemInclude(normalized))
-        includes_.insert(normalized);
-    } else if (FilterInputFilename(line)) {
-      // Drop it.
-      // TODO: if we support compiling multiple output files in a single
-      // cl.exe invocation, we should stash the filename.
-    } else {
-      filtered_output->append(line);
-      filtered_output->append("\n");
-    }
-
-    if (end < output.size() && output[end] == '\r')
-      ++end;
-    if (end < output.size() && output[end] == '\n')
-      ++end;
-    start = end;
-  }
-
-  return true;
-}
diff -Naur ninja-1.9.0.orig/src/clparser.h ninja/src/clparser.h
--- ninja-1.9.0.orig/src/clparser.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/clparser.h	1969-12-31 19:00:00.000000000 +0000
@@ -1,52 +0,0 @@
-// Copyright 2015 Google Inc. All Rights Reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef NINJA_CLPARSER_H_
-#define NINJA_CLPARSER_H_
-
-#include <set>
-#include <string>
-using namespace std;
-
-/// Visual Studio's cl.exe requires some massaging to work with Ninja;
-/// for example, it emits include information on stderr in a funny
-/// format when building with /showIncludes.  This class parses this
-/// output.
-struct CLParser {
-  /// Parse a line of cl.exe output and extract /showIncludes info.
-  /// If a dependency is extracted, returns a nonempty string.
-  /// Exposed for testing.
-  static string FilterShowIncludes(const string& line,
-                                   const string& deps_prefix);
-
-  /// Return true if a mentioned include file is a system path.
-  /// Filtering these out reduces dependency information considerably.
-  static bool IsSystemInclude(string path);
-
-  /// Parse a line of cl.exe output and return true if it looks like
-  /// it's printing an input filename.  This is a heuristic but it appears
-  /// to be the best we can do.
-  /// Exposed for testing.
-  static bool FilterInputFilename(string line);
-
-  /// Parse the full output of cl, filling filtered_output with the text that
-  /// should be printed (if any). Returns true on success, or false with err
-  /// filled. output must not be the same object as filtered_object.
-  bool Parse(const string& output, const string& deps_prefix,
-             string* filtered_output, string* err);
-
-  set<string> includes_;
-};
-
-#endif  // NINJA_CLPARSER_H_
diff -Naur ninja-1.9.0.orig/src/clparser_perftest.cc ninja/src/clparser_perftest.cc
--- ninja-1.9.0.orig/src/clparser_perftest.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/clparser_perftest.cc	1969-12-31 19:00:00.000000000 +0000
@@ -1,157 +0,0 @@
-// Copyright 2017 Google Inc. All Rights Reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "clparser.h"
-#include "metrics.h"
-
-int main(int argc, char* argv[]) {
-  // Output of /showIncludes from #include <iostream>
-  string perf_testdata =
-      "Note: including file: C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\iostream\r\n"
-      "Note: including file:  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\istream\r\n"
-      "Note: including file:   C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\ostream\r\n"
-      "Note: including file:    C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\ios\r\n"
-      "Note: including file:     C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xlocnum\r\n"
-      "Note: including file:      C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\climits\r\n"
-      "Note: including file:       C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h\r\n"
-      "Note: including file:        C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xkeycheck.h\r\n"
-      "Note: including file:        C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\crtdefs.h\r\n"
-      "Note: including file:         C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h\r\n"
-      "Note: including file:          C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h\r\n"
-      "Note: including file:           C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\ConcurrencySal.h\r\n"
-      "Note: including file:          C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vadefs.h\r\n"
-      "Note: including file:         C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h\r\n"
-      "Note: including file:          C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h\r\n"
-      "Note: including file:        C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\use_ansi.h\r\n"
-      "Note: including file:       C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits.h\r\n"
-      "Note: including file:        C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h\r\n"
-      "Note: including file:      C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cmath\r\n"
-      "Note: including file:       C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\math.h\r\n"
-      "Note: including file:       C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xtgmath.h\r\n"
-      "Note: including file:        C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xtr1common\r\n"
-      "Note: including file:         C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cstdlib\r\n"
-      "Note: including file:          C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h\r\n"
-      "Note: including file:           C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_malloc.h\r\n"
-      "Note: including file:           C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_search.h\r\n"
-      "Note: including file:            C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\stddef.h\r\n"
-      "Note: including file:           C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h\r\n"
-      "Note: including file:      C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cstdio\r\n"
-      "Note: including file:       C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h\r\n"
-      "Note: including file:        C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h\r\n"
-      "Note: including file:         C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h\r\n"
-      "Note: including file:      C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\streambuf\r\n"
-      "Note: including file:       C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xiosbase\r\n"
-      "Note: including file:        C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xlocale\r\n"
-      "Note: including file:         C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cstring\r\n"
-      "Note: including file:          C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\string.h\r\n"
-      "Note: including file:           C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memory.h\r\n"
-      "Note: including file:            C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\errno.h\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime_string.h\r\n"
-      "Note: including file:              C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h\r\n"
-      "Note: including file:           C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h\r\n"
-      "Note: including file:         C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\stdexcept\r\n"
-      "Note: including file:          C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\exception\r\n"
-      "Note: including file:           C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\type_traits\r\n"
-      "Note: including file:            C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xstddef\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cstddef\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\initializer_list\r\n"
-      "Note: including file:           C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h\r\n"
-      "Note: including file:           C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime_exception.h\r\n"
-      "Note: including file:            C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\eh.h\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_terminate.h\r\n"
-      "Note: including file:          C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xstring\r\n"
-      "Note: including file:           C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xmemory0\r\n"
-      "Note: including file:            C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cstdint\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\stdint.h\r\n"
-      "Note: including file:              C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h\r\n"
-      "Note: including file:            C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\ymath.h\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cfloat\r\n"
-      "Note: including file:              C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\float.h\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cwchar\r\n"
-      "Note: including file:              C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h\r\n"
-      "Note: including file:               C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h\r\n"
-      "Note: including file:               C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wctype.h\r\n"
-      "Note: including file:               C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wdirect.h\r\n"
-      "Note: including file:               C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h\r\n"
-      "Note: including file:                C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_share.h\r\n"
-      "Note: including file:               C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wprocess.h\r\n"
-      "Note: including file:               C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h\r\n"
-      "Note: including file:               C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\sys/stat.h\r\n"
-      "Note: including file:                C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\sys/types.h\r\n"
-      "Note: including file:            C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\new\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime_new.h\r\n"
-      "Note: including file:              C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h\r\n"
-      "Note: including file:            C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xutility\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\utility\r\n"
-      "Note: including file:              C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\iosfwd\r\n"
-      "Note: including file:               C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h\r\n"
-      "Note: including file:                C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime_new_debug.h\r\n"
-      "Note: including file:            C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xatomic0.h\r\n"
-      "Note: including file:            C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\intrin.h\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\setjmp.h\r\n"
-      "Note: including file:              C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\immintrin.h\r\n"
-      "Note: including file:              C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\wmmintrin.h\r\n"
-      "Note: including file:               C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\nmmintrin.h\r\n"
-      "Note: including file:                C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\smmintrin.h\r\n"
-      "Note: including file:                 C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\tmmintrin.h\r\n"
-      "Note: including file:                  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\pmmintrin.h\r\n"
-      "Note: including file:                   C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\emmintrin.h\r\n"
-      "Note: including file:                    C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xmmintrin.h\r\n"
-      "Note: including file:                     C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\mmintrin.h\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\ammintrin.h\r\n"
-      "Note: including file:             C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\mm3dnow.h\r\n"
-      "Note: including file:              C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h\r\n"
-      "Note: including file:         C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\typeinfo\r\n"
-      "Note: including file:          C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime_typeinfo.h\r\n"
-      "Note: including file:           C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h\r\n"
-      "Note: including file:         C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xlocinfo\r\n"
-      "Note: including file:          C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xlocinfo.h\r\n"
-      "Note: including file:           C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h\r\n"
-      "Note: including file:           C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\locale.h\r\n"
-      "Note: including file:         C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xfacet\r\n"
-      "Note: including file:        C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\system_error\r\n"
-      "Note: including file:         C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cerrno\r\n"
-      "Note: including file:        C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10240.0\\ucrt\\share.h\r\n";
-
-  for (int limit = 1 << 10; limit < (1<<20); limit *= 2) {
-    int64_t start = GetTimeMillis();
-    for (int rep = 0; rep < limit; ++rep) {
-      string output;
-      string err;
-
-      CLParser parser;
-      if (!parser.Parse(perf_testdata, "", &output, &err)) {
-        printf("%s\n", err.c_str());
-        return 1;
-      }
-    }
-    int64_t end = GetTimeMillis();
-
-    if (end - start > 2000) {
-      int delta_ms = (int)(end - start);
-      printf("Parse %d times in %dms avg %.1fus\n",
-             limit, delta_ms, float(delta_ms * 1000) / limit);
-      break;
-    }
-  }
-
-  return 0;
-}
diff -Naur ninja-1.9.0.orig/src/clparser_test.cc ninja/src/clparser_test.cc
--- ninja-1.9.0.orig/src/clparser_test.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/clparser_test.cc	1969-12-31 19:00:00.000000000 +0000
@@ -1,117 +0,0 @@
-// Copyright 2011 Google Inc. All Rights Reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "clparser.h"
-
-#include "test.h"
-#include "util.h"
-
-TEST(CLParserTest, ShowIncludes) {
-  ASSERT_EQ("", CLParser::FilterShowIncludes("", ""));
-
-  ASSERT_EQ("", CLParser::FilterShowIncludes("Sample compiler output", ""));
-  ASSERT_EQ("c:\\Some Files\\foobar.h",
-            CLParser::FilterShowIncludes("Note: including file: "
-                                         "c:\\Some Files\\foobar.h", ""));
-  ASSERT_EQ("c:\\initspaces.h",
-            CLParser::FilterShowIncludes("Note: including file:    "
-                                         "c:\\initspaces.h", ""));
-  ASSERT_EQ("c:\\initspaces.h",
-            CLParser::FilterShowIncludes("Non-default prefix: inc file:    "
-                                         "c:\\initspaces.h",
-                    "Non-default prefix: inc file:"));
-}
-
-TEST(CLParserTest, FilterInputFilename) {
-  ASSERT_TRUE(CLParser::FilterInputFilename("foobar.cc"));
-  ASSERT_TRUE(CLParser::FilterInputFilename("foo bar.cc"));
-  ASSERT_TRUE(CLParser::FilterInputFilename("baz.c"));
-  ASSERT_TRUE(CLParser::FilterInputFilename("FOOBAR.CC"));
-
-  ASSERT_FALSE(CLParser::FilterInputFilename(
-                   "src\\cl_helper.cc(166) : fatal error C1075: end "
-                   "of file found ..."));
-}
-
-TEST(CLParserTest, ParseSimple) {
-  CLParser parser;
-  string output, err;
-  ASSERT_TRUE(parser.Parse(
-      "foo\r\n"
-      "Note: inc file prefix:  foo.h\r\n"
-      "bar\r\n",
-      "Note: inc file prefix:", &output, &err));
-
-  ASSERT_EQ("foo\nbar\n", output);
-  ASSERT_EQ(1u, parser.includes_.size());
-  ASSERT_EQ("foo.h", *parser.includes_.begin());
-}
-
-TEST(CLParserTest, ParseFilenameFilter) {
-  CLParser parser;
-  string output, err;
-  ASSERT_TRUE(parser.Parse(
-      "foo.cc\r\n"
-      "cl: warning\r\n",
-      "", &output, &err));
-  ASSERT_EQ("cl: warning\n", output);
-}
-
-TEST(CLParserTest, ParseSystemInclude) {
-  CLParser parser;
-  string output, err;
-  ASSERT_TRUE(parser.Parse(
-      "Note: including file: c:\\Program Files\\foo.h\r\n"
-      "Note: including file: d:\\Microsoft Visual Studio\\bar.h\r\n"
-      "Note: including file: path.h\r\n",
-      "", &output, &err));
-  // We should have dropped the first two includes because they look like
-  // system headers.
-  ASSERT_EQ("", output);
-  ASSERT_EQ(1u, parser.includes_.size());
-  ASSERT_EQ("path.h", *parser.includes_.begin());
-}
-
-TEST(CLParserTest, DuplicatedHeader) {
-  CLParser parser;
-  string output, err;
-  ASSERT_TRUE(parser.Parse(
-      "Note: including file: foo.h\r\n"
-      "Note: including file: bar.h\r\n"
-      "Note: including file: foo.h\r\n",
-      "", &output, &err));
-  // We should have dropped one copy of foo.h.
-  ASSERT_EQ("", output);
-  ASSERT_EQ(2u, parser.includes_.size());
-}
-
-TEST(CLParserTest, DuplicatedHeaderPathConverted) {
-  CLParser parser;
-  string output, err;
-
-  // This isn't inline in the Parse() call below because the #ifdef in
-  // a macro expansion would confuse MSVC2013's preprocessor.
-  const char kInput[] =
-      "Note: including file: sub/./foo.h\r\n"
-      "Note: including file: bar.h\r\n"
-#ifdef _WIN32
-      "Note: including file: sub\\foo.h\r\n";
-#else
-      "Note: including file: sub/foo.h\r\n";
-#endif
-  ASSERT_TRUE(parser.Parse(kInput, "", &output, &err));
-  // We should have dropped one copy of foo.h.
-  ASSERT_EQ("", output);
-  ASSERT_EQ(2u, parser.includes_.size());
-}
diff -Naur ninja-1.9.0.orig/src/debug_flags.cc ninja/src/debug_flags.cc
--- ninja-1.9.0.orig/src/debug_flags.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/debug_flags.cc	2019-09-24 19:51:29.608521738 +0000
@@ -14,8 +14,6 @@
 
 bool g_explaining = false;
 
-bool g_keep_depfile = false;
-
 bool g_keep_rsp = false;
 
 bool g_experimental_statcache = true;
diff -Naur ninja-1.9.0.orig/src/debug_flags.h ninja/src/debug_flags.h
--- ninja-1.9.0.orig/src/debug_flags.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/debug_flags.h	2019-09-24 19:51:29.609429738 +0000
@@ -24,8 +24,6 @@
 
 extern bool g_explaining;
 
-extern bool g_keep_depfile;
-
 extern bool g_keep_rsp;
 
 extern bool g_experimental_statcache;
diff -Naur ninja-1.9.0.orig/src/depfile_parser.cc ninja/src/depfile_parser.cc
--- ninja-1.9.0.orig/src/depfile_parser.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/depfile_parser.cc	2019-09-24 19:51:29.610698538 +0000
@@ -1,4 +1,4 @@
-/* Generated by re2c 1.1.1 */
+/* Generated by re2c 0.13.5 */
 // Copyright 2011 Google Inc. All Rights Reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,12 +14,6 @@
 // limitations under the License.
 
 #include "depfile_parser.h"
-#include "util.h"
-
-DepfileParser::DepfileParser(DepfileParserOptions options)
-  : options_(options)
-{
-}
 
 // A note on backslashes in Makefiles, from reading the docs:
 // Backslash-newline is the line continuation character.
@@ -41,13 +35,8 @@
   // parsing_targets: whether we are parsing targets or dependencies.
   char* in = &(*content)[0];
   char* end = in + content->size();
-  bool have_target = false;
-  bool have_secondary_target_on_this_rule = false;
-  bool have_newline_since_primary_target = false;
-  bool warned_distinct_target_lines = false;
   bool parsing_targets = true;
   while (in < end) {
-    bool have_newline = false;
     // out: current output point (typically same as in, but can fall behind
     // as we de-escape backslashes).
     char* out = in;
@@ -56,16 +45,15 @@
     for (;;) {
       // start: beginning of the current parsed span.
       const char* start = in;
-      char* yymarker = NULL;
       
     {
-      unsigned char yych;
+      char yych;
       static const unsigned char yybm[] = {
           0,   0,   0,   0,   0,   0,   0,   0, 
           0,   0,   0,   0,   0,   0,   0,   0, 
           0,   0,   0,   0,   0,   0,   0,   0, 
           0,   0,   0,   0,   0,   0,   0,   0, 
-          0, 128,   0,   0,   0, 128,   0,   0, 
+          0, 128,   0,   0,   0,   0,   0,   0, 
         128, 128,   0, 128, 128, 128, 128, 128, 
         128, 128, 128, 128, 128, 128, 128, 128, 
         128, 128, 128,   0,   0, 128,   0,   0, 
@@ -77,72 +65,101 @@
         128, 128, 128, 128, 128, 128, 128, 128, 
         128, 128, 128, 128, 128, 128, 128, 128, 
         128, 128, 128, 128,   0, 128, 128,   0, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
-        128, 128, 128, 128, 128, 128, 128, 128, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
+          0,   0,   0,   0,   0,   0,   0,   0, 
       };
+
       yych = *in;
-      if (yybm[0+yych] & 128) {
-        goto yy9;
-      }
-      if (yych <= '\r') {
-        if (yych <= '\t') {
-          if (yych >= 0x01) goto yy4;
+      if (yych <= '=') {
+        if (yych <= '$') {
+          if (yych <= ' ') {
+            if (yych <= 0x00) goto yy7;
+            goto yy9;
+          } else {
+            if (yych <= '!') goto yy5;
+            if (yych <= '#') goto yy9;
+            goto yy4;
+          }
         } else {
-          if (yych <= '\n') goto yy6;
-          if (yych <= '\f') goto yy4;
-          goto yy8;
+          if (yych <= '*') {
+            if (yych <= '\'') goto yy9;
+            if (yych <= ')') goto yy5;
+            goto yy9;
+          } else {
+            if (yych <= ':') goto yy5;
+            if (yych <= '<') goto yy9;
+            goto yy5;
+          }
         }
       } else {
-        if (yych <= '$') {
-          if (yych <= '#') goto yy4;
-          goto yy12;
+        if (yych <= '^') {
+          if (yych <= 'Z') {
+            if (yych <= '?') goto yy9;
+            goto yy5;
+          } else {
+            if (yych != '\\') goto yy9;
+          }
         } else {
-          if (yych == '\\') goto yy13;
-          goto yy4;
+          if (yych <= '{') {
+            if (yych == '`') goto yy9;
+            goto yy5;
+          } else {
+            if (yych <= '|') goto yy9;
+            if (yych <= '~') goto yy5;
+            goto yy9;
+          }
         }
       }
       ++in;
-      {
-        break;
+      if ((yych = *in) <= '"') {
+        if (yych <= '\f') {
+          if (yych <= 0x00) goto yy3;
+          if (yych != '\n') goto yy14;
+        } else {
+          if (yych <= '\r') goto yy3;
+          if (yych == ' ') goto yy16;
+          goto yy14;
+        }
+      } else {
+        if (yych <= 'Z') {
+          if (yych <= '#') goto yy16;
+          if (yych == '*') goto yy16;
+          goto yy14;
+        } else {
+          if (yych <= '\\') goto yy16;
+          if (yych == '|') goto yy16;
+          goto yy14;
+        }
       }
-yy4:
-      ++in;
-yy5:
+yy3:
       {
         // For any other character (e.g. whitespace), swallow it here,
         // allowing the outer logic to loop around again.
         break;
       }
-yy6:
-      ++in;
-      {
-        // A newline ends the current file name and the current rule.
-        have_newline = true;
-        break;
-      }
-yy8:
-      yych = *++in;
-      if (yych == '\n') goto yy6;
-      goto yy5;
-yy9:
+yy4:
       yych = *++in;
-      if (yybm[0+yych] & 128) {
-        goto yy9;
-      }
+      if (yych == '$') goto yy12;
+      goto yy3;
+yy5:
+      ++in;
+      yych = *in;
+      goto yy11;
+yy6:
       {
         // Got a span of plain text.
         int len = (int)(in - start);
@@ -152,41 +169,30 @@
         out += len;
         continue;
       }
-yy12:
+yy7:
+      ++in;
+      {
+        break;
+      }
+yy9:
       yych = *++in;
-      if (yych == '$') goto yy14;
-      goto yy5;
-yy13:
-      yych = *(yymarker = ++in);
-      if (yych <= '"') {
-        if (yych <= '\f') {
-          if (yych <= 0x00) goto yy5;
-          if (yych == '\n') goto yy18;
-          goto yy16;
-        } else {
-          if (yych <= '\r') goto yy20;
-          if (yych == ' ') goto yy22;
-          goto yy16;
-        }
-      } else {
-        if (yych <= 'Z') {
-          if (yych <= '#') goto yy22;
-          if (yych == '*') goto yy22;
-          goto yy16;
-        } else {
-          if (yych <= ']') goto yy22;
-          if (yych == '|') goto yy22;
-          goto yy16;
-        }
+      goto yy3;
+yy10:
+      ++in;
+      yych = *in;
+yy11:
+      if (yybm[0+yych] & 128) {
+        goto yy10;
       }
-yy14:
+      goto yy6;
+yy12:
       ++in;
       {
         // De-escape dollar character.
         *out++ = '$';
         continue;
       }
-yy16:
+yy14:
       ++in;
       {
         // Let backslash before other characters through verbatim.
@@ -194,18 +200,7 @@
         *out++ = yych;
         continue;
       }
-yy18:
-      ++in;
-      {
-        // A line continuation ends the current file name.
-        break;
-      }
-yy20:
-      yych = *++in;
-      if (yych == '\n') goto yy18;
-      in = yymarker;
-      goto yy5;
-yy22:
+yy16:
       ++in;
       {
         // De-escape backslashed character.
@@ -217,52 +212,25 @@
     }
 
     int len = (int)(out - filename);
-    const bool is_dependency = !parsing_targets;
+    const bool is_target = parsing_targets;
     if (len > 0 && filename[len - 1] == ':') {
       len--;  // Strip off trailing colon, if any.
       parsing_targets = false;
-      have_target = true;
     }
 
-    if (len > 0) {
-      if (is_dependency) {
-        if (have_secondary_target_on_this_rule) {
-          if (!have_newline_since_primary_target) {
-            *err = "depfile has multiple output paths";
-            return false;
-          } else if (options_.depfile_distinct_target_lines_action_ ==
-                     kDepfileDistinctTargetLinesActionError) {
-            *err =
-                "depfile has multiple output paths (on separate lines)"
-                " [-w depfilemulti=err]";
-            return false;
-          } else {
-            if (!warned_distinct_target_lines) {
-              warned_distinct_target_lines = true;
-              Warning("depfile has multiple output paths (on separate lines); "
-                      "continuing anyway [-w depfilemulti=warn]");
-            }
-            continue;
-          }
-        }
-        ins_.push_back(StringPiece(filename, len));
-      } else if (!out_.str_) {
-        out_ = StringPiece(filename, len);
-      } else if (out_ != StringPiece(filename, len)) {
-        have_secondary_target_on_this_rule = true;
-      }
-    }
+    if (len == 0)
+      continue;
 
-    if (have_newline) {
-      // A newline ends a rule so the next filename will be a new target.
-      parsing_targets = true;
-      have_secondary_target_on_this_rule = false;
-      if (have_target) {
-        have_newline_since_primary_target = true;
-      }
+    if (!is_target) {
+      ins_.push_back(StringPiece(filename, len));
+    } else if (!out_.str_) {
+      out_ = StringPiece(filename, len);
+    } else if (out_ != StringPiece(filename, len)) {
+      *err = "depfile has multiple output paths";
+      return false;
     }
   }
-  if (!have_target) {
+  if (parsing_targets) {
     *err = "expected ':' in depfile";
     return false;
   }
diff -Naur ninja-1.9.0.orig/src/depfile_parser.h ninja/src/depfile_parser.h
--- ninja-1.9.0.orig/src/depfile_parser.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/depfile_parser.h	2019-09-24 19:51:29.611570538 +0000
@@ -21,24 +21,8 @@
 
 #include "string_piece.h"
 
-enum DepfileDistinctTargetLinesAction {
-  kDepfileDistinctTargetLinesActionWarn,
-  kDepfileDistinctTargetLinesActionError,
-};
-
-struct DepfileParserOptions {
-  DepfileParserOptions()
-      : depfile_distinct_target_lines_action_(
-          kDepfileDistinctTargetLinesActionWarn) {}
-  DepfileDistinctTargetLinesAction
-    depfile_distinct_target_lines_action_;
-};
-
 /// Parser for the dependency information emitted by gcc's -M flags.
 struct DepfileParser {
-  explicit DepfileParser(DepfileParserOptions options =
-                         DepfileParserOptions());
-
   /// Parse an input file.  Input must be NUL-terminated.
   /// Warning: may mutate the content in-place and parsed StringPieces are
   /// pointers within it.
@@ -46,7 +30,6 @@
 
   StringPiece out_;
   vector<StringPiece> ins_;
-  DepfileParserOptions options_;
 };
 
 #endif // NINJA_DEPFILE_PARSER_H_
diff -Naur ninja-1.9.0.orig/src/depfile_parser.in.cc ninja/src/depfile_parser.in.cc
--- ninja-1.9.0.orig/src/depfile_parser.in.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/depfile_parser.in.cc	2019-09-24 19:51:29.612143338 +0000
@@ -13,12 +13,6 @@
 // limitations under the License.
 
 #include "depfile_parser.h"
-#include "util.h"
-
-DepfileParser::DepfileParser(DepfileParserOptions options)
-  : options_(options)
-{
-}
 
 // A note on backslashes in Makefiles, from reading the docs:
 // Backslash-newline is the line continuation character.
@@ -40,13 +34,8 @@
   // parsing_targets: whether we are parsing targets or dependencies.
   char* in = &(*content)[0];
   char* end = in + content->size();
-  bool have_target = false;
-  bool have_secondary_target_on_this_rule = false;
-  bool have_newline_since_primary_target = false;
-  bool warned_distinct_target_lines = false;
   bool parsing_targets = true;
   while (in < end) {
-    bool have_newline = false;
     // out: current output point (typically same as in, but can fall behind
     // as we de-escape backslashes).
     char* out = in;
@@ -55,12 +44,10 @@
     for (;;) {
       // start: beginning of the current parsed span.
       const char* start = in;
-      char* yymarker = NULL;
       /*!re2c
-      re2c:define:YYCTYPE = "unsigned char";
+      re2c:define:YYCTYPE = "char";
       re2c:define:YYCURSOR = in;
       re2c:define:YYLIMIT = end;
-      re2c:define:YYMARKER = yymarker;
 
       re2c:yyfill:enable = 0;
 
@@ -68,8 +55,7 @@
       re2c:indent:string = "  ";
 
       nul = "\000";
-      escape = [ \\#*[|\]];
-      newline = '\r'?'\n';
+      escape = [ \\#*[|];
 
       '\\' escape {
         // De-escape backslashed character.
@@ -87,7 +73,7 @@
         *out++ = yych;
         continue;
       }
-      [a-zA-Z0-9+,/_:.~()}{%@=!\x80-\xFF-]+ {
+      [a-zA-Z0-9+,/_:.~()}{@=!-]+ {
         // Got a span of plain text.
         int len = (int)(in - start);
         // Need to shift it over if we're overwriting backslashes.
@@ -99,15 +85,6 @@
       nul {
         break;
       }
-      '\\' newline {
-        // A line continuation ends the current file name.
-        break;
-      }
-      newline {
-        // A newline ends the current file name and the current rule.
-        have_newline = true;
-        break;
-      }
       [^] {
         // For any other character (e.g. whitespace), swallow it here,
         // allowing the outer logic to loop around again.
@@ -117,52 +94,25 @@
     }
 
     int len = (int)(out - filename);
-    const bool is_dependency = !parsing_targets;
+    const bool is_target = parsing_targets;
     if (len > 0 && filename[len - 1] == ':') {
       len--;  // Strip off trailing colon, if any.
       parsing_targets = false;
-      have_target = true;
     }
 
-    if (len > 0) {
-      if (is_dependency) {
-        if (have_secondary_target_on_this_rule) {
-          if (!have_newline_since_primary_target) {
-            *err = "depfile has multiple output paths";
-            return false;
-          } else if (options_.depfile_distinct_target_lines_action_ ==
-                     kDepfileDistinctTargetLinesActionError) {
-            *err =
-                "depfile has multiple output paths (on separate lines)"
-                " [-w depfilemulti=err]";
-            return false;
-          } else {
-            if (!warned_distinct_target_lines) {
-              warned_distinct_target_lines = true;
-              Warning("depfile has multiple output paths (on separate lines); "
-                      "continuing anyway [-w depfilemulti=warn]");
-            }
-            continue;
-          }
-        }
-        ins_.push_back(StringPiece(filename, len));
-      } else if (!out_.str_) {
-        out_ = StringPiece(filename, len);
-      } else if (out_ != StringPiece(filename, len)) {
-        have_secondary_target_on_this_rule = true;
-      }
-    }
+    if (len == 0)
+      continue;
 
-    if (have_newline) {
-      // A newline ends a rule so the next filename will be a new target.
-      parsing_targets = true;
-      have_secondary_target_on_this_rule = false;
-      if (have_target) {
-        have_newline_since_primary_target = true;
-      }
+    if (!is_target) {
+      ins_.push_back(StringPiece(filename, len));
+    } else if (!out_.str_) {
+      out_ = StringPiece(filename, len);
+    } else if (out_ != StringPiece(filename, len)) {
+      *err = "depfile has multiple output paths";
+      return false;
     }
   }
-  if (!have_target) {
+  if (parsing_targets) {
     *err = "expected ':' in depfile";
     return false;
   }
diff -Naur ninja-1.9.0.orig/src/depfile_parser_test.cc ninja/src/depfile_parser_test.cc
--- ninja-1.9.0.orig/src/depfile_parser_test.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/depfile_parser_test.cc	2019-09-24 19:51:29.613270538 +0000
@@ -119,34 +119,28 @@
   // https://github.com/google/libcxx/tree/master/test/iterators/stream.iterators/istreambuf.iterator/
   string err;
   EXPECT_TRUE(Parse(
-"C:/Program\\ Files\\ (x86)/Microsoft\\ crtdefs.h: \\\n"
-" en@quot.header~ t+t-x!=1 \\\n"
-" openldap/slapd.d/cn=config/cn=schema/cn={0}core.ldif\\\n"
-" Fu\303\244ball\\\n"
-" a\\[1\\]b@2%c",
+"C:/Program\\ Files\\ (x86)/Microsoft\\ crtdefs.h: \n"
+" en@quot.header~ t+t-x!=1 \n"
+" openldap/slapd.d/cn=config/cn=schema/cn={0}core.ldif",
       &err));
   ASSERT_EQ("", err);
   EXPECT_EQ("C:/Program Files (x86)/Microsoft crtdefs.h",
             parser_.out_.AsString());
-  ASSERT_EQ(5u, parser_.ins_.size());
+  ASSERT_EQ(3u, parser_.ins_.size());
   EXPECT_EQ("en@quot.header~",
             parser_.ins_[0].AsString());
   EXPECT_EQ("t+t-x!=1",
             parser_.ins_[1].AsString());
   EXPECT_EQ("openldap/slapd.d/cn=config/cn=schema/cn={0}core.ldif",
             parser_.ins_[2].AsString());
-  EXPECT_EQ("Fu\303\244ball",
-            parser_.ins_[3].AsString());
-  EXPECT_EQ("a[1]b@2%c",
-            parser_.ins_[4].AsString());
 }
 
 TEST_F(DepfileParserTest, UnifyMultipleOutputs) {
   // check that multiple duplicate targets are properly unified
   string err;
   EXPECT_TRUE(Parse("foo foo: x y z", &err));
-  ASSERT_EQ("foo", parser_.out_.AsString());
-  ASSERT_EQ(3u, parser_.ins_.size());
+  ASSERT_EQ(parser_.out_.AsString(), "foo");
+  ASSERT_EQ(parser_.ins_.size(), 3u);
   EXPECT_EQ("x", parser_.ins_[0].AsString());
   EXPECT_EQ("y", parser_.ins_[1].AsString());
   EXPECT_EQ("z", parser_.ins_[2].AsString());
@@ -158,133 +152,3 @@
   EXPECT_FALSE(Parse("foo bar: x y z", &err));
   ASSERT_EQ("depfile has multiple output paths", err);
 }
-
-TEST_F(DepfileParserTest, MultipleEmptyRules) {
-  string err;
-  EXPECT_TRUE(Parse("foo: x\n"
-                    "foo: \n"
-                    "foo:\n", &err));
-  ASSERT_EQ("foo", parser_.out_.AsString());
-  ASSERT_EQ(1u, parser_.ins_.size());
-  EXPECT_EQ("x", parser_.ins_[0].AsString());
-}
-
-TEST_F(DepfileParserTest, UnifyMultipleRulesLF) {
-  string err;
-  EXPECT_TRUE(Parse("foo: x\n"
-                    "foo: y\n"
-                    "foo \\\n"
-                    "foo: z\n", &err));
-  ASSERT_EQ("foo", parser_.out_.AsString());
-  ASSERT_EQ(3u, parser_.ins_.size());
-  EXPECT_EQ("x", parser_.ins_[0].AsString());
-  EXPECT_EQ("y", parser_.ins_[1].AsString());
-  EXPECT_EQ("z", parser_.ins_[2].AsString());
-}
-
-TEST_F(DepfileParserTest, UnifyMultipleRulesCRLF) {
-  string err;
-  EXPECT_TRUE(Parse("foo: x\r\n"
-                    "foo: y\r\n"
-                    "foo \\\r\n"
-                    "foo: z\r\n", &err));
-  ASSERT_EQ("foo", parser_.out_.AsString());
-  ASSERT_EQ(3u, parser_.ins_.size());
-  EXPECT_EQ("x", parser_.ins_[0].AsString());
-  EXPECT_EQ("y", parser_.ins_[1].AsString());
-  EXPECT_EQ("z", parser_.ins_[2].AsString());
-}
-
-TEST_F(DepfileParserTest, UnifyMixedRulesLF) {
-  string err;
-  EXPECT_TRUE(Parse("foo: x\\\n"
-                    "     y\n"
-                    "foo \\\n"
-                    "foo: z\n", &err));
-  ASSERT_EQ("foo", parser_.out_.AsString());
-  ASSERT_EQ(3u, parser_.ins_.size());
-  EXPECT_EQ("x", parser_.ins_[0].AsString());
-  EXPECT_EQ("y", parser_.ins_[1].AsString());
-  EXPECT_EQ("z", parser_.ins_[2].AsString());
-}
-
-TEST_F(DepfileParserTest, UnifyMixedRulesCRLF) {
-  string err;
-  EXPECT_TRUE(Parse("foo: x\\\r\n"
-                    "     y\r\n"
-                    "foo \\\r\n"
-                    "foo: z\r\n", &err));
-  ASSERT_EQ("foo", parser_.out_.AsString());
-  ASSERT_EQ(3u, parser_.ins_.size());
-  EXPECT_EQ("x", parser_.ins_[0].AsString());
-  EXPECT_EQ("y", parser_.ins_[1].AsString());
-  EXPECT_EQ("z", parser_.ins_[2].AsString());
-}
-
-TEST_F(DepfileParserTest, IndentedRulesLF) {
-  string err;
-  EXPECT_TRUE(Parse(" foo: x\n"
-                    " foo: y\n"
-                    " foo: z\n", &err));
-  ASSERT_EQ("foo", parser_.out_.AsString());
-  ASSERT_EQ(3u, parser_.ins_.size());
-  EXPECT_EQ("x", parser_.ins_[0].AsString());
-  EXPECT_EQ("y", parser_.ins_[1].AsString());
-  EXPECT_EQ("z", parser_.ins_[2].AsString());
-}
-
-TEST_F(DepfileParserTest, IndentedRulesCRLF) {
-  string err;
-  EXPECT_TRUE(Parse(" foo: x\r\n"
-                    " foo: y\r\n"
-                    " foo: z\r\n", &err));
-  ASSERT_EQ("foo", parser_.out_.AsString());
-  ASSERT_EQ(3u, parser_.ins_.size());
-  EXPECT_EQ("x", parser_.ins_[0].AsString());
-  EXPECT_EQ("y", parser_.ins_[1].AsString());
-  EXPECT_EQ("z", parser_.ins_[2].AsString());
-}
-
-TEST_F(DepfileParserTest, TolerateMP) {
-  string err;
-  EXPECT_TRUE(Parse("foo: x y z\n"
-                    "x:\n"
-                    "y:\n"
-                    "z:\n", &err));
-  ASSERT_EQ("foo", parser_.out_.AsString());
-  ASSERT_EQ(3u, parser_.ins_.size());
-  EXPECT_EQ("x", parser_.ins_[0].AsString());
-  EXPECT_EQ("y", parser_.ins_[1].AsString());
-  EXPECT_EQ("z", parser_.ins_[2].AsString());
-}
-
-TEST_F(DepfileParserTest, MultipleRulesTolerateMP) {
-  string err;
-  EXPECT_TRUE(Parse("foo: x\n"
-                    "x:\n"
-                    "foo: y\n"
-                    "y:\n"
-                    "foo: z\n"
-                    "z:\n", &err));
-  ASSERT_EQ("foo", parser_.out_.AsString());
-  ASSERT_EQ(3u, parser_.ins_.size());
-  EXPECT_EQ("x", parser_.ins_[0].AsString());
-  EXPECT_EQ("y", parser_.ins_[1].AsString());
-  EXPECT_EQ("z", parser_.ins_[2].AsString());
-}
-
-TEST_F(DepfileParserTest, MultipleRulesRejectDifferentOutputs) {
-  // check that multiple different outputs are rejected by the parser
-  // when spread across multiple rules
-  DepfileParserOptions parser_opts;
-  parser_opts.depfile_distinct_target_lines_action_ =
-      kDepfileDistinctTargetLinesActionError;
-  DepfileParser parser(parser_opts);
-  string err;
-  string input =
-      "foo: x y\n"
-      "bar: y z\n";
-  EXPECT_FALSE(parser.Parse(&input, &err));
-  ASSERT_EQ("depfile has multiple output paths (on separate lines)"
-            " [-w depfilemulti=err]", err);
-}
diff -Naur ninja-1.9.0.orig/src/deps_log.cc ninja/src/deps_log.cc
--- ninja-1.9.0.orig/src/deps_log.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/deps_log.cc	2019-09-24 19:51:29.614802538 +0000
@@ -20,9 +20,6 @@
 #include <string.h>
 #ifndef _WIN32
 #include <unistd.h>
-#elif defined(_MSC_VER) && (_MSC_VER < 1900)
-typedef __int32 int32_t;
-typedef unsigned __int32 uint32_t;
 #endif
 
 #include "graph.h"
@@ -33,7 +30,7 @@
 // The version is stored as 4 bytes after the signature and also serves as a
 // byte order mark. Signature and version combined are 16 bytes long.
 const char kFileSignature[] = "# ninjadeps\n";
-const int kCurrentVersion = 4;
+const int kCurrentVersion = 3;
 
 // Record size is currently limited to less than the full 32 bit, due to
 // internal buffers having to have this size.
@@ -127,7 +124,7 @@
     return true;
 
   // Update on-disk representation.
-  unsigned size = 4 * (1 + 2 + node_count);
+  unsigned size = 4 * (1 + 1 + node_count);
   if (size > kMaxRecordSize) {
     errno = ERANGE;
     return false;
@@ -138,11 +135,8 @@
   int id = node->id();
   if (fwrite(&id, 4, 1, file_) < 1)
     return false;
-  uint32_t mtime_part = static_cast<uint32_t>(mtime & 0xffffffff);
-  if (fwrite(&mtime_part, 4, 1, file_) < 1)
-    return false;
-  mtime_part = static_cast<uint32_t>((mtime >> 32) & 0xffffffff);
-  if (fwrite(&mtime_part, 4, 1, file_) < 1)
+  int timestamp = mtime;
+  if (fwrite(&timestamp, 4, 1, file_) < 1)
     return false;
   for (int i = 0; i < node_count; ++i) {
     id = nodes[i]->id();
@@ -215,7 +209,7 @@
     bool is_deps = (size >> 31) != 0;
     size = size & 0x7FFFFFFF;
 
-    if (size > kMaxRecordSize || fread(buf, size, 1, f) < 1) {
+    if (fread(buf, size, 1, f) < 1 || size > kMaxRecordSize) {
       read_failed = true;
       break;
     }
@@ -224,11 +218,9 @@
       assert(size % 4 == 0);
       int* deps_data = reinterpret_cast<int*>(buf);
       int out_id = deps_data[0];
-      TimeStamp mtime;
-      mtime = (TimeStamp)(((uint64_t)(unsigned int)deps_data[2] << 32) |
-                          (uint64_t)(unsigned int)deps_data[1]);
-      deps_data += 3;
-      int deps_count = (size / 4) - 3;
+      int mtime = deps_data[1];
+      deps_data += 2;
+      int deps_count = (size / 4) - 2;
 
       Deps* deps = new Deps(mtime, deps_count);
       for (int i = 0; i < deps_count; ++i) {
diff -Naur ninja-1.9.0.orig/src/deps_log.h ninja/src/deps_log.h
--- ninja-1.9.0.orig/src/deps_log.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/deps_log.h	2019-09-24 19:51:29.615985738 +0000
@@ -57,9 +57,7 @@
 ///      one's complement of the expected index of the record (to detect
 ///      concurrent writes of multiple ninja processes to the log).
 ///    dependency records are an array of 4-byte integers
-///      [output path id,
-///       output path mtime (lower 4 bytes), output path mtime (upper 4 bytes),
-///       input path id, input path id...]
+///      [output path id, output path mtime, input path id, input path id...]
 ///      (The mtime is compared against the on-disk output path mtime
 ///      to verify the stored data is up-to-date.)
 /// If two records reference the same output the latter one in the file
@@ -77,10 +75,10 @@
 
   // Reading (startup-time) interface.
   struct Deps {
-    Deps(int64_t mtime, int node_count)
+    Deps(int mtime, int node_count)
         : mtime(mtime), node_count(node_count), nodes(new Node*[node_count]) {}
     ~Deps() { delete [] nodes; }
-    TimeStamp mtime;
+    int mtime;
     int node_count;
     Node** nodes;
   };
diff -Naur ninja-1.9.0.orig/src/deps_log_test.cc ninja/src/deps_log_test.cc
--- ninja-1.9.0.orig/src/deps_log_test.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/deps_log_test.cc	2019-09-24 19:51:29.617566538 +0000
@@ -143,7 +143,7 @@
     ASSERT_GT(file_size, 0);
   }
 
-  // Now reload the file, and read the same deps.
+  // Now reload the file, and readd the same deps.
   {
     State state;
     DepsLog log;
@@ -203,7 +203,7 @@
     ASSERT_GT(file_size, 0);
   }
 
-  // Now reload the file, and add slightly different deps.
+  // Now reload the file, and add slighly different deps.
   int file_size_2;
   {
     State state;
@@ -431,12 +431,10 @@
   }
 
   // Shorten the file, corrupting the last record.
-  {
-    struct stat st;
-    ASSERT_EQ(0, stat(kTestFilename, &st));
-    string err;
-    ASSERT_TRUE(Truncate(kTestFilename, st.st_size - 2, &err));
-  }
+  struct stat st;
+  ASSERT_EQ(0, stat(kTestFilename, &st));
+  string err;
+  ASSERT_TRUE(Truncate(kTestFilename, st.st_size - 2, &err));
 
   // Load the file again, add an entry.
   {
diff -Naur ninja-1.9.0.orig/src/disk_interface.cc ninja/src/disk_interface.cc
--- ninja-1.9.0.orig/src/disk_interface.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/disk_interface.cc	2019-09-24 19:51:29.618581738 +0000
@@ -28,22 +28,20 @@
 #include <direct.h>  // _mkdir
 #endif
 
-#include "metrics.h"
 #include "util.h"
 
 namespace {
 
 string DirName(const string& path) {
 #ifdef _WIN32
-  static const char kPathSeparators[] = "\\/";
+  const char kPathSeparators[] = "\\/";
 #else
-  static const char kPathSeparators[] = "/";
+  const char kPathSeparators[] = "/";
 #endif
-  static const char* const kEnd = kPathSeparators + sizeof(kPathSeparators) - 1;
-
   string::size_type slash_pos = path.find_last_of(kPathSeparators);
   if (slash_pos == string::npos)
     return string();  // Nothing to do.
+  const char* const kEnd = kPathSeparators + strlen(kPathSeparators);
   while (slash_pos > 0 &&
          std::find(kPathSeparators, kEnd, path[slash_pos - 1]) != kEnd)
     --slash_pos;
@@ -62,16 +60,17 @@
 TimeStamp TimeStampFromFileTime(const FILETIME& filetime) {
   // FILETIME is in 100-nanosecond increments since the Windows epoch.
   // We don't much care about epoch correctness but we do want the
-  // resulting value to fit in a 64-bit integer.
+  // resulting value to fit in an integer.
   uint64_t mtime = ((uint64_t)filetime.dwHighDateTime << 32) |
     ((uint64_t)filetime.dwLowDateTime);
-  // 1600 epoch -> 2000 epoch (subtract 400 years).
-  return (TimeStamp)mtime - 12622770400LL * (1000000000LL / 100);
+  mtime /= 1000000000LL / 100; // 100ns -> s.
+  mtime -= 12622770400LL;  // 1600 epoch -> 2000 epoch (subtract 400 years).
+  return (TimeStamp)mtime;
 }
 
 TimeStamp StatSingleFile(const string& path, string* err) {
   WIN32_FILE_ATTRIBUTE_DATA attrs;
-  if (!GetFileAttributesExA(path.c_str(), GetFileExInfoStandard, &attrs)) {
+  if (!GetFileAttributesEx(path.c_str(), GetFileExInfoStandard, &attrs)) {
     DWORD win_err = GetLastError();
     if (win_err == ERROR_FILE_NOT_FOUND || win_err == ERROR_PATH_NOT_FOUND)
       return 0;
@@ -81,15 +80,20 @@
   return TimeStampFromFileTime(attrs.ftLastWriteTime);
 }
 
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable: 4996)  // GetVersionExA is deprecated post SDK 8.1.
+#endif
 bool IsWindows7OrLater() {
-  OSVERSIONINFOEX version_info =
-      { sizeof(OSVERSIONINFOEX), 6, 1, 0, 0, {0}, 0, 0, 0, 0, 0};
-  DWORDLONG comparison = 0;
-  VER_SET_CONDITION(comparison, VER_MAJORVERSION, VER_GREATER_EQUAL);
-  VER_SET_CONDITION(comparison, VER_MINORVERSION, VER_GREATER_EQUAL);
-  return VerifyVersionInfo(
-      &version_info, VER_MAJORVERSION | VER_MINORVERSION, comparison);
+  OSVERSIONINFO version_info = { sizeof(version_info) };
+  if (!GetVersionEx(&version_info))
+    Fatal("GetVersionEx: %s", GetLastErrorString().c_str());
+  return version_info.dwMajorVersion > 6 ||
+         (version_info.dwMajorVersion == 6 && version_info.dwMinorVersion >= 1);
 }
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif
 
 bool StatAllFilesInDir(const string& dir, map<string, TimeStamp>* stamps,
                        string* err) {
@@ -113,11 +117,6 @@
   }
   do {
     string lowername = ffd.cFileName;
-    if (lowername == "..") {
-      // Seems to just copy the timestamp for ".." from ".", which is wrong.
-      // This is the case at least on NTFS under Windows 7.
-      continue;
-    }
     transform(lowername.begin(), lowername.end(), lowername.begin(), ::tolower);
     stamps->insert(make_pair(lowername,
                              TimeStampFromFileTime(ffd.ftLastWriteTime)));
@@ -154,7 +153,6 @@
 // RealDiskInterface -----------------------------------------------------------
 
 TimeStamp RealDiskInterface::Stat(const string& path, string* err) const {
-  METRIC_RECORD("node stat");
 #ifdef _WIN32
   // MSDN: "Naming Files, Paths, and Namespaces"
   // http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx
@@ -170,11 +168,6 @@
 
   string dir = DirName(path);
   string base(path.substr(dir.size() ? dir.size() + 1 : 0));
-  if (base == "..") {
-    // StatAllFilesInDir does not report any information for base = "..".
-    base = ".";
-    dir = path;
-  }
 
   transform(dir.begin(), dir.end(), dir.begin(), ::tolower);
   transform(base.begin(), base.end(), base.begin(), ::tolower);
@@ -197,27 +190,7 @@
     *err = "stat(" + path + "): " + strerror(errno);
     return -1;
   }
-  // Some users (Flatpak) set mtime to 0, this should be harmless
-  // and avoids conflicting with our return value of 0 meaning
-  // that it doesn't exist.
-  if (st.st_mtime == 0)
-    return 1;
-#if defined(__APPLE__) && !defined(_POSIX_C_SOURCE)
-  return ((int64_t)st.st_mtimespec.tv_sec * 1000000000LL +
-          st.st_mtimespec.tv_nsec);
-#elif (_POSIX_C_SOURCE >= 200809L || _XOPEN_SOURCE >= 700 || defined(_BSD_SOURCE) || defined(_SVID_SOURCE) || \
-       defined(__BIONIC__) || (defined (__SVR4) && defined (__sun)) || defined(__FreeBSD__))
-  // For glibc, see "Timestamp files" in the Notes of http://www.kernel.org/doc/man-pages/online/pages/man2/stat.2.html
-  // newlib, uClibc and musl follow the kernel (or Cygwin) headers and define the right macro values above.
-  // For bsd, see https://github.com/freebsd/freebsd/blob/master/sys/sys/stat.h and similar
-  // For bionic, C and POSIX API is always enabled.
-  // For solaris, see https://docs.oracle.com/cd/E88353_01/html/E37841/stat-2.html.
-  return (int64_t)st.st_mtim.tv_sec * 1000000000LL + st.st_mtim.tv_nsec;
-#elif defined(_AIX)
-  return (int64_t)st.st_mtime * 1000000000LL + st.st_mtime_n;
-#else
-  return (int64_t)st.st_mtime * 1000000000LL + st.st_mtimensec;
-#endif
+  return st.st_mtime;
 #endif
 }
 
@@ -256,14 +229,14 @@
   return true;
 }
 
-FileReader::Status RealDiskInterface::ReadFile(const string& path,
-                                               string* contents,
-                                               string* err) {
-  switch (::ReadFile(path, contents, err)) {
-  case 0:       return Okay;
-  case -ENOENT: return NotFound;
-  default:      return OtherError;
+string RealDiskInterface::ReadFile(const string& path, string* err) {
+  string contents;
+  int ret = ::ReadFile(path, &contents, err);
+  if (ret == -ENOENT) {
+    // Swallow ENOENT.
+    err->clear();
   }
+  return contents;
 }
 
 int RealDiskInterface::RemoveFile(const string& path) {
diff -Naur ninja-1.9.0.orig/src/disk_interface.h ninja/src/disk_interface.h
--- ninja-1.9.0.orig/src/disk_interface.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/disk_interface.h	2019-09-24 19:51:29.619540938 +0000
@@ -21,29 +21,13 @@
 
 #include "timestamp.h"
 
-/// Interface for reading files from disk.  See DiskInterface for details.
-/// This base offers the minimum interface needed just to read files.
-struct FileReader {
-  virtual ~FileReader() {}
-
-  /// Result of ReadFile.
-  enum Status {
-    Okay,
-    NotFound,
-    OtherError
-  };
-
-  /// Read and store in given string.  On success, return Okay.
-  /// On error, return another Status and fill |err|.
-  virtual Status ReadFile(const string& path, string* contents,
-                          string* err) = 0;
-};
-
 /// Interface for accessing the disk.
 ///
 /// Abstract so it can be mocked out for tests.  The real implementation
 /// is RealDiskInterface.
-struct DiskInterface: public FileReader {
+struct DiskInterface {
+  virtual ~DiskInterface() {}
+
   /// stat() a file, returning the mtime, or 0 if missing and -1 on
   /// other errors.
   virtual TimeStamp Stat(const string& path, string* err) const = 0;
@@ -55,6 +39,9 @@
   /// Returns true on success, false on failure
   virtual bool WriteFile(const string& path, const string& contents) = 0;
 
+  /// Read a file to a string.  Fill in |err| on error.
+  virtual string ReadFile(const string& path, string* err) = 0;
+
   /// Remove the file named @a path. It behaves like 'rm -f path' so no errors
   /// are reported if it does not exists.
   /// @returns 0 if the file has been removed,
@@ -78,7 +65,7 @@
   virtual TimeStamp Stat(const string& path, string* err) const;
   virtual bool MakeDir(const string& path);
   virtual bool WriteFile(const string& path, const string& contents);
-  virtual Status ReadFile(const string& path, string* contents, string* err);
+  virtual string ReadFile(const string& path, string* err);
   virtual int RemoveFile(const string& path);
 
   /// Whether stat information can be cached.  Only has an effect on Windows.
diff -Naur ninja-1.9.0.orig/src/disk_interface_test.cc ninja/src/disk_interface_test.cc
--- ninja-1.9.0.orig/src/disk_interface_test.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/disk_interface_test.cc	2019-09-24 19:51:29.620960138 +0000
@@ -87,8 +87,6 @@
   string err;
   ASSERT_TRUE(disk_.MakeDir("subdir"));
   ASSERT_TRUE(disk_.MakeDir("subdir/subsubdir"));
-  EXPECT_GT(disk_.Stat("..", &err), 1);
-  EXPECT_EQ("", err);
   EXPECT_GT(disk_.Stat(".", &err), 1);
   EXPECT_EQ("", err);
   EXPECT_GT(disk_.Stat("subdir", &err), 1);
@@ -107,6 +105,7 @@
 #ifdef _WIN32
 TEST_F(DiskInterfaceTest, StatCache) {
   string err;
+  disk_.AllowStatCache(true);
 
   ASSERT_TRUE(Touch("file1"));
   ASSERT_TRUE(Touch("fiLE2"));
@@ -116,10 +115,6 @@
   ASSERT_TRUE(Touch("subdir\\SUBFILE2"));
   ASSERT_TRUE(Touch("subdir\\SUBFILE3"));
 
-  disk_.AllowStatCache(false);
-  TimeStamp parent_stat_uncached = disk_.Stat("..", &err);
-  disk_.AllowStatCache(true);
-
   EXPECT_GT(disk_.Stat("FIle1", &err), 1);
   EXPECT_EQ("", err);
   EXPECT_GT(disk_.Stat("file1", &err), 1);
@@ -130,8 +125,6 @@
   EXPECT_GT(disk_.Stat("sUbdir\\suBFile1", &err), 1);
   EXPECT_EQ("", err);
 
-  EXPECT_GT(disk_.Stat("..", &err), 1);
-  EXPECT_EQ("", err);
   EXPECT_GT(disk_.Stat(".", &err), 1);
   EXPECT_EQ("", err);
   EXPECT_GT(disk_.Stat("subdir", &err), 1);
@@ -139,15 +132,11 @@
   EXPECT_GT(disk_.Stat("subdir/subsubdir", &err), 1);
   EXPECT_EQ("", err);
 
-#ifndef _MSC_VER // TODO: Investigate why. Also see https://github.com/ninja-build/ninja/pull/1423
   EXPECT_EQ(disk_.Stat("subdir", &err),
             disk_.Stat("subdir/.", &err));
   EXPECT_EQ("", err);
   EXPECT_EQ(disk_.Stat("subdir", &err),
             disk_.Stat("subdir/subsubdir/..", &err));
-#endif
-  EXPECT_EQ("", err);
-  EXPECT_EQ(disk_.Stat("..", &err), parent_stat_uncached);
   EXPECT_EQ("", err);
   EXPECT_EQ(disk_.Stat("subdir/subsubdir", &err),
             disk_.Stat("subdir/subsubdir/.", &err));
@@ -168,12 +157,8 @@
 
 TEST_F(DiskInterfaceTest, ReadFile) {
   string err;
-  std::string content;
-  ASSERT_EQ(DiskInterface::NotFound,
-            disk_.ReadFile("foobar", &content, &err));
-  EXPECT_EQ("", content);
-  EXPECT_NE("", err); // actual value is platform-specific
-  err.clear();
+  EXPECT_EQ("", disk_.ReadFile("foobar", &err));
+  EXPECT_EQ("", err);
 
   const char* kTestFile = "testfile";
   FILE* f = fopen(kTestFile, "wb");
@@ -182,9 +167,7 @@
   fprintf(f, "%s", kTestContent);
   ASSERT_EQ(0, fclose(f));
 
-  ASSERT_EQ(DiskInterface::Okay,
-            disk_.ReadFile(kTestFile, &content, &err));
-  EXPECT_EQ(kTestContent, content);
+  EXPECT_EQ(kTestContent, disk_.ReadFile(kTestFile, &err));
   EXPECT_EQ("", err);
 }
 
@@ -213,7 +196,7 @@
 
 struct StatTest : public StateTestWithBuiltinRules,
                   public DiskInterface {
-  StatTest() : scan_(&state_, NULL, NULL, this, NULL) {}
+  StatTest() : scan_(&state_, NULL, NULL, this) {}
 
   // DiskInterface implementation.
   virtual TimeStamp Stat(const string& path, string* err) const;
@@ -225,9 +208,9 @@
     assert(false);
     return false;
   }
-  virtual Status ReadFile(const string& path, string* contents, string* err) {
+  virtual string ReadFile(const string& path, string* err) {
     assert(false);
-    return NotFound;
+    return "";
   }
   virtual int RemoveFile(const string& path) {
     assert(false);
@@ -256,7 +239,7 @@
   EXPECT_TRUE(out->Stat(this, &err));
   EXPECT_EQ("", err);
   ASSERT_EQ(1u, stats_.size());
-  scan_.RecomputeDirty(out, NULL);
+  scan_.RecomputeDirty(out->in_edge(), NULL);
   ASSERT_EQ(2u, stats_.size());
   ASSERT_EQ("out", stats_[0]);
   ASSERT_EQ("in",  stats_[1]);
@@ -272,7 +255,7 @@
   EXPECT_TRUE(out->Stat(this, &err));
   EXPECT_EQ("", err);
   ASSERT_EQ(1u, stats_.size());
-  scan_.RecomputeDirty(out, NULL);
+  scan_.RecomputeDirty(out->in_edge(), NULL);
   ASSERT_EQ(3u, stats_.size());
   ASSERT_EQ("out", stats_[0]);
   ASSERT_TRUE(GetNode("out")->dirty());
@@ -292,7 +275,7 @@
   EXPECT_TRUE(out->Stat(this, &err));
   EXPECT_EQ("", err);
   ASSERT_EQ(1u, stats_.size());
-  scan_.RecomputeDirty(out, NULL);
+  scan_.RecomputeDirty(out->in_edge(), NULL);
   ASSERT_EQ(1u + 6u, stats_.size());
   ASSERT_EQ("mid1", stats_[1]);
   ASSERT_TRUE(GetNode("mid1")->dirty());
@@ -313,7 +296,7 @@
   EXPECT_TRUE(out->Stat(this, &err));
   EXPECT_EQ("", err);
   ASSERT_EQ(1u, stats_.size());
-  scan_.RecomputeDirty(out, NULL);
+  scan_.RecomputeDirty(out->in_edge(), NULL);
   ASSERT_FALSE(GetNode("in")->dirty());
   ASSERT_TRUE(GetNode("mid")->dirty());
   ASSERT_TRUE(GetNode("out")->dirty());
diff -Naur ninja-1.9.0.orig/src/edit_distance.cc ninja/src/edit_distance.cc
--- ninja-1.9.0.orig/src/edit_distance.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/edit_distance.cc	2019-09-24 19:51:29.621629738 +0000
@@ -28,42 +28,40 @@
   //   http://en.wikipedia.org/wiki/Levenshtein_distance
   //
   // Although the algorithm is typically described using an m x n
-  // array, only one row plus one element are used at a time, so this
-  // implementation just keeps one vector for the row.  To update one entry,
-  // only the entries to the left, top, and top-left are needed.  The left
-  // entry is in row[x-1], the top entry is what's in row[x] from the last
-  // iteration, and the top-left entry is stored in previous.
+  // array, only two rows are used at a time, so this implementation
+  // just keeps two separate vectors for those two rows.
   int m = s1.len_;
   int n = s2.len_;
 
-  vector<int> row(n + 1);
-  for (int i = 1; i <= n; ++i)
-    row[i] = i;
+  vector<int> previous(n + 1);
+  vector<int> current(n + 1);
+
+  for (int i = 0; i <= n; ++i)
+    previous[i] = i;
 
   for (int y = 1; y <= m; ++y) {
-    row[0] = y;
-    int best_this_row = row[0];
+    current[0] = y;
+    int best_this_row = current[0];
 
-    int previous = y - 1;
     for (int x = 1; x <= n; ++x) {
-      int old_row = row[x];
       if (allow_replacements) {
-        row[x] = min(previous + (s1.str_[y - 1] == s2.str_[x - 1] ? 0 : 1),
-                     min(row[x - 1], row[x]) + 1);
+        current[x] = min(previous[x-1] + (s1.str_[y-1] == s2.str_[x-1] ? 0 : 1),
+                         min(current[x-1], previous[x])+1);
       }
       else {
-        if (s1.str_[y - 1] == s2.str_[x - 1])
-          row[x] = previous;
+        if (s1.str_[y-1] == s2.str_[x-1])
+          current[x] = previous[x-1];
         else
-          row[x] = min(row[x - 1], row[x]) + 1;
+          current[x] = min(current[x-1], previous[x]) + 1;
       }
-      previous = old_row;
-      best_this_row = min(best_this_row, row[x]);
+      best_this_row = min(best_this_row, current[x]);
     }
 
     if (max_edit_distance && best_this_row > max_edit_distance)
       return max_edit_distance + 1;
+
+    current.swap(previous);
   }
 
-  return row[n];
+  return previous[n];
 }
diff -Naur ninja-1.9.0.orig/src/eval_env.cc ninja/src/eval_env.cc
--- ninja-1.9.0.orig/src/eval_env.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/eval_env.cc	2019-09-24 19:51:29.622364138 +0000
@@ -55,7 +55,7 @@
 }
 
 const EvalString* Rule::GetBinding(const string& key) const {
-  Bindings::const_iterator i = bindings_.find(key);
+  map<string, EvalString>::const_iterator i = bindings_.find(key);
   if (i == bindings_.end())
     return NULL;
   return &i->second;
@@ -71,8 +71,7 @@
       var == "pool" ||
       var == "restat" ||
       var == "rspfile" ||
-      var == "rspfile_content" ||
-      var == "msvc_deps_prefix";
+      var == "rspfile_content";
 }
 
 const map<string, const Rule*>& BindingEnv::GetRules() const {
diff -Naur ninja-1.9.0.orig/src/eval_env.h ninja/src/eval_env.h
--- ninja-1.9.0.orig/src/eval_env.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/eval_env.h	2019-09-24 19:51:29.623108938 +0000
@@ -57,6 +57,7 @@
 
   const string& name() const { return name_; }
 
+  typedef map<string, EvalString> Bindings;
   void AddBinding(const string& key, const EvalString& val);
 
   static bool IsReservedBinding(const string& var);
@@ -68,8 +69,7 @@
   friend struct ManifestParser;
 
   string name_;
-  typedef map<string, EvalString> Bindings;
-  Bindings bindings_;
+  map<string, EvalString> bindings_;
 };
 
 /// An Env which contains a mapping of variables to values
diff -Naur ninja-1.9.0.orig/src/getopt.c ninja/src/getopt.c
--- ninja-1.9.0.orig/src/getopt.c	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/getopt.c	2019-09-24 19:51:29.624612938 +0000
@@ -385,13 +385,11 @@
     return optopt;
 }
 
-#ifndef _AIX
 int
 getopt (int argc, char **argv, char *optstring)
 {
   return getopt_internal (argc, argv, optstring, NULL, NULL, 0);
 }
-#endif
 
 int
 getopt_long (int argc, char **argv, const char *shortopts,
diff -Naur ninja-1.9.0.orig/src/getopt.h ninja/src/getopt.h
--- ninja-1.9.0.orig/src/getopt.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/getopt.h	2019-09-24 19:51:29.625254538 +0000
@@ -39,9 +39,7 @@
   extern int optopt;
 
   /* function prototypes */
-#ifndef _AIX
   int getopt (int argc, char **argv, char *optstring);
-#endif
   int getopt_long (int argc, char **argv, const char *shortopts,
                    const GETOPT_LONG_OPTION_T * longopts, int *longind);
   int getopt_long_only (int argc, char **argv, const char *shortopts,
diff -Naur ninja-1.9.0.orig/src/graph.cc ninja/src/graph.cc
--- ninja-1.9.0.orig/src/graph.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/graph.cc	2019-09-24 19:51:29.628233738 +0000
@@ -28,47 +28,23 @@
 #include "util.h"
 
 bool Node::Stat(DiskInterface* disk_interface, string* err) {
+  METRIC_RECORD("node stat");
   return (mtime_ = disk_interface->Stat(path_, err)) != -1;
 }
 
-bool DependencyScan::RecomputeDirty(Node* node, string* err) {
-  vector<Node*> stack;
-  return RecomputeDirty(node, &stack, err);
-}
-
-bool DependencyScan::RecomputeDirty(Node* node, vector<Node*>* stack,
-                                    string* err) {
-  Edge* edge = node->in_edge();
-  if (!edge) {
-    // If we already visited this leaf node then we are done.
-    if (node->status_known())
-      return true;
-    // This node has no in-edge; it is dirty if it is missing.
-    if (!node->StatIfNecessary(disk_interface_, err))
-      return false;
-    if (!node->exists())
-      EXPLAIN("%s has no in-edge and is missing", node->path().c_str());
-    node->set_dirty(!node->exists());
-    return true;
-  }
-
-  // If we already finished this edge then we are done.
-  if (edge->mark_ == Edge::VisitDone)
-    return true;
-
-  // If we encountered this edge earlier in the call stack we have a cycle.
-  if (!VerifyDAG(node, stack, err))
-    return false;
-
-  // Mark the edge temporarily while in the call stack.
-  edge->mark_ = Edge::VisitInStack;
-  stack->push_back(node);
-
+bool DependencyScan::RecomputeDirty(Edge* edge, string* err) {
   bool dirty = false;
   edge->outputs_ready_ = true;
   edge->deps_missing_ = false;
 
-  // Load output mtimes so we can compare them to the most recent input below.
+  // RecomputeDirty() recursively walks the graph following the input nodes
+  // of |edge| and the in_edges of these nodes.  It uses the stat state of each
+  // node to mark nodes as visited and doesn't traverse across nodes that have
+  // been visited already.  To make sure that every edge is visited only once
+  // (important because an edge's deps are loaded every time it's visited), mark
+  // all outputs of |edge| visited as a first step.  This ensures that edges
+  // with multiple inputs and outputs are visited only once, even in cyclic
+  // graphs.
   for (vector<Node*>::iterator o = edge->outputs_.begin();
        o != edge->outputs_.end(); ++o) {
     if (!(*o)->StatIfNecessary(disk_interface_, err))
@@ -87,9 +63,19 @@
   Node* most_recent_input = NULL;
   for (vector<Node*>::iterator i = edge->inputs_.begin();
        i != edge->inputs_.end(); ++i) {
-    // Visit this input.
-    if (!RecomputeDirty(*i, stack, err))
-      return false;
+    if (!(*i)->status_known()) {
+      if (!(*i)->StatIfNecessary(disk_interface_, err))
+        return false;
+      if (Edge* in_edge = (*i)->in_edge()) {
+        if (!RecomputeDirty(in_edge, err))
+          return false;
+      } else {
+        // This input has no in-edge; it is dirty if it is missing.
+        if (!(*i)->exists())
+          EXPLAIN("%s has no in-edge and is missing", (*i)->path().c_str());
+        (*i)->set_dirty(!(*i)->exists());
+      }
+    }
 
     // If an input is not ready, neither are our outputs.
     if (Edge* in_edge = (*i)->in_edge()) {
@@ -132,59 +118,16 @@
   if (dirty && !(edge->is_phony() && edge->inputs_.empty()))
     edge->outputs_ready_ = false;
 
-  // Mark the edge as finished during this walk now that it will no longer
-  // be in the call stack.
-  edge->mark_ = Edge::VisitDone;
-  assert(stack->back() == node);
-  stack->pop_back();
-
   return true;
 }
 
-bool DependencyScan::VerifyDAG(Node* node, vector<Node*>* stack, string* err) {
-  Edge* edge = node->in_edge();
-  assert(edge != NULL);
-
-  // If we have no temporary mark on the edge then we do not yet have a cycle.
-  if (edge->mark_ != Edge::VisitInStack)
-    return true;
-
-  // We have this edge earlier in the call stack.  Find it.
-  vector<Node*>::iterator start = stack->begin();
-  while (start != stack->end() && (*start)->in_edge() != edge)
-    ++start;
-  assert(start != stack->end());
-
-  // Make the cycle clear by reporting its start as the node at its end
-  // instead of some other output of the starting edge.  For example,
-  // running 'ninja b' on
-  //   build a b: cat c
-  //   build c: cat a
-  // should report a -> c -> a instead of b -> c -> a.
-  *start = node;
-
-  // Construct the error message rejecting the cycle.
-  *err = "dependency cycle: ";
-  for (vector<Node*>::const_iterator i = start; i != stack->end(); ++i) {
-    err->append((*i)->path());
-    err->append(" -> ");
-  }
-  err->append((*start)->path());
-
-  if ((start + 1) == stack->end() && edge->maybe_phonycycle_diagnostic()) {
-    // The manifest parser would have filtered out the self-referencing
-    // input if it were not configured to allow the error.
-    err->append(" [-w phonycycle=err]");
-  }
-
-  return false;
-}
-
 bool DependencyScan::RecomputeOutputsDirty(Edge* edge, Node* most_recent_input,
                                            bool* outputs_dirty, string* err) {
   string command = edge->EvaluateCommand(/*incl_rsp_file=*/true);
   for (vector<Node*>::iterator o = edge->outputs_.begin();
        o != edge->outputs_.end(); ++o) {
+    if (!(*o)->StatIfNecessary(disk_interface_, err))
+      return false;
     if (RecomputeOutputDirty(edge, most_recent_input, command, *o)) {
       *outputs_dirty = true;
       return true;
@@ -227,13 +170,13 @@
     bool used_restat = false;
     if (edge->GetBindingBool("restat") && build_log() &&
         (entry = build_log()->LookupByOutput(output->path()))) {
-      output_mtime = entry->mtime;
+      output_mtime = entry->restat_mtime;
       used_restat = true;
     }
 
     if (output_mtime < most_recent_input->mtime()) {
       EXPLAIN("%soutput %s older than most recent input %s "
-              "(%" PRId64 " vs %" PRId64 ")",
+              "(%d vs %d)",
               used_restat ? "restat of " : "", output->path().c_str(),
               most_recent_input->path().c_str(),
               output_mtime, most_recent_input->mtime());
@@ -241,29 +184,17 @@
     }
   }
 
-  if (build_log()) {
-    bool generator = edge->GetBindingBool("generator");
+  // May also be dirty due to the command changing since the last build.
+  // But if this is a generator rule, the command changing does not make us
+  // dirty.
+  if (!edge->GetBindingBool("generator") && build_log()) {
     if (entry || (entry = build_log()->LookupByOutput(output->path()))) {
-      if (!generator &&
-          BuildLog::LogEntry::HashCommand(command) != entry->command_hash) {
-        // May also be dirty due to the command changing since the last build.
-        // But if this is a generator rule, the command changing does not make us
-        // dirty.
+      if (BuildLog::LogEntry::HashCommand(command) != entry->command_hash) {
         EXPLAIN("command line changed for %s", output->path().c_str());
         return true;
       }
-      if (most_recent_input && entry->mtime < most_recent_input->mtime()) {
-        // May also be dirty due to the mtime in the log being older than the
-        // mtime of the most recent input.  This can occur even when the mtime
-        // on disk is newer if a previous run wrote to the output file but
-        // exited with an error or was interrupted.
-        EXPLAIN("recorded mtime of %s older than most recent input %s (%" PRId64 " vs %" PRId64 ")",
-                output->path().c_str(), most_recent_input->path().c_str(),
-                entry->mtime, most_recent_input->mtime());
-        return true;
-      }
     }
-    if (!entry && !generator) {
+    if (!entry) {
       EXPLAIN("command line not found in log for %s", output->path().c_str());
       return true;
     }
@@ -310,9 +241,8 @@
                         edge_->inputs_.begin() + explicit_deps_count,
                         var == "in" ? ' ' : '\n');
   } else if (var == "out") {
-    int explicit_outs_count = edge_->outputs_.size() - edge_->implicit_outs_;
     return MakePathList(edge_->outputs_.begin(),
-                        edge_->outputs_.begin() + explicit_outs_count,
+                        edge_->outputs_.end(),
                         ' ');
   }
 
@@ -417,21 +347,12 @@
   return pool() == &State::kConsolePool;
 }
 
-bool Edge::maybe_phonycycle_diagnostic() const {
-  // CMake 2.8.12.x and 3.0.x produced self-referencing phony rules
-  // of the form "build a: phony ... a ...".   Restrict our
-  // "phonycycle" diagnostic option to the form it used.
-  return is_phony() && outputs_.size() == 1 && implicit_outs_ == 0 &&
-      implicit_deps_ == 0;
-}
-
-// static
-string Node::PathDecanonicalized(const string& path, uint64_t slash_bits) {
-  string result = path;
+string Node::PathDecanonicalized() const {
+  string result = path_;
 #ifdef _WIN32
-  uint64_t mask = 1;
+  unsigned int mask = 1;
   for (char* c = &result[0]; (c = strchr(c, '/')) != NULL;) {
-    if (slash_bits & mask)
+    if (slash_bits_ & mask)
       *c = '\\';
     c++;
     mask <<= 1;
@@ -441,7 +362,7 @@
 }
 
 void Node::Dump(const char* prefix) const {
-  printf("%s <%s 0x%p> mtime: %" PRId64 "%s, (:%s), ",
+  printf("%s <%s 0x%p> mtime: %d%s, (:%s), ",
          prefix, path().c_str(), this,
          mtime(), mtime() ? "" : " (:missing)",
          dirty() ? " dirty" : " clean");
@@ -473,15 +394,8 @@
 bool ImplicitDepLoader::LoadDepFile(Edge* edge, const string& path,
                                     string* err) {
   METRIC_RECORD("depfile load");
-  // Read depfile content.  Treat a missing depfile as empty.
-  string content;
-  switch (disk_interface_->ReadFile(path, &content, err)) {
-  case DiskInterface::Okay:
-    break;
-  case DiskInterface::NotFound:
-    err->clear();
-    break;
-  case DiskInterface::OtherError:
+  string content = disk_interface_->ReadFile(path, err);
+  if (!err->empty()) {
     *err = "loading '" + path + "': " + *err;
     return false;
   }
@@ -491,21 +405,17 @@
     return false;
   }
 
-  DepfileParser depfile(depfile_parser_options_
-                        ? *depfile_parser_options_
-                        : DepfileParserOptions());
+  DepfileParser depfile;
   string depfile_err;
   if (!depfile.Parse(&content, &depfile_err)) {
     *err = path + ": " + depfile_err;
     return false;
   }
 
-  uint64_t unused;
+  unsigned int unused;
   if (!CanonicalizePath(const_cast<char*>(depfile.out_.str_),
-                        &depfile.out_.len_, &unused, err)) {
-    *err = path + ": " + *err;
+                        &depfile.out_.len_, &unused, err))
     return false;
-  }
 
   // Check that this depfile matches the edge's output, if not return false to
   // mark the edge as dirty.
@@ -524,7 +434,7 @@
   // Add all its in-edges.
   for (vector<StringPiece>::iterator i = depfile.ins_.begin();
        i != depfile.ins_.end(); ++i, ++implicit_dep) {
-    uint64_t slash_bits;
+    unsigned int slash_bits;
     if (!CanonicalizePath(const_cast<char*>(i->str_), &i->len_, &slash_bits,
                           err))
       return false;
@@ -549,7 +459,7 @@
 
   // Deps are invalid if the output is newer than the deps.
   if (output->mtime() > deps->mtime) {
-    EXPLAIN("stored deps info out of date for '%s' (%" PRId64 " vs %" PRId64 ")",
+    EXPLAIN("stored deps info out of date for '%s' (%d vs %d)",
             output->path().c_str(), deps->mtime, output->mtime());
     return false;
   }
diff -Naur ninja-1.9.0.orig/src/graph.h ninja/src/graph.h
--- ninja-1.9.0.orig/src/graph.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/graph.h	2019-09-24 19:51:29.630313738 +0000
@@ -21,10 +21,8 @@
 
 #include "eval_env.h"
 #include "timestamp.h"
-#include "util.h"
 
 struct BuildLog;
-struct DepfileParserOptions;
 struct DiskInterface;
 struct DepsLog;
 struct Edge;
@@ -35,7 +33,7 @@
 /// Information about a node in the dependency graph: the file, whether
 /// it's dirty, mtime, etc.
 struct Node {
-  Node(const string& path, uint64_t slash_bits)
+  Node(const string& path, unsigned int slash_bits)
       : path_(path),
         slash_bits_(slash_bits),
         mtime_(-1),
@@ -74,13 +72,8 @@
 
   const string& path() const { return path_; }
   /// Get |path()| but use slash_bits to convert back to original slash styles.
-  string PathDecanonicalized() const {
-    return PathDecanonicalized(path_, slash_bits_);
-  }
-  static string PathDecanonicalized(const string& path,
-                                    uint64_t slash_bits);
-  uint64_t slash_bits() const { return slash_bits_; }
-
+  string PathDecanonicalized() const;
+  unsigned int slash_bits() const { return slash_bits_; }
   TimeStamp mtime() const { return mtime_; }
 
   bool dirty() const { return dirty_; }
@@ -103,7 +96,7 @@
 
   /// Set bits starting from lowest for backslashes that were normalized to
   /// forward slashes by CanonicalizePath. See |PathDecanonicalized|.
-  uint64_t slash_bits_;
+  unsigned int slash_bits_;
 
   /// Possible values of mtime_:
   ///   -1: file hasn't been examined
@@ -129,15 +122,9 @@
 
 /// An edge in the dependency graph; links between Nodes using Rules.
 struct Edge {
-  enum VisitMark {
-    VisitNone,
-    VisitInStack,
-    VisitDone
-  };
-
-  Edge() : rule_(NULL), pool_(NULL), env_(NULL), mark_(VisitNone),
+  Edge() : rule_(NULL), pool_(NULL), env_(NULL),
            outputs_ready_(false), deps_missing_(false),
-           implicit_deps_(0), order_only_deps_(0), implicit_outs_(0) {}
+           implicit_deps_(0), order_only_deps_(0) {}
 
   /// Return true if all inputs' in-edges are ready.
   bool AllInputsReady() const;
@@ -163,7 +150,6 @@
   vector<Node*> inputs_;
   vector<Node*> outputs_;
   BindingEnv* env_;
-  VisitMark mark_;
   bool outputs_ready_;
   bool deps_missing_;
 
@@ -190,19 +176,8 @@
     return index >= inputs_.size() - order_only_deps_;
   }
 
-  // There are two types of outputs.
-  // 1) explicit outs, which show up as $out on the command line;
-  // 2) implicit outs, which the target generates but are not part of $out.
-  // These are stored in outputs_ in that order, and we keep a count of
-  // #2 to use when we need to access the various subsets.
-  int implicit_outs_;
-  bool is_implicit_out(size_t index) const {
-    return index >= outputs_.size() - implicit_outs_;
-  }
-
   bool is_phony() const;
   bool use_console() const;
-  bool maybe_phonycycle_diagnostic() const;
 };
 
 
@@ -210,10 +185,8 @@
 /// "depfile" attribute in build files.
 struct ImplicitDepLoader {
   ImplicitDepLoader(State* state, DepsLog* deps_log,
-                    DiskInterface* disk_interface,
-                    DepfileParserOptions const* depfile_parser_options)
-      : state_(state), disk_interface_(disk_interface), deps_log_(deps_log),
-        depfile_parser_options_(depfile_parser_options) {}
+                    DiskInterface* disk_interface)
+      : state_(state), disk_interface_(disk_interface), deps_log_(deps_log) {}
 
   /// Load implicit dependencies for \a edge.
   /// @return false on error (without filling \a err if info is just missing
@@ -245,7 +218,6 @@
   State* state_;
   DiskInterface* disk_interface_;
   DepsLog* deps_log_;
-  DepfileParserOptions const* depfile_parser_options_;
 };
 
 
@@ -253,18 +225,16 @@
 /// and updating the dirty/outputs_ready state of all the nodes and edges.
 struct DependencyScan {
   DependencyScan(State* state, BuildLog* build_log, DepsLog* deps_log,
-                 DiskInterface* disk_interface,
-                 DepfileParserOptions const* depfile_parser_options)
+                 DiskInterface* disk_interface)
       : build_log_(build_log),
         disk_interface_(disk_interface),
-        dep_loader_(state, deps_log, disk_interface, depfile_parser_options) {}
+        dep_loader_(state, deps_log, disk_interface) {}
 
-  /// Update the |dirty_| state of the given node by inspecting its input edge.
   /// Examine inputs, outputs, and command lines to judge whether an edge
   /// needs to be re-run, and update outputs_ready_ and each outputs' |dirty_|
   /// state accordingly.
   /// Returns false on failure.
-  bool RecomputeDirty(Node* node, string* err);
+  bool RecomputeDirty(Edge* edge, string* err);
 
   /// Recompute whether any output of the edge is dirty, if so sets |*dirty|.
   /// Returns false on failure.
@@ -283,9 +253,6 @@
   }
 
  private:
-  bool RecomputeDirty(Node* node, vector<Node*>* stack, string* err);
-  bool VerifyDAG(Node* node, vector<Node*>* stack, string* err);
-
   /// Recompute whether a given single output should be marked dirty.
   /// Returns true if so.
   bool RecomputeOutputDirty(Edge* edge, Node* most_recent_input,
diff -Naur ninja-1.9.0.orig/src/graph_test.cc ninja/src/graph_test.cc
--- ninja-1.9.0.orig/src/graph_test.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/graph_test.cc	2019-09-24 19:51:29.632048938 +0000
@@ -18,7 +18,7 @@
 #include "test.h"
 
 struct GraphTest : public StateTestWithBuiltinRules {
-  GraphTest() : scan_(&state_, NULL, NULL, &fs_, NULL) {}
+  GraphTest() : scan_(&state_, NULL, NULL, &fs_) {}
 
   VirtualFileSystem fs_;
   DependencyScan scan_;
@@ -30,8 +30,9 @@
   fs_.Create("in", "");
   fs_.Create("out", "");
 
+  Edge* edge = GetNode("out")->in_edge();
   string err;
-  EXPECT_TRUE(scan_.RecomputeDirty(GetNode("out"), &err));
+  EXPECT_TRUE(scan_.RecomputeDirty(edge, &err));
   ASSERT_EQ("", err);
 
   // A missing implicit dep *should* make the output dirty.
@@ -48,8 +49,9 @@
   fs_.Tick();
   fs_.Create("implicit", "");
 
+  Edge* edge = GetNode("out")->in_edge();
   string err;
-  EXPECT_TRUE(scan_.RecomputeDirty(GetNode("out"), &err));
+  EXPECT_TRUE(scan_.RecomputeDirty(edge, &err));
   ASSERT_EQ("", err);
 
   // A modified implicit dep should make the output dirty.
@@ -68,8 +70,9 @@
   fs_.Tick();
   fs_.Create("implicit.h", "");
 
+  Edge* edge = GetNode("out.o")->in_edge();
   string err;
-  EXPECT_TRUE(scan_.RecomputeDirty(GetNode("out.o"), &err));
+  EXPECT_TRUE(scan_.RecomputeDirty(edge, &err));
   ASSERT_EQ("", err);
 
   // implicit.h has changed, though our depfile refers to it with a
@@ -91,8 +94,9 @@
   fs_.Tick();
   fs_.Create("data", "");
 
+  Edge* edge = GetNode("out.o")->in_edge();
   string err;
-  EXPECT_TRUE(scan_.RecomputeDirty(GetNode("out.o"), &err));
+  EXPECT_TRUE(scan_.RecomputeDirty(edge, &err));
   ASSERT_EQ("", err);
 
   // We have both an implicit and an explicit dep on implicit.h.
@@ -101,85 +105,6 @@
   EXPECT_TRUE(GetNode("out.o")->dirty());
 }
 
-TEST_F(GraphTest, ImplicitOutputParse) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-"build out | out.imp: cat in\n"));
-
-  Edge* edge = GetNode("out")->in_edge();
-  EXPECT_EQ(2, edge->outputs_.size());
-  EXPECT_EQ("out", edge->outputs_[0]->path());
-  EXPECT_EQ("out.imp", edge->outputs_[1]->path());
-  EXPECT_EQ(1, edge->implicit_outs_);
-  EXPECT_EQ(edge, GetNode("out.imp")->in_edge());
-}
-
-TEST_F(GraphTest, ImplicitOutputMissing) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-"build out | out.imp: cat in\n"));
-  fs_.Create("in", "");
-  fs_.Create("out", "");
-
-  string err;
-  EXPECT_TRUE(scan_.RecomputeDirty(GetNode("out"), &err));
-  ASSERT_EQ("", err);
-
-  EXPECT_TRUE(GetNode("out")->dirty());
-  EXPECT_TRUE(GetNode("out.imp")->dirty());
-}
-
-TEST_F(GraphTest, ImplicitOutputOutOfDate) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-"build out | out.imp: cat in\n"));
-  fs_.Create("out.imp", "");
-  fs_.Tick();
-  fs_.Create("in", "");
-  fs_.Create("out", "");
-
-  string err;
-  EXPECT_TRUE(scan_.RecomputeDirty(GetNode("out"), &err));
-  ASSERT_EQ("", err);
-
-  EXPECT_TRUE(GetNode("out")->dirty());
-  EXPECT_TRUE(GetNode("out.imp")->dirty());
-}
-
-TEST_F(GraphTest, ImplicitOutputOnlyParse) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-"build | out.imp: cat in\n"));
-
-  Edge* edge = GetNode("out.imp")->in_edge();
-  EXPECT_EQ(1, edge->outputs_.size());
-  EXPECT_EQ("out.imp", edge->outputs_[0]->path());
-  EXPECT_EQ(1, edge->implicit_outs_);
-  EXPECT_EQ(edge, GetNode("out.imp")->in_edge());
-}
-
-TEST_F(GraphTest, ImplicitOutputOnlyMissing) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-"build | out.imp: cat in\n"));
-  fs_.Create("in", "");
-
-  string err;
-  EXPECT_TRUE(scan_.RecomputeDirty(GetNode("out.imp"), &err));
-  ASSERT_EQ("", err);
-
-  EXPECT_TRUE(GetNode("out.imp")->dirty());
-}
-
-TEST_F(GraphTest, ImplicitOutputOnlyOutOfDate) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-"build | out.imp: cat in\n"));
-  fs_.Create("out.imp", "");
-  fs_.Tick();
-  fs_.Create("in", "");
-
-  string err;
-  EXPECT_TRUE(scan_.RecomputeDirty(GetNode("out.imp"), &err));
-  ASSERT_EQ("", err);
-
-  EXPECT_TRUE(GetNode("out.imp")->dirty());
-}
-
 TEST_F(GraphTest, PathWithCurrentDirectory) {
   ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
 "rule catdep\n"
@@ -190,8 +115,9 @@
   fs_.Create("out.o.d", "out.o: foo.cc\n");
   fs_.Create("out.o", "");
 
+  Edge* edge = GetNode("out.o")->in_edge();
   string err;
-  EXPECT_TRUE(scan_.RecomputeDirty(GetNode("out.o"), &err));
+  EXPECT_TRUE(scan_.RecomputeDirty(edge, &err));
   ASSERT_EQ("", err);
 
   EXPECT_FALSE(GetNode("out.o")->dirty());
@@ -227,7 +153,7 @@
 #endif
 }
 
-// Regression test for https://github.com/ninja-build/ninja/issues/380
+// Regression test for https://github.com/martine/ninja/issues/380
 TEST_F(GraphTest, DepfileWithCanonicalizablePath) {
   ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
 "rule catdep\n"
@@ -238,14 +164,15 @@
   fs_.Create("out.o.d", "out.o: bar/../foo.cc\n");
   fs_.Create("out.o", "");
 
+  Edge* edge = GetNode("out.o")->in_edge();
   string err;
-  EXPECT_TRUE(scan_.RecomputeDirty(GetNode("out.o"), &err));
+  EXPECT_TRUE(scan_.RecomputeDirty(edge, &err));
   ASSERT_EQ("", err);
 
   EXPECT_FALSE(GetNode("out.o")->dirty());
 }
 
-// Regression test for https://github.com/ninja-build/ninja/issues/404
+// Regression test for https://github.com/martine/ninja/issues/404
 TEST_F(GraphTest, DepfileRemoved) {
   ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
 "rule catdep\n"
@@ -258,14 +185,15 @@
   fs_.Create("out.o.d", "out.o: foo.h\n");
   fs_.Create("out.o", "");
 
+  Edge* edge = GetNode("out.o")->in_edge();
   string err;
-  EXPECT_TRUE(scan_.RecomputeDirty(GetNode("out.o"), &err));
+  EXPECT_TRUE(scan_.RecomputeDirty(edge, &err));
   ASSERT_EQ("", err);
   EXPECT_FALSE(GetNode("out.o")->dirty());
 
   state_.Reset();
   fs_.RemoveFile("out.o.d");
-  EXPECT_TRUE(scan_.RecomputeDirty(GetNode("out.o"), &err));
+  EXPECT_TRUE(scan_.RecomputeDirty(edge, &err));
   ASSERT_EQ("", err);
   EXPECT_TRUE(GetNode("out.o")->dirty());
 }
@@ -312,7 +240,8 @@
 "build n2: phony n1\n"
   );
   string err;
-  EXPECT_TRUE(scan_.RecomputeDirty(GetNode("n2"), &err));
+  Edge* edge = GetNode("n2")->in_edge();
+  EXPECT_TRUE(scan_.RecomputeDirty(edge, &err));
   ASSERT_EQ("", err);
 
   Plan plan_;
@@ -323,67 +252,6 @@
   ASSERT_FALSE(plan_.more_to_do());
 }
 
-TEST_F(GraphTest, PhonySelfReferenceError) {
-  ManifestParserOptions parser_opts;
-  parser_opts.phony_cycle_action_ = kPhonyCycleActionError;
-  AssertParse(&state_,
-"build a: phony a\n",
-  parser_opts);
-
-  string err;
-  EXPECT_FALSE(scan_.RecomputeDirty(GetNode("a"), &err));
-  ASSERT_EQ("dependency cycle: a -> a [-w phonycycle=err]", err);
-}
-
-TEST_F(GraphTest, DependencyCycle) {
-  AssertParse(&state_,
-"build out: cat mid\n"
-"build mid: cat in\n"
-"build in: cat pre\n"
-"build pre: cat out\n");
-
-  string err;
-  EXPECT_FALSE(scan_.RecomputeDirty(GetNode("out"), &err));
-  ASSERT_EQ("dependency cycle: out -> mid -> in -> pre -> out", err);
-}
-
-TEST_F(GraphTest, CycleInEdgesButNotInNodes1) {
-  string err;
-  AssertParse(&state_,
-"build a b: cat a\n");
-  EXPECT_FALSE(scan_.RecomputeDirty(GetNode("b"), &err));
-  ASSERT_EQ("dependency cycle: a -> a", err);
-}
-
-TEST_F(GraphTest, CycleInEdgesButNotInNodes2) {
-  string err;
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-"build b a: cat a\n"));
-  EXPECT_FALSE(scan_.RecomputeDirty(GetNode("b"), &err));
-  ASSERT_EQ("dependency cycle: a -> a", err);
-}
-
-TEST_F(GraphTest, CycleInEdgesButNotInNodes3) {
-  string err;
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-"build a b: cat c\n"
-"build c: cat a\n"));
-  EXPECT_FALSE(scan_.RecomputeDirty(GetNode("b"), &err));
-  ASSERT_EQ("dependency cycle: a -> c -> a", err);
-}
-
-TEST_F(GraphTest, CycleInEdgesButNotInNodes4) {
-  string err;
-  ASSERT_NO_FATAL_FAILURE(AssertParse(&state_,
-"build d: cat c\n"
-"build c: cat b\n"
-"build b: cat a\n"
-"build a e: cat d\n"
-"build f: cat e\n"));
-  EXPECT_FALSE(scan_.RecomputeDirty(GetNode("f"), &err));
-  ASSERT_EQ("dependency cycle: a -> d -> c -> b -> a", err);
-}
-
 // Verify that cycles in graphs with multiple outputs are handled correctly
 // in RecomputeDirty() and don't cause deps to be loaded multiple times.
 TEST_F(GraphTest, CycleWithLengthZeroFromDepfile) {
@@ -396,13 +264,13 @@
   fs_.Create("dep.d", "a: b\n");
 
   string err;
-  EXPECT_FALSE(scan_.RecomputeDirty(GetNode("a"), &err));
-  ASSERT_EQ("dependency cycle: b -> b", err);
+  Edge* edge = GetNode("a")->in_edge();
+  EXPECT_TRUE(scan_.RecomputeDirty(edge, &err));
+  ASSERT_EQ("", err);
 
   // Despite the depfile causing edge to be a cycle (it has outputs a and b,
   // but the depfile also adds b as an input), the deps should have been loaded
   // only once:
-  Edge* edge = GetNode("a")->in_edge();
   EXPECT_EQ(1, edge->inputs_.size());
   EXPECT_EQ("b", edge->inputs_[0]->path());
 }
@@ -421,13 +289,13 @@
   fs_.Create("dep.d", "a: c\n");
 
   string err;
-  EXPECT_FALSE(scan_.RecomputeDirty(GetNode("a"), &err));
-  ASSERT_EQ("dependency cycle: b -> c -> b", err);
+  Edge* edge = GetNode("a")->in_edge();
+  EXPECT_TRUE(scan_.RecomputeDirty(edge, &err));
+  ASSERT_EQ("", err);
 
   // Despite the depfile causing edge to be a cycle (|edge| has outputs a and b,
   // but c's in_edge has b as input but the depfile also adds |edge| as
   // output)), the deps should have been loaded only once:
-  Edge* edge = GetNode("a")->in_edge();
   EXPECT_EQ(1, edge->inputs_.size());
   EXPECT_EQ("c", edge->inputs_[0]->path());
 }
@@ -448,8 +316,8 @@
   fs_.Create("dep.d", "a: c\n");
 
   string err;
-  EXPECT_FALSE(scan_.RecomputeDirty(GetNode("d"), &err));
-  ASSERT_EQ("dependency cycle: b -> c -> b", err);
+  EXPECT_TRUE(scan_.RecomputeDirty(GetNode("d")->in_edge(), &err));
+  ASSERT_EQ("", err);
 
   // Despite the depfile causing edge to be a cycle (|edge| has outputs a and b,
   // but c's in_edge has b as input but the depfile also adds |edge| as
diff -Naur ninja-1.9.0.orig/src/graphviz.h ninja/src/graphviz.h
--- ninja-1.9.0.orig/src/graphviz.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/graphviz.h	2019-09-24 19:51:29.633646538 +0000
@@ -16,6 +16,7 @@
 #define NINJA_GRAPHVIZ_H_
 
 #include <set>
+using namespace std;
 
 struct Node;
 struct Edge;
@@ -26,8 +27,8 @@
   void AddTarget(Node* node);
   void Finish();
 
-  std::set<Node*> visited_nodes_;
-  std::set<Edge*> visited_edges_;
+  set<Node*> visited_nodes_;
+  set<Edge*> visited_edges_;
 };
 
 #endif  // NINJA_GRAPHVIZ_H_
diff -Naur ninja-1.9.0.orig/src/hash_collision_bench.cc ninja/src/hash_collision_bench.cc
--- ninja-1.9.0.orig/src/hash_collision_bench.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/hash_collision_bench.cc	2019-09-24 19:51:29.634335338 +0000
@@ -17,7 +17,6 @@
 #include <algorithm>
 using namespace std;
 
-#include <stdlib.h>
 #include <time.h>
 
 int random(int low, int high) {
diff -Naur ninja-1.9.0.orig/src/hash_map.h ninja/src/hash_map.h
--- ninja-1.9.0.orig/src/hash_map.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/hash_map.h	2019-09-24 19:51:29.635196938 +0000
@@ -18,7 +18,6 @@
 #include <algorithm>
 #include <string.h>
 #include "string_piece.h"
-#include "util.h"
 
 // MurmurHash2, by Austin Appleby
 static inline
@@ -41,9 +40,7 @@
   }
   switch (len) {
   case 3: h ^= data[2] << 16;
-          NINJA_FALLTHROUGH;
   case 2: h ^= data[1] << 8;
-          NINJA_FALLTHROUGH;
   case 1: h ^= data[0];
     h *= m;
   };
@@ -79,7 +76,7 @@
     return MurmurHash2(key.str_, key.len_);
   }
   bool operator()(const StringPiece& a, const StringPiece& b) const {
-    int cmp = memcmp(a.str_, b.str_, min(a.len_, b.len_));
+    int cmp = strncmp(a.str_, b.str_, min(a.len_, b.len_));
     if (cmp < 0) {
       return true;
     } else if (cmp > 0) {
diff -Naur ninja-1.9.0.orig/src/includes_normalize-win32.cc ninja/src/includes_normalize-win32.cc
--- ninja-1.9.0.orig/src/includes_normalize-win32.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/includes_normalize-win32.cc	2019-09-24 19:51:29.636040138 +0000
@@ -15,7 +15,6 @@
 #include "includes_normalize.h"
 
 #include "string_piece.h"
-#include "string_piece_util.h"
 #include "util.h"
 
 #include <algorithm>
@@ -26,62 +25,12 @@
 
 namespace {
 
-bool InternalGetFullPathName(const StringPiece& file_name, char* buffer,
-                             size_t buffer_length, string *err) {
-  DWORD result_size = GetFullPathNameA(file_name.AsString().c_str(),
-                                       buffer_length, buffer, NULL);
-  if (result_size == 0) {
-    *err = "GetFullPathNameA(" + file_name.AsString() + "): " +
-        GetLastErrorString();
-    return false;
-  } else if (result_size > buffer_length) {
-    *err = "path too long";
-    return false;
-  }
-  return true;
-}
-
-bool IsPathSeparator(char c) {
-  return c == '/' ||  c == '\\';
-}
-
-// Return true if paths a and b are on the same windows drive.
-// Return false if this funcation cannot check
-// whether or not on the same windows drive.
-bool SameDriveFast(StringPiece a, StringPiece b) {
-  if (a.size() < 3 || b.size() < 3) {
-    return false;
-  }
-
-  if (!islatinalpha(a[0]) || !islatinalpha(b[0])) {
-    return false;
-  }
-
-  if (ToLowerASCII(a[0]) != ToLowerASCII(b[0])) {
-    return false;
-  }
-
-  if (a[1] != ':' || b[1] != ':') {
-    return false;
-  }
-
-  return IsPathSeparator(a[2]) && IsPathSeparator(b[2]);
-}
-
-// Return true if paths a and b are on the same Windows drive.
-bool SameDrive(StringPiece a, StringPiece b, string* err)  {
-  if (SameDriveFast(a, b)) {
-    return true;
-  }
-
+/// Return true if paths a and b are on the same Windows drive.
+bool SameDrive(StringPiece a, StringPiece b)  {
   char a_absolute[_MAX_PATH];
   char b_absolute[_MAX_PATH];
-  if (!InternalGetFullPathName(a, a_absolute, sizeof(a_absolute), err)) {
-    return false;
-  }
-  if (!InternalGetFullPathName(b, b_absolute, sizeof(b_absolute), err)) {
-    return false;
-  }
+  GetFullPathName(a.AsString().c_str(), sizeof(a_absolute), a_absolute, NULL);
+  GetFullPathName(b.AsString().c_str(), sizeof(b_absolute), b_absolute, NULL);
   char a_drive[_MAX_DIR];
   char b_drive[_MAX_DIR];
   _splitpath(a_absolute, a_drive, NULL, NULL, NULL);
@@ -89,121 +38,79 @@
   return _stricmp(a_drive, b_drive) == 0;
 }
 
-// Check path |s| is FullPath style returned by GetFullPathName.
-// This ignores difference of path separator.
-// This is used not to call very slow GetFullPathName API.
-bool IsFullPathName(StringPiece s) {
-  if (s.size() < 3 ||
-      !islatinalpha(s[0]) ||
-      s[1] != ':' ||
-      !IsPathSeparator(s[2])) {
-    return false;
-  }
+}  // anonymous namespace
 
-  // Check "." or ".." is contained in path.
-  for (size_t i = 2; i < s.size(); ++i) {
-    if (!IsPathSeparator(s[i])) {
-      continue;
-    }
-
-    // Check ".".
-    if (i + 1 < s.size() && s[i+1] == '.' &&
-        (i + 2 >= s.size() || IsPathSeparator(s[i+2]))) {
-      return false;
-    }
-
-    // Check "..".
-    if (i + 2 < s.size() && s[i+1] == '.' && s[i+2] == '.' &&
-        (i + 3 >= s.size() || IsPathSeparator(s[i+3]))) {
-      return false;
-    }
+string IncludesNormalize::Join(const vector<string>& list, char sep) {
+  string ret;
+  for (size_t i = 0; i < list.size(); ++i) {
+    ret += list[i];
+    if (i != list.size() - 1)
+      ret += sep;
   }
-
-  return true;
+  return ret;
 }
 
-}  // anonymous namespace
-
-IncludesNormalize::IncludesNormalize(const string& relative_to) {
-  string err;
-  relative_to_ = AbsPath(relative_to, &err);
-  if (!err.empty()) {
-    Fatal("Initializing IncludesNormalize(): %s", err.c_str());
-  }
-  split_relative_to_ = SplitStringPiece(relative_to_, '/');
+vector<string> IncludesNormalize::Split(const string& input, char sep) {
+  vector<string> elems;
+  stringstream ss(input);
+  string item;
+  while (getline(ss, item, sep))
+    elems.push_back(item);
+  return elems;
 }
 
-string IncludesNormalize::AbsPath(StringPiece s, string* err) {
-  if (IsFullPathName(s)) {
-    string result = s.AsString();
-    for (size_t i = 0; i < result.size(); ++i) {
-      if (result[i] == '\\') {
-        result[i] = '/';
-      }
-    }
-    return result;
-  }
+string IncludesNormalize::ToLower(const string& s) {
+  string ret;
+  transform(s.begin(), s.end(), back_inserter(ret), ::tolower);
+  return ret;
+}
 
+string IncludesNormalize::AbsPath(StringPiece s) {
   char result[_MAX_PATH];
-  if (!InternalGetFullPathName(s, result, sizeof(result), err)) {
-    return "";
-  }
+  GetFullPathName(s.AsString().c_str(), sizeof(result), result, NULL);
   for (char* c = result; *c; ++c)
     if (*c == '\\')
       *c = '/';
   return result;
 }
 
-string IncludesNormalize::Relativize(
-    StringPiece path, const vector<StringPiece>& start_list, string* err) {
-  string abs_path = AbsPath(path, err);
-  if (!err->empty())
-    return "";
-  vector<StringPiece> path_list = SplitStringPiece(abs_path, '/');
+string IncludesNormalize::Relativize(StringPiece path, const string& start) {
+  vector<string> start_list = Split(AbsPath(start), '/');
+  vector<string> path_list = Split(AbsPath(path), '/');
   int i;
   for (i = 0; i < static_cast<int>(min(start_list.size(), path_list.size()));
        ++i) {
-    if (!EqualsCaseInsensitiveASCII(start_list[i], path_list[i])) {
+    if (ToLower(start_list[i]) != ToLower(path_list[i]))
       break;
-    }
   }
 
-  vector<StringPiece> rel_list;
-  rel_list.reserve(start_list.size() - i + path_list.size() - i);
+  vector<string> rel_list;
   for (int j = 0; j < static_cast<int>(start_list.size() - i); ++j)
     rel_list.push_back("..");
   for (int j = i; j < static_cast<int>(path_list.size()); ++j)
     rel_list.push_back(path_list[j]);
   if (rel_list.size() == 0)
     return ".";
-  return JoinStringPiece(rel_list, '/');
+  return Join(rel_list, '/');
 }
 
-bool IncludesNormalize::Normalize(const string& input,
-                                  string* result, string* err) const {
-  char copy[_MAX_PATH + 1];
+string IncludesNormalize::Normalize(const string& input,
+                                    const char* relative_to) {
+  char copy[_MAX_PATH];
   size_t len = input.size();
-  if (len > _MAX_PATH) {
-    *err = "path too long";
-    return false;
-  }
   strncpy(copy, input.c_str(), input.size() + 1);
-  uint64_t slash_bits;
-  if (!CanonicalizePath(copy, &len, &slash_bits, err))
-    return false;
+  string err;
+  unsigned int slash_bits;
+  if (!CanonicalizePath(copy, &len, &slash_bits, &err))
+    Warning("couldn't canonicalize '%s': %s\n", input.c_str(), err.c_str());
   StringPiece partially_fixed(copy, len);
-  string abs_input = AbsPath(partially_fixed, err);
-  if (!err->empty())
-    return false;
-
-  if (!SameDrive(abs_input, relative_to_, err)) {
-    if (!err->empty())
-      return false;
-    *result = partially_fixed.AsString();
-    return true;
-  }
-  *result = Relativize(abs_input, split_relative_to_, err);
-  if (!err->empty())
-    return false;
-  return true;
+
+  string curdir;
+  if (!relative_to) {
+    curdir = AbsPath(".");
+    relative_to = curdir.c_str();
+  }
+  if (!SameDrive(partially_fixed, relative_to))
+    return partially_fixed.AsString();
+  return Relativize(partially_fixed, relative_to);
 }
diff -Naur ninja-1.9.0.orig/src/includes_normalize.h ninja/src/includes_normalize.h
--- ninja-1.9.0.orig/src/includes_normalize.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/includes_normalize.h	2019-09-24 19:51:29.636669738 +0000
@@ -21,19 +21,14 @@
 /// Utility functions for normalizing include paths on Windows.
 /// TODO: this likely duplicates functionality of CanonicalizePath; refactor.
 struct IncludesNormalize {
-  /// Normalize path relative to |relative_to|.
-  IncludesNormalize(const string& relative_to);
-
   // Internal utilities made available for testing, maybe useful otherwise.
-  static string AbsPath(StringPiece s, string* err);
-  static string Relativize(StringPiece path,
-                           const vector<StringPiece>& start_list, string* err);
+  static string Join(const vector<string>& list, char sep);
+  static vector<string> Split(const string& input, char sep);
+  static string ToLower(const string& s);
+  static string AbsPath(StringPiece s);
+  static string Relativize(StringPiece path, const string& start);
 
   /// Normalize by fixing slashes style, fixing redundant .. and . and makes the
-  /// path |input| relative to |this->relative_to_| and store to |result|.
-  bool Normalize(const string& input, string* result, string* err) const;
-
- private:
-  string relative_to_;
-  vector<StringPiece> split_relative_to_;
+  /// path relative to |relative_to|.
+  static string Normalize(const string& input, const char* relative_to);
 };
diff -Naur ninja-1.9.0.orig/src/includes_normalize_test.cc ninja/src/includes_normalize_test.cc
--- ninja-1.9.0.orig/src/includes_normalize_test.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/includes_normalize_test.cc	2019-09-24 19:51:29.637576938 +0000
@@ -14,154 +14,91 @@
 
 #include "includes_normalize.h"
 
-#include <algorithm>
-
 #include <direct.h>
 
-#include "string_piece_util.h"
 #include "test.h"
 #include "util.h"
 
+TEST(IncludesNormalize, Simple) {
+  EXPECT_EQ("b", IncludesNormalize::Normalize("a\\..\\b", NULL));
+  EXPECT_EQ("b", IncludesNormalize::Normalize("a\\../b", NULL));
+  EXPECT_EQ("a/b", IncludesNormalize::Normalize("a\\.\\b", NULL));
+  EXPECT_EQ("a/b", IncludesNormalize::Normalize("a\\./b", NULL));
+}
+
 namespace {
 
 string GetCurDir() {
   char buf[_MAX_PATH];
   _getcwd(buf, sizeof(buf));
-  vector<StringPiece> parts = SplitStringPiece(buf, '\\');
-  return parts[parts.size() - 1].AsString();
-}
-
-string NormalizeAndCheckNoError(const string& input) {
-  string result, err;
-  IncludesNormalize normalizer(".");
-  EXPECT_TRUE(normalizer.Normalize(input, &result, &err));
-  EXPECT_EQ("", err);
-  return result;
-}
-
-string NormalizeRelativeAndCheckNoError(const string& input,
-                                        const string& relative_to) {
-  string result, err;
-  IncludesNormalize normalizer(relative_to);
-  EXPECT_TRUE(normalizer.Normalize(input, &result, &err));
-  EXPECT_EQ("", err);
-  return result;
+  vector<string> parts = IncludesNormalize::Split(string(buf), '\\');
+  return parts[parts.size() - 1];
 }
 
 }  // namespace
 
-TEST(IncludesNormalize, Simple) {
-  EXPECT_EQ("b", NormalizeAndCheckNoError("a\\..\\b"));
-  EXPECT_EQ("b", NormalizeAndCheckNoError("a\\../b"));
-  EXPECT_EQ("a/b", NormalizeAndCheckNoError("a\\.\\b"));
-  EXPECT_EQ("a/b", NormalizeAndCheckNoError("a\\./b"));
-}
-
 TEST(IncludesNormalize, WithRelative) {
-  string err;
   string currentdir = GetCurDir();
-  EXPECT_EQ("c", NormalizeRelativeAndCheckNoError("a/b/c", "a/b"));
-  EXPECT_EQ("a",
-            NormalizeAndCheckNoError(IncludesNormalize::AbsPath("a", &err)));
-  EXPECT_EQ("", err);
+  EXPECT_EQ("c", IncludesNormalize::Normalize("a/b/c", "a/b"));
+  EXPECT_EQ("a", IncludesNormalize::Normalize(IncludesNormalize::AbsPath("a"),
+                                              NULL));
   EXPECT_EQ(string("../") + currentdir + string("/a"),
-            NormalizeRelativeAndCheckNoError("a", "../b"));
+            IncludesNormalize::Normalize("a", "../b"));
   EXPECT_EQ(string("../") + currentdir + string("/a/b"),
-            NormalizeRelativeAndCheckNoError("a/b", "../c"));
-  EXPECT_EQ("../../a", NormalizeRelativeAndCheckNoError("a", "b/c"));
-  EXPECT_EQ(".", NormalizeRelativeAndCheckNoError("a", "a"));
+            IncludesNormalize::Normalize("a/b", "../c"));
+  EXPECT_EQ("../../a", IncludesNormalize::Normalize("a", "b/c"));
+  EXPECT_EQ(".", IncludesNormalize::Normalize("a", "a"));
 }
 
 TEST(IncludesNormalize, Case) {
-  EXPECT_EQ("b", NormalizeAndCheckNoError("Abc\\..\\b"));
-  EXPECT_EQ("BdEf", NormalizeAndCheckNoError("Abc\\..\\BdEf"));
-  EXPECT_EQ("A/b", NormalizeAndCheckNoError("A\\.\\b"));
-  EXPECT_EQ("a/b", NormalizeAndCheckNoError("a\\./b"));
-  EXPECT_EQ("A/B", NormalizeAndCheckNoError("A\\.\\B"));
-  EXPECT_EQ("A/B", NormalizeAndCheckNoError("A\\./B"));
+  EXPECT_EQ("b", IncludesNormalize::Normalize("Abc\\..\\b", NULL));
+  EXPECT_EQ("BdEf", IncludesNormalize::Normalize("Abc\\..\\BdEf", NULL));
+  EXPECT_EQ("A/b", IncludesNormalize::Normalize("A\\.\\b", NULL));
+  EXPECT_EQ("a/b", IncludesNormalize::Normalize("a\\./b", NULL));
+  EXPECT_EQ("A/B", IncludesNormalize::Normalize("A\\.\\B", NULL));
+  EXPECT_EQ("A/B", IncludesNormalize::Normalize("A\\./B", NULL));
+}
+
+TEST(IncludesNormalize, Join) {
+  vector<string> x;
+  EXPECT_EQ("", IncludesNormalize::Join(x, ':'));
+  x.push_back("alpha");
+  EXPECT_EQ("alpha", IncludesNormalize::Join(x, ':'));
+  x.push_back("beta");
+  x.push_back("gamma");
+  EXPECT_EQ("alpha:beta:gamma", IncludesNormalize::Join(x, ':'));
+}
+
+TEST(IncludesNormalize, Split) {
+  EXPECT_EQ("", IncludesNormalize::Join(IncludesNormalize::Split("", '/'),
+                                        ':'));
+  EXPECT_EQ("a", IncludesNormalize::Join(IncludesNormalize::Split("a", '/'),
+                                         ':'));
+  EXPECT_EQ("a:b:c",
+            IncludesNormalize::Join(
+                IncludesNormalize::Split("a/b/c", '/'), ':'));
+}
+
+TEST(IncludesNormalize, ToLower) {
+  EXPECT_EQ("", IncludesNormalize::ToLower(""));
+  EXPECT_EQ("stuff", IncludesNormalize::ToLower("Stuff"));
+  EXPECT_EQ("stuff and things", IncludesNormalize::ToLower("Stuff AND thINGS"));
+  EXPECT_EQ("stuff 3and thin43gs",
+            IncludesNormalize::ToLower("Stuff 3AND thIN43GS"));
 }
 
 TEST(IncludesNormalize, DifferentDrive) {
   EXPECT_EQ("stuff.h",
-            NormalizeRelativeAndCheckNoError("p:\\vs08\\stuff.h", "p:\\vs08"));
+      IncludesNormalize::Normalize("p:\\vs08\\stuff.h", "p:\\vs08"));
   EXPECT_EQ("stuff.h",
-            NormalizeRelativeAndCheckNoError("P:\\Vs08\\stuff.h", "p:\\vs08"));
+      IncludesNormalize::Normalize("P:\\Vs08\\stuff.h", "p:\\vs08"));
   EXPECT_EQ("p:/vs08/stuff.h",
-            NormalizeRelativeAndCheckNoError("p:\\vs08\\stuff.h", "c:\\vs08"));
-  EXPECT_EQ("P:/vs08/stufF.h", NormalizeRelativeAndCheckNoError(
-                                   "P:\\vs08\\stufF.h", "D:\\stuff/things"));
-  EXPECT_EQ("P:/vs08/stuff.h", NormalizeRelativeAndCheckNoError(
-                                   "P:/vs08\\stuff.h", "D:\\stuff/things"));
+      IncludesNormalize::Normalize("p:\\vs08\\stuff.h", "c:\\vs08"));
+  EXPECT_EQ("P:/vs08/stufF.h",
+      IncludesNormalize::Normalize("P:\\vs08\\stufF.h", "D:\\stuff/things"));
+  EXPECT_EQ("P:/vs08/stuff.h",
+      IncludesNormalize::Normalize("P:/vs08\\stuff.h", "D:\\stuff/things"));
   EXPECT_EQ("P:/wee/stuff.h",
-            NormalizeRelativeAndCheckNoError("P:/vs08\\../wee\\stuff.h",
-                                             "D:\\stuff/things"));
-}
-
-TEST(IncludesNormalize, LongInvalidPath) {
-  const char kLongInputString[] =
-      "C:\\Program Files (x86)\\Microsoft Visual Studio "
-      "12.0\\VC\\INCLUDEwarning #31001: The dll for reading and writing the "
-      "pdb (for example, mspdb110.dll) could not be found on your path. This "
-      "is usually a configuration error. Compilation will continue using /Z7 "
-      "instead of /Zi, but expect a similar error when you link your program.";
-  // Too long, won't be canonicalized. Ensure doesn't crash.
-  string result, err;
-  IncludesNormalize normalizer(".");
-  EXPECT_FALSE(
-      normalizer.Normalize(kLongInputString, &result, &err));
-  EXPECT_EQ("path too long", err);
-
-
-  // Construct max size path having cwd prefix.
-  // kExactlyMaxPath = "$cwd\\a\\aaaa...aaaa\0";
-  char kExactlyMaxPath[_MAX_PATH + 1];
-  ASSERT_NE(_getcwd(kExactlyMaxPath, sizeof kExactlyMaxPath), NULL);
-
-  int cwd_len = strlen(kExactlyMaxPath);
-  ASSERT_LE(cwd_len + 3 + 1, _MAX_PATH)
-  kExactlyMaxPath[cwd_len] = '\\';
-  kExactlyMaxPath[cwd_len + 1] = 'a';
-  kExactlyMaxPath[cwd_len + 2] = '\\';
-
-  kExactlyMaxPath[cwd_len + 3] = 'a';
-
-  for (int i = cwd_len + 4; i < _MAX_PATH; ++i) {
-    if (i > cwd_len + 4 && i < _MAX_PATH - 1 && i % 10 == 0)
-      kExactlyMaxPath[i] = '\\';
-    else
-      kExactlyMaxPath[i] = 'a';
-  }
-
-  kExactlyMaxPath[_MAX_PATH] = '\0';
-  EXPECT_EQ(strlen(kExactlyMaxPath), _MAX_PATH);
-
-  string forward_slashes(kExactlyMaxPath);
-  replace(forward_slashes.begin(), forward_slashes.end(), '\\', '/');
-  // Make sure a path that's exactly _MAX_PATH long is canonicalized.
-  EXPECT_EQ(forward_slashes.substr(cwd_len + 1),
-            NormalizeAndCheckNoError(kExactlyMaxPath));
-}
-
-TEST(IncludesNormalize, ShortRelativeButTooLongAbsolutePath) {
-  string result, err;
-  IncludesNormalize normalizer(".");
-  // A short path should work
-  EXPECT_TRUE(normalizer.Normalize("a", &result, &err));
-  EXPECT_EQ("", err);
-
-  // Construct max size path having cwd prefix.
-  // kExactlyMaxPath = "aaaa\\aaaa...aaaa\0";
-  char kExactlyMaxPath[_MAX_PATH + 1];
-  for (int i = 0; i < _MAX_PATH; ++i) {
-    if (i < _MAX_PATH - 1 && i % 10 == 4)
-      kExactlyMaxPath[i] = '\\';
-    else
-      kExactlyMaxPath[i] = 'a';
-  }
-  kExactlyMaxPath[_MAX_PATH] = '\0';
-  EXPECT_EQ(strlen(kExactlyMaxPath), _MAX_PATH);
-
-  // Make sure a path that's exactly _MAX_PATH long fails with a proper error.
-  EXPECT_FALSE(normalizer.Normalize(kExactlyMaxPath, &result, &err));
-  EXPECT_TRUE(err.find("GetFullPathName") != string::npos);
+            IncludesNormalize::Normalize("P:/vs08\\../wee\\stuff.h",
+                                         "D:\\stuff/things"));
 }
diff -Naur ninja-1.9.0.orig/src/inline.sh ninja/src/inline.sh
--- ninja-1.9.0.orig/src/inline.sh	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/inline.sh	2019-09-24 19:51:29.638460138 +0000
@@ -20,6 +20,6 @@
 
 varname="$1"
 echo "const char $varname[] ="
-od -t x1 -A n -v | sed -e 's|[ \t]||g; s|..|\\x&|g; s|^|"|; s|$|"|'
+od -t x1 -A n -v | sed -e 's| ||g; s|..|\\x&|g; s|^|"|; s|$|"|'
 echo ";"
 
diff -Naur ninja-1.9.0.orig/src/lexer.cc ninja/src/lexer.cc
--- ninja-1.9.0.orig/src/lexer.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/lexer.cc	2019-09-24 19:51:29.640428938 +0000
@@ -1,4 +1,4 @@
-/* Generated by re2c 0.16 */
+/* Generated by re2c 0.13.5 */
 // Copyright 2011 Google Inc. All Rights Reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
@@ -23,14 +23,14 @@
 bool Lexer::Error(const string& message, string* err) {
   // Compute line/column.
   int line = 1;
-  const char* line_start = input_.str_;
+  const char* context = input_.str_;
   for (const char* p = input_.str_; p < last_token_; ++p) {
     if (*p == '\n') {
       ++line;
-      line_start = p + 1;
+      context = p + 1;
     }
   }
-  int col = last_token_ ? (int)(last_token_ - line_start) : 0;
+  int col = last_token_ ? (int)(last_token_ - context) : 0;
 
   char buf[1024];
   snprintf(buf, sizeof(buf), "%s:%d: ", filename_.AsString().c_str(), line);
@@ -43,12 +43,12 @@
     int len;
     bool truncated = true;
     for (len = 0; len < kTruncateColumn; ++len) {
-      if (line_start[len] == 0 || line_start[len] == '\n') {
+      if (context[len] == 0 || context[len] == '\n') {
         truncated = false;
         break;
       }
     }
-    *err += string(line_start, len);
+    *err += string(context, len);
     if (truncated)
       *err += "...";
     *err += "\n";
@@ -126,325 +126,305 @@
 	unsigned char yych;
 	unsigned int yyaccept = 0;
 	static const unsigned char yybm[] = {
-		  0, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128,   0, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		160, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 192, 192, 128, 
-		192, 192, 192, 192, 192, 192, 192, 192, 
-		192, 192, 128, 128, 128, 128, 128, 128, 
-		128, 192, 192, 192, 192, 192, 192, 192, 
-		192, 192, 192, 192, 192, 192, 192, 192, 
-		192, 192, 192, 192, 192, 192, 192, 192, 
-		192, 192, 192, 128, 128, 128, 128, 192, 
-		128, 192, 192, 192, 192, 192, 192, 192, 
-		192, 192, 192, 192, 192, 192, 192, 192, 
-		192, 192, 192, 192, 192, 192, 192, 192, 
-		192, 192, 192, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
-		128, 128, 128, 128, 128, 128, 128, 128, 
+		  0,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,   0,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		192,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  96,  96,  64, 
+		 96,  96,  96,  96,  96,  96,  96,  96, 
+		 96,  96,  64,  64,  64,  64,  64,  64, 
+		 64,  96,  96,  96,  96,  96,  96,  96, 
+		 96,  96,  96,  96,  96,  96,  96,  96, 
+		 96,  96,  96,  96,  96,  96,  96,  96, 
+		 96,  96,  96,  64,  64,  64,  64,  96, 
+		 64,  96,  96,  96,  96,  96,  96,  96, 
+		 96,  96,  96,  96,  96,  96,  96,  96, 
+		 96,  96,  96,  96,  96,  96,  96,  96, 
+		 96,  96,  96,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
+		 64,  64,  64,  64,  64,  64,  64,  64, 
 	};
+
 	yych = *p;
-	if (yybm[0+yych] & 32) {
-		goto yy9;
-	}
-	if (yych <= '^') {
-		if (yych <= ',') {
+	if (yych <= 'Z') {
+		if (yych <= '#') {
 			if (yych <= '\f') {
-				if (yych <= 0x00) goto yy2;
-				if (yych == '\n') goto yy6;
-				goto yy4;
+				if (yych <= 0x00) goto yy23;
+				if (yych == '\n') goto yy7;
+				goto yy25;
 			} else {
-				if (yych <= '\r') goto yy8;
-				if (yych == '#') goto yy12;
-				goto yy4;
+				if (yych <= 0x1F) {
+					if (yych <= '\r') goto yy6;
+					goto yy25;
+				} else {
+					if (yych <= ' ') goto yy2;
+					if (yych <= '"') goto yy25;
+					goto yy4;
+				}
 			}
 		} else {
-			if (yych <= ':') {
-				if (yych == '/') goto yy4;
-				if (yych <= '9') goto yy13;
-				goto yy16;
+			if (yych <= '9') {
+				if (yych <= ',') goto yy25;
+				if (yych == '/') goto yy25;
+				goto yy22;
 			} else {
-				if (yych <= '=') {
-					if (yych <= '<') goto yy4;
-					goto yy18;
+				if (yych <= '<') {
+					if (yych <= ':') goto yy16;
+					goto yy25;
 				} else {
-					if (yych <= '@') goto yy4;
-					if (yych <= 'Z') goto yy13;
-					goto yy4;
+					if (yych <= '=') goto yy14;
+					if (yych <= '@') goto yy25;
+					goto yy22;
 				}
 			}
 		}
 	} else {
 		if (yych <= 'i') {
-			if (yych <= 'b') {
-				if (yych == '`') goto yy4;
-				if (yych <= 'a') goto yy13;
-				goto yy20;
-			} else {
-				if (yych == 'd') goto yy21;
-				if (yych <= 'h') goto yy13;
+			if (yych <= 'a') {
+				if (yych == '_') goto yy22;
+				if (yych <= '`') goto yy25;
 				goto yy22;
+			} else {
+				if (yych <= 'c') {
+					if (yych <= 'b') goto yy9;
+					goto yy22;
+				} else {
+					if (yych <= 'd') goto yy13;
+					if (yych <= 'h') goto yy22;
+					goto yy20;
+				}
 			}
 		} else {
 			if (yych <= 'r') {
-				if (yych == 'p') goto yy23;
-				if (yych <= 'q') goto yy13;
-				goto yy24;
+				if (yych == 'p') goto yy11;
+				if (yych <= 'q') goto yy22;
+				goto yy12;
 			} else {
 				if (yych <= 'z') {
-					if (yych <= 's') goto yy25;
-					goto yy13;
+					if (yych <= 's') goto yy21;
+					goto yy22;
 				} else {
-					if (yych == '|') goto yy26;
-					goto yy4;
+					if (yych == '|') goto yy18;
+					goto yy25;
 				}
 			}
 		}
 	}
 yy2:
-	++p;
-	{ token = TEOF;     break; }
+	yyaccept = 0;
+	yych = *(q = ++p);
+	goto yy73;
+yy3:
+	{ token = INDENT;   break; }
 yy4:
-	++p;
+	yyaccept = 1;
+	yych = *(q = ++p);
+	if (yych >= 0x01) goto yy68;
 yy5:
 	{ token = ERROR;    break; }
 yy6:
-	++p;
-	{ token = NEWLINE;  break; }
-yy8:
 	yych = *++p;
-	if (yych == '\n') goto yy28;
+	if (yych == '\n') goto yy65;
 	goto yy5;
+yy7:
+	++p;
+yy8:
+	{ token = NEWLINE;  break; }
 yy9:
-	yyaccept = 0;
-	q = ++p;
-	yych = *p;
-	if (yybm[0+yych] & 32) {
-		goto yy9;
-	}
-	if (yych <= '\f') {
-		if (yych == '\n') goto yy6;
-	} else {
-		if (yych <= '\r') goto yy30;
-		if (yych == '#') goto yy32;
-	}
+	++p;
+	if ((yych = *p) == 'u') goto yy60;
+	goto yy27;
+yy10:
+	{ token = IDENT;    break; }
 yy11:
-	{ token = INDENT;   break; }
+	yych = *++p;
+	if (yych == 'o') goto yy56;
+	goto yy27;
 yy12:
-	yyaccept = 1;
-	yych = *(q = ++p);
-	if (yych <= 0x00) goto yy5;
-	goto yy33;
+	yych = *++p;
+	if (yych == 'u') goto yy52;
+	goto yy27;
 yy13:
-	++p;
-	yych = *p;
+	yych = *++p;
+	if (yych == 'e') goto yy45;
+	goto yy27;
 yy14:
-	if (yybm[0+yych] & 64) {
-		goto yy13;
-	}
-	{ token = IDENT;    break; }
+	++p;
+	{ token = EQUALS;   break; }
 yy16:
 	++p;
 	{ token = COLON;    break; }
 yy18:
 	++p;
-	{ token = EQUALS;   break; }
+	if ((yych = *p) == '|') goto yy43;
+	{ token = PIPE;     break; }
 yy20:
 	yych = *++p;
-	if (yych == 'u') goto yy36;
-	goto yy14;
+	if (yych == 'n') goto yy36;
+	goto yy27;
 yy21:
 	yych = *++p;
-	if (yych == 'e') goto yy37;
-	goto yy14;
+	if (yych == 'u') goto yy28;
+	goto yy27;
 yy22:
 	yych = *++p;
-	if (yych == 'n') goto yy38;
-	goto yy14;
+	goto yy27;
 yy23:
-	yych = *++p;
-	if (yych == 'o') goto yy39;
-	goto yy14;
-yy24:
-	yych = *++p;
-	if (yych == 'u') goto yy40;
-	goto yy14;
+	++p;
+	{ token = TEOF;     break; }
 yy25:
 	yych = *++p;
-	if (yych == 'u') goto yy41;
-	goto yy14;
+	goto yy5;
 yy26:
 	++p;
-	if ((yych = *p) == '|') goto yy42;
-	{ token = PIPE;     break; }
+	yych = *p;
+yy27:
+	if (yybm[0+yych] & 32) {
+		goto yy26;
+	}
+	goto yy10;
 yy28:
-	++p;
-	{ token = NEWLINE;  break; }
-yy30:
 	yych = *++p;
-	if (yych == '\n') goto yy28;
-yy31:
-	p = q;
-	if (yyaccept == 0) {
-		goto yy11;
-	} else {
-		goto yy5;
-	}
-yy32:
+	if (yych != 'b') goto yy27;
+	yych = *++p;
+	if (yych != 'n') goto yy27;
+	yych = *++p;
+	if (yych != 'i') goto yy27;
+	yych = *++p;
+	if (yych != 'n') goto yy27;
+	yych = *++p;
+	if (yych != 'j') goto yy27;
+	yych = *++p;
+	if (yych != 'a') goto yy27;
 	++p;
-	yych = *p;
-yy33:
-	if (yybm[0+yych] & 128) {
-		goto yy32;
+	if (yybm[0+(yych = *p)] & 32) {
+		goto yy26;
 	}
-	if (yych <= 0x00) goto yy31;
-	++p;
-	{ continue; }
+	{ token = SUBNINJA; break; }
 yy36:
 	yych = *++p;
-	if (yych == 'i') goto yy44;
-	goto yy14;
-yy37:
-	yych = *++p;
-	if (yych == 'f') goto yy45;
-	goto yy14;
-yy38:
-	yych = *++p;
-	if (yych == 'c') goto yy46;
-	goto yy14;
-yy39:
-	yych = *++p;
-	if (yych == 'o') goto yy47;
-	goto yy14;
-yy40:
-	yych = *++p;
-	if (yych == 'l') goto yy48;
-	goto yy14;
-yy41:
-	yych = *++p;
-	if (yych == 'b') goto yy49;
-	goto yy14;
-yy42:
+	if (yych != 'c') goto yy27;
+	yych = *++p;
+	if (yych != 'l') goto yy27;
+	yych = *++p;
+	if (yych != 'u') goto yy27;
+	yych = *++p;
+	if (yych != 'd') goto yy27;
+	yych = *++p;
+	if (yych != 'e') goto yy27;
+	++p;
+	if (yybm[0+(yych = *p)] & 32) {
+		goto yy26;
+	}
+	{ token = INCLUDE;  break; }
+yy43:
 	++p;
 	{ token = PIPE2;    break; }
-yy44:
-	yych = *++p;
-	if (yych == 'l') goto yy50;
-	goto yy14;
 yy45:
 	yych = *++p;
-	if (yych == 'a') goto yy51;
-	goto yy14;
-yy46:
-	yych = *++p;
-	if (yych == 'l') goto yy52;
-	goto yy14;
-yy47:
-	yych = *++p;
-	if (yych == 'l') goto yy53;
-	goto yy14;
-yy48:
-	yych = *++p;
-	if (yych == 'e') goto yy55;
-	goto yy14;
-yy49:
-	yych = *++p;
-	if (yych == 'n') goto yy57;
-	goto yy14;
-yy50:
-	yych = *++p;
-	if (yych == 'd') goto yy58;
-	goto yy14;
-yy51:
+	if (yych != 'f') goto yy27;
 	yych = *++p;
-	if (yych == 'u') goto yy60;
-	goto yy14;
-yy52:
+	if (yych != 'a') goto yy27;
+	yych = *++p;
+	if (yych != 'u') goto yy27;
+	yych = *++p;
+	if (yych != 'l') goto yy27;
 	yych = *++p;
-	if (yych == 'u') goto yy61;
-	goto yy14;
-yy53:
+	if (yych != 't') goto yy27;
 	++p;
-	if (yybm[0+(yych = *p)] & 64) {
-		goto yy13;
+	if (yybm[0+(yych = *p)] & 32) {
+		goto yy26;
 	}
-	{ token = POOL;     break; }
-yy55:
+	{ token = DEFAULT;  break; }
+yy52:
+	yych = *++p;
+	if (yych != 'l') goto yy27;
+	yych = *++p;
+	if (yych != 'e') goto yy27;
 	++p;
-	if (yybm[0+(yych = *p)] & 64) {
-		goto yy13;
+	if (yybm[0+(yych = *p)] & 32) {
+		goto yy26;
 	}
 	{ token = RULE;     break; }
-yy57:
+yy56:
+	yych = *++p;
+	if (yych != 'o') goto yy27;
 	yych = *++p;
-	if (yych == 'i') goto yy62;
-	goto yy14;
-yy58:
+	if (yych != 'l') goto yy27;
 	++p;
-	if (yybm[0+(yych = *p)] & 64) {
-		goto yy13;
+	if (yybm[0+(yych = *p)] & 32) {
+		goto yy26;
 	}
-	{ token = BUILD;    break; }
+	{ token = POOL;     break; }
 yy60:
 	yych = *++p;
-	if (yych == 'l') goto yy63;
-	goto yy14;
-yy61:
-	yych = *++p;
-	if (yych == 'd') goto yy64;
-	goto yy14;
-yy62:
-	yych = *++p;
-	if (yych == 'n') goto yy65;
-	goto yy14;
-yy63:
-	yych = *++p;
-	if (yych == 't') goto yy66;
-	goto yy14;
-yy64:
+	if (yych != 'i') goto yy27;
 	yych = *++p;
-	if (yych == 'e') goto yy68;
-	goto yy14;
-yy65:
+	if (yych != 'l') goto yy27;
 	yych = *++p;
-	if (yych == 'j') goto yy70;
-	goto yy14;
-yy66:
+	if (yych != 'd') goto yy27;
 	++p;
-	if (yybm[0+(yych = *p)] & 64) {
-		goto yy13;
+	if (yybm[0+(yych = *p)] & 32) {
+		goto yy26;
 	}
-	{ token = DEFAULT;  break; }
-yy68:
+	{ token = BUILD;    break; }
+yy65:
 	++p;
-	if (yybm[0+(yych = *p)] & 64) {
-		goto yy13;
+	{ token = NEWLINE;  break; }
+yy67:
+	++p;
+	yych = *p;
+yy68:
+	if (yybm[0+yych] & 64) {
+		goto yy67;
+	}
+	if (yych >= 0x01) goto yy70;
+yy69:
+	p = q;
+	if (yyaccept <= 0) {
+		goto yy3;
+	} else {
+		goto yy5;
 	}
-	{ token = INCLUDE;  break; }
 yy70:
-	yych = *++p;
-	if (yych != 'a') goto yy14;
 	++p;
-	if (yybm[0+(yych = *p)] & 64) {
-		goto yy13;
+	{ continue; }
+yy72:
+	yyaccept = 0;
+	q = ++p;
+	yych = *p;
+yy73:
+	if (yybm[0+yych] & 128) {
+		goto yy72;
 	}
-	{ token = SUBNINJA; break; }
+	if (yych <= '\f') {
+		if (yych != '\n') goto yy3;
+	} else {
+		if (yych <= '\r') goto yy75;
+		if (yych == '#') goto yy67;
+		goto yy3;
+	}
+	yych = *++p;
+	goto yy8;
+yy75:
+	++p;
+	if ((yych = *p) == '\n') goto yy65;
+	goto yy69;
 }
 
   }
@@ -507,42 +487,49 @@
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 	};
 	yych = *p;
-	if (yybm[0+yych] & 128) {
-		goto yy79;
+	if (yych <= ' ') {
+		if (yych <= 0x00) goto yy82;
+		if (yych <= 0x1F) goto yy84;
+	} else {
+		if (yych == '$') goto yy80;
+		goto yy84;
 	}
-	if (yych <= 0x00) goto yy75;
-	if (yych == '$') goto yy82;
-	goto yy77;
-yy75:
-	++p;
-	{ break; }
-yy77:
-	++p;
-yy78:
-	{ break; }
-yy79:
 	++p;
 	yych = *p;
-	if (yybm[0+yych] & 128) {
-		goto yy79;
-	}
+	goto yy92;
+yy79:
 	{ continue; }
-yy82:
+yy80:
 	yych = *(q = ++p);
-	if (yych == '\n') goto yy83;
-	if (yych == '\r') goto yy85;
-	goto yy78;
-yy83:
+	if (yych == '\n') goto yy85;
+	if (yych == '\r') goto yy87;
+yy81:
+	{ break; }
+yy82:
 	++p;
-	{ continue; }
+	{ break; }
+yy84:
+	yych = *++p;
+	goto yy81;
 yy85:
+	++p;
+	{ continue; }
+yy87:
 	yych = *++p;
-	if (yych == '\n') goto yy87;
+	if (yych == '\n') goto yy89;
 	p = q;
-	goto yy78;
-yy87:
+	goto yy81;
+yy89:
 	++p;
 	{ continue; }
+yy91:
+	++p;
+	yych = *p;
+yy92:
+	if (yybm[0+yych] & 128) {
+		goto yy91;
+	}
+	goto yy79;
 }
 
   }
@@ -550,9 +537,8 @@
 
 bool Lexer::ReadIdent(string* out) {
   const char* p = ofs_;
-  const char* start;
   for (;;) {
-    start = p;
+    const char* start = p;
     
 {
 	unsigned char yych;
@@ -591,28 +577,45 @@
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 	};
 	yych = *p;
-	if (yybm[0+yych] & 128) {
-		goto yy93;
+	if (yych <= '@') {
+		if (yych <= '.') {
+			if (yych <= ',') goto yy97;
+		} else {
+			if (yych <= '/') goto yy97;
+			if (yych >= ':') goto yy97;
+		}
+	} else {
+		if (yych <= '_') {
+			if (yych <= 'Z') goto yy95;
+			if (yych <= '^') goto yy97;
+		} else {
+			if (yych <= '`') goto yy97;
+			if (yych >= '{') goto yy97;
+		}
 	}
+yy95:
 	++p;
+	yych = *p;
+	goto yy100;
+yy96:
 	{
-      last_token_ = start;
-      return false;
+      out->assign(start, p - start);
+      break;
     }
-yy93:
+yy97:
+	++p;
+	{ return false; }
+yy99:
 	++p;
 	yych = *p;
+yy100:
 	if (yybm[0+yych] & 128) {
-		goto yy93;
+		goto yy99;
 	}
-	{
-      out->assign(start, p - start);
-      break;
-    }
+	goto yy96;
 }
 
   }
-  last_token_ = start;
   ofs_ = p;
   EatWhitespace();
   return true;
@@ -628,69 +631,72 @@
 {
 	unsigned char yych;
 	static const unsigned char yybm[] = {
-		  0,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,   0,  16,  16,   0,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 32,  16,  16,  16,   0,  16,  16,  16, 
-		 16,  16,  16,  16,  16, 208, 144,  16, 
-		208, 208, 208, 208, 208, 208, 208, 208, 
-		208, 208,   0,  16,  16,  16,  16,  16, 
-		 16, 208, 208, 208, 208, 208, 208, 208, 
-		208, 208, 208, 208, 208, 208, 208, 208, 
-		208, 208, 208, 208, 208, 208, 208, 208, 
-		208, 208, 208,  16,  16,  16,  16, 208, 
-		 16, 208, 208, 208, 208, 208, 208, 208, 
-		208, 208, 208, 208, 208, 208, 208, 208, 
-		208, 208, 208, 208, 208, 208, 208, 208, 
-		208, 208, 208,  16,   0,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
-		 16,  16,  16,  16,  16,  16,  16,  16, 
+		  0, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128,   0, 128, 128,   0, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		 16, 128, 128, 128,   0, 128, 128, 128, 
+		128, 128, 128, 128, 128, 224, 160, 128, 
+		224, 224, 224, 224, 224, 224, 224, 224, 
+		224, 224,   0, 128, 128, 128, 128, 128, 
+		128, 224, 224, 224, 224, 224, 224, 224, 
+		224, 224, 224, 224, 224, 224, 224, 224, 
+		224, 224, 224, 224, 224, 224, 224, 224, 
+		224, 224, 224, 128, 128, 128, 128, 224, 
+		128, 224, 224, 224, 224, 224, 224, 224, 
+		224, 224, 224, 224, 224, 224, 224, 224, 
+		224, 224, 224, 224, 224, 224, 224, 224, 
+		224, 224, 224, 128,   0, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
+		128, 128, 128, 128, 128, 128, 128, 128, 
 	};
 	yych = *p;
-	if (yybm[0+yych] & 16) {
-		goto yy100;
-	}
-	if (yych <= '\r') {
-		if (yych <= 0x00) goto yy98;
-		if (yych <= '\n') goto yy103;
-		goto yy105;
+	if (yych <= ' ') {
+		if (yych <= '\n') {
+			if (yych <= 0x00) goto yy110;
+			if (yych >= '\n') goto yy107;
+		} else {
+			if (yych == '\r') goto yy105;
+			if (yych >= ' ') goto yy107;
+		}
 	} else {
-		if (yych <= ' ') goto yy103;
-		if (yych <= '$') goto yy107;
-		goto yy103;
+		if (yych <= '9') {
+			if (yych == '$') goto yy109;
+		} else {
+			if (yych <= ':') goto yy107;
+			if (yych == '|') goto yy107;
+		}
 	}
-yy98:
-	++p;
-	{
-      last_token_ = start;
-      return Error("unexpected EOF", err);
-    }
-yy100:
 	++p;
 	yych = *p;
-	if (yybm[0+yych] & 16) {
-		goto yy100;
-	}
+	goto yy140;
+yy104:
 	{
       eval->AddText(StringPiece(start, p - start));
       continue;
     }
-yy103:
+yy105:
+	++p;
+	if ((yych = *p) == '\n') goto yy137;
+	{
+      last_token_ = start;
+      return Error(DescribeLastError(), err);
+    }
+yy107:
 	++p;
 	{
       if (path) {
@@ -703,121 +709,152 @@
         continue;
       }
     }
-yy105:
-	++p;
-	if ((yych = *p) == '\n') goto yy108;
-	{
-      last_token_ = start;
-      return Error(DescribeLastError(), err);
-    }
-yy107:
+yy109:
 	yych = *++p;
-	if (yybm[0+yych] & 64) {
-		goto yy120;
-	}
-	if (yych <= ' ') {
-		if (yych <= '\f') {
-			if (yych == '\n') goto yy112;
-			goto yy110;
+	if (yych <= '-') {
+		if (yych <= 0x1F) {
+			if (yych <= '\n') {
+				if (yych <= '\t') goto yy112;
+				goto yy124;
+			} else {
+				if (yych == '\r') goto yy114;
+				goto yy112;
+			}
 		} else {
-			if (yych <= '\r') goto yy115;
-			if (yych <= 0x1F) goto yy110;
-			goto yy116;
+			if (yych <= '#') {
+				if (yych <= ' ') goto yy115;
+				goto yy112;
+			} else {
+				if (yych <= '$') goto yy117;
+				if (yych <= ',') goto yy112;
+				goto yy119;
+			}
 		}
 	} else {
-		if (yych <= '/') {
-			if (yych == '$') goto yy118;
-			goto yy110;
+		if (yych <= 'Z') {
+			if (yych <= '9') {
+				if (yych <= '/') goto yy112;
+				goto yy119;
+			} else {
+				if (yych <= ':') goto yy121;
+				if (yych <= '@') goto yy112;
+				goto yy119;
+			}
 		} else {
-			if (yych <= ':') goto yy123;
-			if (yych <= '`') goto yy110;
-			if (yych <= '{') goto yy125;
-			goto yy110;
+			if (yych <= '`') {
+				if (yych == '_') goto yy119;
+				goto yy112;
+			} else {
+				if (yych <= 'z') goto yy119;
+				if (yych <= '{') goto yy123;
+				goto yy112;
+			}
 		}
 	}
-yy108:
-	++p;
-	{
-      if (path)
-        p = start;
-      break;
-    }
 yy110:
 	++p;
-yy111:
 	{
       last_token_ = start;
-      return Error("bad $-escape (literal $ must be written as $$)", err);
+      return Error("unexpected EOF", err);
     }
 yy112:
 	++p;
-	yych = *p;
-	if (yybm[0+yych] & 32) {
-		goto yy112;
-	}
+yy113:
 	{
-      continue;
+      last_token_ = start;
+      return Error("bad $-escape (literal $ must be written as $$)", err);
     }
-yy115:
+yy114:
 	yych = *++p;
-	if (yych == '\n') goto yy126;
-	goto yy111;
-yy116:
+	if (yych == '\n') goto yy134;
+	goto yy113;
+yy115:
 	++p;
 	{
       eval->AddText(StringPiece(" ", 1));
       continue;
     }
-yy118:
+yy117:
 	++p;
 	{
       eval->AddText(StringPiece("$", 1));
       continue;
     }
-yy120:
+yy119:
 	++p;
 	yych = *p;
-	if (yybm[0+yych] & 64) {
-		goto yy120;
-	}
+	goto yy133;
+yy120:
 	{
       eval->AddSpecial(StringPiece(start + 1, p - start - 1));
       continue;
     }
-yy123:
+yy121:
 	++p;
 	{
       eval->AddText(StringPiece(":", 1));
       continue;
     }
-yy125:
+yy123:
 	yych = *(q = ++p);
-	if (yybm[0+yych] & 128) {
-		goto yy129;
+	if (yybm[0+yych] & 32) {
+		goto yy127;
 	}
-	goto yy111;
-yy126:
+	goto yy113;
+yy124:
 	++p;
 	yych = *p;
-	if (yych == ' ') goto yy126;
+	if (yybm[0+yych] & 16) {
+		goto yy124;
+	}
 	{
       continue;
     }
-yy129:
+yy127:
 	++p;
 	yych = *p;
-	if (yybm[0+yych] & 128) {
-		goto yy129;
+	if (yybm[0+yych] & 32) {
+		goto yy127;
 	}
-	if (yych == '}') goto yy132;
+	if (yych == '}') goto yy130;
 	p = q;
-	goto yy111;
-yy132:
+	goto yy113;
+yy130:
 	++p;
 	{
       eval->AddSpecial(StringPiece(start + 2, p - start - 3));
       continue;
     }
+yy132:
+	++p;
+	yych = *p;
+yy133:
+	if (yybm[0+yych] & 64) {
+		goto yy132;
+	}
+	goto yy120;
+yy134:
+	++p;
+	yych = *p;
+	if (yych == ' ') goto yy134;
+	{
+      continue;
+    }
+yy137:
+	++p;
+	{
+      if (path)
+        p = start;
+      break;
+    }
+yy139:
+	++p;
+	yych = *p;
+yy140:
+	if (yybm[0+yych] & 128) {
+		goto yy139;
+	}
+	goto yy104;
 }
 
   }
diff -Naur ninja-1.9.0.orig/src/lexer.in.cc ninja/src/lexer.in.cc
--- ninja-1.9.0.orig/src/lexer.in.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/lexer.in.cc	2019-09-24 19:51:29.641632138 +0000
@@ -22,14 +22,14 @@
 bool Lexer::Error(const string& message, string* err) {
   // Compute line/column.
   int line = 1;
-  const char* line_start = input_.str_;
+  const char* context = input_.str_;
   for (const char* p = input_.str_; p < last_token_; ++p) {
     if (*p == '\n') {
       ++line;
-      line_start = p + 1;
+      context = p + 1;
     }
   }
-  int col = last_token_ ? (int)(last_token_ - line_start) : 0;
+  int col = last_token_ ? (int)(last_token_ - context) : 0;
 
   char buf[1024];
   snprintf(buf, sizeof(buf), "%s:%d: ", filename_.AsString().c_str(), line);
@@ -42,12 +42,12 @@
     int len;
     bool truncated = true;
     for (len = 0; len < kTruncateColumn; ++len) {
-      if (line_start[len] == 0 || line_start[len] == '\n') {
+      if (context[len] == 0 || context[len] == '\n') {
         truncated = false;
         break;
       }
     }
-    *err += string(line_start, len);
+    *err += string(context, len);
     if (truncated)
       *err += "...";
     *err += "\n";
@@ -182,21 +182,16 @@
 
 bool Lexer::ReadIdent(string* out) {
   const char* p = ofs_;
-  const char* start;
   for (;;) {
-    start = p;
+    const char* start = p;
     /*!re2c
     varname {
       out->assign(start, p - start);
       break;
     }
-    [^] {
-      last_token_ = start;
-      return false;
-    }
+    [^] { return false; }
     */
   }
-  last_token_ = start;
   ofs_ = p;
   EatWhitespace();
   return true;
diff -Naur ninja-1.9.0.orig/src/line_printer.cc ninja/src/line_printer.cc
--- ninja-1.9.0.orig/src/line_printer.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/line_printer.cc	2019-09-24 19:51:29.642698538 +0000
@@ -18,9 +18,6 @@
 #include <stdlib.h>
 #ifdef _WIN32
 #include <windows.h>
-#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
-#define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x4
-#endif
 #else
 #include <unistd.h>
 #include <sys/ioctl.h>
@@ -44,20 +41,6 @@
   CONSOLE_SCREEN_BUFFER_INFO csbi;
   smart_terminal_ = GetConsoleScreenBufferInfo(console_, &csbi);
 #endif
-  supports_color_ = smart_terminal_;
-  if (!supports_color_) {
-    const char* clicolor_force = getenv("CLICOLOR_FORCE");
-    supports_color_ = clicolor_force && string(clicolor_force) != "0";
-  }
-#ifdef _WIN32
-  // Try enabling ANSI escape sequence support on Windows 10 terminals.
-  if (supports_color_) {
-    DWORD mode;
-    if (GetConsoleMode(console_, &mode)) {
-      SetConsoleMode(console_, mode | ENABLE_VIRTUAL_TERMINAL_PROCESSING);
-    }
-  }
-#endif
 }
 
 void LinePrinter::Print(string to_print, LineType type) {
@@ -99,7 +82,7 @@
     // Limit output to width of the terminal if provided so we don't cause
     // line-wrapping.
     winsize size;
-    if ((ioctl(STDOUT_FILENO, TIOCGWINSZ, &size) == 0) && size.ws_col) {
+    if ((ioctl(0, TIOCGWINSZ, &size) == 0) && size.ws_col) {
       to_print = ElideMiddle(to_print, size.ws_col);
     }
     printf("%s", to_print.c_str());
diff -Naur ninja-1.9.0.orig/src/line_printer.h ninja/src/line_printer.h
--- ninja-1.9.0.orig/src/line_printer.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/line_printer.h	2019-09-24 19:51:29.643495338 +0000
@@ -27,8 +27,6 @@
   bool is_smart_terminal() const { return smart_terminal_; }
   void set_smart_terminal(bool smart) { smart_terminal_ = smart; }
 
-  bool supports_color() const { return supports_color_; }
-
   enum LineType {
     FULL,
     ELIDE
@@ -48,9 +46,6 @@
   /// Whether we can do fancy terminal control codes.
   bool smart_terminal_;
 
-  /// Whether we can use ISO 6429 (ANSI) color sequences.
-  bool supports_color_;
-
   /// Whether the caret is at the beginning of a blank line.
   bool have_blank_line_;
 
diff -Naur ninja-1.9.0.orig/src/manifest_parser.cc ninja/src/manifest_parser.cc
--- ninja-1.9.0.orig/src/manifest_parser.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/manifest_parser.cc	2019-09-24 19:51:29.646982538 +0000
@@ -18,7 +18,6 @@
 #include <stdlib.h>
 #include <vector>
 
-#include "disk_interface.h"
 #include "graph.h"
 #include "metrics.h"
 #include "state.h"
@@ -26,9 +25,9 @@
 #include "version.h"
 
 ManifestParser::ManifestParser(State* state, FileReader* file_reader,
-                               ManifestParserOptions options)
+                               bool dupe_edge_should_err)
     : state_(state), file_reader_(file_reader),
-      options_(options), quiet_(false) {
+      dupe_edge_should_err_(dupe_edge_should_err), quiet_(false) {
   env_ = &state->bindings_;
 }
 
@@ -36,7 +35,7 @@
   METRIC_RECORD(".ninja parse");
   string contents;
   string read_err;
-  if (file_reader_->ReadFile(filename, &contents, &read_err) != FileReader::Okay) {
+  if (!file_reader_->ReadFile(filename, &contents, &read_err)) {
     *err = "loading '" + filename + "': " + read_err;
     if (parent)
       parent->Error(string(*err), err);
@@ -212,7 +211,7 @@
   do {
     string path = eval.Evaluate(env_);
     string path_err;
-    uint64_t slash_bits;  // Unused because this only does lookup.
+    unsigned int slash_bits;  // Unused because this only does lookup.
     if (!CanonicalizePath(&path, &slash_bits, &path_err))
       return lexer_.Error(path_err, err);
     if (!state_->AddDefault(path, &path_err))
@@ -236,32 +235,18 @@
     EvalString out;
     if (!lexer_.ReadPath(&out, err))
       return false;
-    while (!out.empty()) {
+    if (out.empty())
+      return lexer_.Error("expected path", err);
+
+    do {
       outs.push_back(out);
 
       out.Clear();
       if (!lexer_.ReadPath(&out, err))
         return false;
-    }
+    } while (!out.empty());
   }
 
-  // Add all implicit outs, counting how many as we go.
-  int implicit_outs = 0;
-  if (lexer_.PeekToken(Lexer::PIPE)) {
-    for (;;) {
-      EvalString out;
-      if (!lexer_.ReadPath(&out, err))
-        return err;
-      if (out.empty())
-        break;
-      outs.push_back(out);
-      ++implicit_outs;
-    }
-  }
-
-  if (outs.empty())
-    return lexer_.Error("expected path", err);
-
   if (!ExpectToken(Lexer::COLON, err))
     return false;
 
@@ -339,26 +324,22 @@
   }
 
   edge->outputs_.reserve(outs.size());
-  for (size_t i = 0, e = outs.size(); i != e; ++i) {
-    string path = outs[i].Evaluate(env);
+  for (vector<EvalString>::iterator i = outs.begin(); i != outs.end(); ++i) {
+    string path = i->Evaluate(env);
     string path_err;
-    uint64_t slash_bits;
+    unsigned int slash_bits;
     if (!CanonicalizePath(&path, &slash_bits, &path_err))
       return lexer_.Error(path_err, err);
     if (!state_->AddOut(edge, path, slash_bits)) {
-      if (options_.dupe_edge_action_ == kDupeEdgeActionError) {
+      if (dupe_edge_should_err_) {
         lexer_.Error("multiple rules generate " + path + " [-w dupbuild=err]",
                      err);
         return false;
-      } else {
-        if (!quiet_) {
-          Warning("multiple rules generate %s. "
-                  "builds involving this target will not be correct; "
-                  "continuing anyway [-w dupbuild=warn]",
-                  path.c_str());
-        }
-        if (e - i <= static_cast<size_t>(implicit_outs))
-          --implicit_outs;
+      } else if (!quiet_) {
+        Warning("multiple rules generate %s. "
+                "builds involving this target will not be correct; "
+                "continuing anyway [-w dupbuild=warn]",
+                path.c_str());
       }
     }
   }
@@ -369,13 +350,12 @@
     delete edge;
     return true;
   }
-  edge->implicit_outs_ = implicit_outs;
 
   edge->inputs_.reserve(ins.size());
   for (vector<EvalString>::iterator i = ins.begin(); i != ins.end(); ++i) {
     string path = i->Evaluate(env);
     string path_err;
-    uint64_t slash_bits;
+    unsigned int slash_bits;
     if (!CanonicalizePath(&path, &slash_bits, &path_err))
       return lexer_.Error(path_err, err);
     state_->AddIn(edge, path, slash_bits);
@@ -383,25 +363,6 @@
   edge->implicit_deps_ = implicit;
   edge->order_only_deps_ = order_only;
 
-  if (options_.phony_cycle_action_ == kPhonyCycleActionWarn &&
-      edge->maybe_phonycycle_diagnostic()) {
-    // CMake 2.8.12.x and 3.0.x incorrectly write phony build statements
-    // that reference themselves.  Ninja used to tolerate these in the
-    // build graph but that has since been fixed.  Filter them out to
-    // support users of those old CMake versions.
-    Node* out = edge->outputs_[0];
-    vector<Node*>::iterator new_end =
-        remove(edge->inputs_.begin(), edge->inputs_.end(), out);
-    if (new_end != edge->inputs_.end()) {
-      edge->inputs_.erase(new_end, edge->inputs_.end());
-      if (!quiet_) {
-        Warning("phony target '%s' names itself as an input; "
-                "ignoring [-w phonycycle=warn]",
-                out->path().c_str());
-      }
-    }
-  }
-
   // Multiple outputs aren't (yet?) supported with depslog.
   string deps_type = edge->GetBinding("deps");
   if (!deps_type.empty() && edge->outputs_.size() > 1) {
@@ -419,7 +380,7 @@
     return false;
   string path = eval.Evaluate(env_);
 
-  ManifestParser subparser(state_, file_reader_, options_);
+  ManifestParser subparser(state_, file_reader_);
   if (new_scope) {
     subparser.env_ = new BindingEnv(env_);
   } else {
diff -Naur ninja-1.9.0.orig/src/manifest_parser.h ninja/src/manifest_parser.h
--- ninja-1.9.0.orig/src/manifest_parser.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/manifest_parser.h	2019-09-24 19:51:29.647636938 +0000
@@ -23,31 +23,17 @@
 
 struct BindingEnv;
 struct EvalString;
-struct FileReader;
 struct State;
 
-enum DupeEdgeAction {
-  kDupeEdgeActionWarn,
-  kDupeEdgeActionError,
-};
-
-enum PhonyCycleAction {
-  kPhonyCycleActionWarn,
-  kPhonyCycleActionError,
-};
-
-struct ManifestParserOptions {
-  ManifestParserOptions()
-      : dupe_edge_action_(kDupeEdgeActionWarn),
-        phony_cycle_action_(kPhonyCycleActionWarn) {}
-  DupeEdgeAction dupe_edge_action_;
-  PhonyCycleAction phony_cycle_action_;
-};
-
 /// Parses .ninja files.
 struct ManifestParser {
+  struct FileReader {
+    virtual ~FileReader() {}
+    virtual bool ReadFile(const string& path, string* content, string* err) = 0;
+  };
+
   ManifestParser(State* state, FileReader* file_reader,
-                 ManifestParserOptions options = ManifestParserOptions());
+                 bool dupe_edge_should_err = false);
 
   /// Load and parse a file.
   bool Load(const string& filename, string* err, Lexer* parent = NULL);
@@ -80,7 +66,7 @@
   BindingEnv* env_;
   FileReader* file_reader_;
   Lexer lexer_;
-  ManifestParserOptions options_;
+  bool dupe_edge_should_err_;
   bool quiet_;
 };
 
diff -Naur ninja-1.9.0.orig/src/manifest_parser_perftest.cc ninja/src/manifest_parser_perftest.cc
--- ninja-1.9.0.orig/src/manifest_parser_perftest.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/manifest_parser_perftest.cc	2019-09-24 19:51:29.648272138 +0000
@@ -19,7 +19,6 @@
 
 #include <errno.h>
 #include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
 
 #ifdef _WIN32
@@ -37,6 +36,12 @@
 #include "state.h"
 #include "util.h"
 
+struct RealFileReader : public ManifestParser::FileReader {
+  virtual bool ReadFile(const string& path, string* content, string* err) {
+    return ::ReadFile(path, content, err) == 0;
+  }
+};
+
 bool WriteFakeManifests(const string& dir, string* err) {
   RealDiskInterface disk_interface;
   TimeStamp mtime = disk_interface.Stat(dir + "/build.ninja", err);
@@ -54,9 +59,9 @@
 
 int LoadManifests(bool measure_command_evaluation) {
   string err;
-  RealDiskInterface disk_interface;
+  RealFileReader file_reader;
   State state;
-  ManifestParser parser(&state, &disk_interface);
+  ManifestParser parser(&state, &file_reader);
   if (!parser.Load("build.ninja", &err)) {
     fprintf(stderr, "Failed to read test data: %s\n", err.c_str());
     exit(1);
diff -Naur ninja-1.9.0.orig/src/manifest_parser_test.cc ninja/src/manifest_parser_test.cc
--- ninja-1.9.0.orig/src/manifest_parser_test.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/manifest_parser_test.cc	2019-09-24 19:51:29.651252938 +0000
@@ -21,17 +21,30 @@
 #include "state.h"
 #include "test.h"
 
-struct ParserTest : public testing::Test {
+struct ParserTest : public testing::Test,
+                    public ManifestParser::FileReader {
   void AssertParse(const char* input) {
-    ManifestParser parser(&state, &fs_);
+    ManifestParser parser(&state, this);
     string err;
     EXPECT_TRUE(parser.ParseTest(input, &err));
     ASSERT_EQ("", err);
     VerifyGraph(state);
   }
 
+  virtual bool ReadFile(const string& path, string* content, string* err) {
+    files_read_.push_back(path);
+    map<string, string>::iterator i = files_.find(path);
+    if (i == files_.end()) {
+      *err = "No such file or directory";  // Match strerror() for ENOENT.
+      return false;
+    }
+    *content = i->second;
+    return true;
+  }
+
   State state;
-  VirtualFileSystem fs_;
+  map<string, string> files_;
+  vector<string> files_read_;
 };
 
 TEST_F(ParserTest, Empty) {
@@ -358,58 +371,12 @@
 "build out1 out2: cat in1\n"
 "build out1: cat in2\n"
 "build final: cat out1\n";
-  ManifestParserOptions parser_opts;
-  parser_opts.dupe_edge_action_ = kDupeEdgeActionError;
-  ManifestParser parser(&state, &fs_, parser_opts);
+  ManifestParser parser(&state, this, /*dupe_edges_should_err=*/true);
   string err;
   EXPECT_FALSE(parser.ParseTest(kInput, &err));
   EXPECT_EQ("input:5: multiple rules generate out1 [-w dupbuild=err]\n", err);
 }
 
-TEST_F(ParserTest, DuplicateEdgeInIncludedFile) {
-  fs_.Create("sub.ninja",
-    "rule cat\n"
-    "  command = cat $in > $out\n"
-    "build out1 out2: cat in1\n"
-    "build out1: cat in2\n"
-    "build final: cat out1\n");
-  const char kInput[] =
-    "subninja sub.ninja\n";
-  ManifestParserOptions parser_opts;
-  parser_opts.dupe_edge_action_ = kDupeEdgeActionError;
-  ManifestParser parser(&state, &fs_, parser_opts);
-  string err;
-  EXPECT_FALSE(parser.ParseTest(kInput, &err));
-  EXPECT_EQ("sub.ninja:5: multiple rules generate out1 [-w dupbuild=err]\n",
-            err);
-}
-
-TEST_F(ParserTest, PhonySelfReferenceIgnored) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(
-"build a: phony a\n"
-));
-
-  Node* node = state.LookupNode("a");
-  Edge* edge = node->in_edge();
-  ASSERT_TRUE(edge->inputs_.empty());
-}
-
-TEST_F(ParserTest, PhonySelfReferenceKept) {
-  const char kInput[] =
-"build a: phony a\n";
-  ManifestParserOptions parser_opts;
-  parser_opts.phony_cycle_action_ = kPhonyCycleActionError;
-  ManifestParser parser(&state, &fs_, parser_opts);
-  string err;
-  EXPECT_TRUE(parser.ParseTest(kInput, &err));
-  EXPECT_EQ("", err);
-
-  Node* node = state.LookupNode("a");
-  Edge* edge = node->in_edge();
-  ASSERT_EQ(edge->inputs_.size(), 1);
-  ASSERT_EQ(edge->inputs_[0], node);
-}
-
 TEST_F(ParserTest, ReservedWords) {
   ASSERT_NO_FATAL_FAILURE(AssertParse(
 "rule build\n"
@@ -420,8 +387,8 @@
 
 TEST_F(ParserTest, Errors) {
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest(string("subn", 4), &err));
     EXPECT_EQ("input:1: expected '=', got eof\n"
@@ -431,8 +398,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("foobar", &err));
     EXPECT_EQ("input:1: expected '=', got eof\n"
@@ -442,8 +409,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("x 3", &err));
     EXPECT_EQ("input:1: expected '=', got identifier\n"
@@ -453,8 +420,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("x = 3", &err));
     EXPECT_EQ("input:1: unexpected EOF\n"
@@ -464,8 +431,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("x = 3\ny 2", &err));
     EXPECT_EQ("input:2: expected '=', got identifier\n"
@@ -475,8 +442,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("x = $", &err));
     EXPECT_EQ("input:1: bad $-escape (literal $ must be written as $$)\n"
@@ -486,8 +453,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("x = $\n $[\n", &err));
     EXPECT_EQ("input:2: bad $-escape (literal $ must be written as $$)\n"
@@ -497,8 +464,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("x = a$\n b$\n $\n", &err));
     EXPECT_EQ("input:4: unexpected EOF\n"
@@ -506,8 +473,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("build\n", &err));
     EXPECT_EQ("input:1: expected path\n"
@@ -517,30 +484,30 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("build x: y z\n", &err));
     EXPECT_EQ("input:1: unknown build rule 'y'\n"
               "build x: y z\n"
-              "         ^ near here"
+              "       ^ near here"
               , err);
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("build x:: y z\n", &err));
     EXPECT_EQ("input:1: expected build command name\n"
               "build x:: y z\n"
-              "        ^ near here"
+              "       ^ near here"
               , err);
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("rule cat\n  command = cat ok\n"
                                   "build x: cat $\n :\n",
@@ -552,8 +519,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("rule cat\n",
                                   &err));
@@ -561,8 +528,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("rule cat\n"
                                   "  command = echo\n"
@@ -575,8 +542,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("rule cat\n"
                                   "  command = echo\n"
@@ -587,8 +554,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("rule cat\n"
                                   "  command = ${fafsd\n"
@@ -602,8 +569,8 @@
 
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("rule cat\n"
                                   "  command = cat\n"
@@ -617,8 +584,8 @@
 
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("rule cat\n"
                                   "  command = cat\n"
@@ -631,20 +598,17 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("rule %foo\n",
                                   &err));
-    EXPECT_EQ("input:1: expected rule name\n"
-              "rule %foo\n"
-              "     ^ near here",
-              err);
+    EXPECT_EQ("input:1: expected rule name\n", err);
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("rule cc\n"
                                   "  command = foo\n"
@@ -657,8 +621,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("rule cc\n  command = foo\n"
                                   "build $.: cc bar.cc\n",
@@ -670,20 +634,17 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("rule cc\n  command = foo\n  && bar",
                                   &err));
-    EXPECT_EQ("input:3: expected variable name\n"
-              "  && bar\n"
-              "  ^ near here",
-              err);
+    EXPECT_EQ("input:3: expected variable name\n", err);
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("rule cc\n  command = foo\n"
                                   "build $: cc bar.cc\n",
@@ -695,8 +656,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("default\n",
                                   &err));
@@ -707,8 +668,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("default nonexistent\n",
                                   &err));
@@ -719,8 +680,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("rule r\n  command = r\n"
                                   "build b: r\n"
@@ -733,8 +694,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("default $a\n", &err));
     EXPECT_EQ("input:1: empty path\n"
@@ -744,8 +705,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("rule r\n"
                                   "  command = r\n"
@@ -756,8 +717,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     // the indented blank line must terminate the rule
     // this also verifies that "unexpected (token)" errors are correct
@@ -769,26 +730,24 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("pool\n", &err));
-    EXPECT_EQ("input:1: expected pool name\n"
-              "pool\n"
-              "    ^ near here", err);
+    EXPECT_EQ("input:1: expected pool name\n", err);
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("pool foo\n", &err));
     EXPECT_EQ("input:2: expected 'depth =' line\n", err);
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("pool foo\n"
                                   "  depth = 4\n"
@@ -800,8 +759,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("pool foo\n"
                                   "  depth = -1\n", &err));
@@ -812,8 +771,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     EXPECT_FALSE(parser.ParseTest("pool foo\n"
                                   "  bar = 1\n", &err));
@@ -824,8 +783,8 @@
   }
 
   {
-    State local_state;
-    ManifestParser parser(&local_state, NULL);
+    State state;
+    ManifestParser parser(&state, NULL);
     string err;
     // Pool names are dereferenced at edge parsing time.
     EXPECT_FALSE(parser.ParseTest("rule run\n"
@@ -837,16 +796,16 @@
 }
 
 TEST_F(ParserTest, MissingInput) {
-  State local_state;
-  ManifestParser parser(&local_state, &fs_);
+  State state;
+  ManifestParser parser(&state, this);
   string err;
   EXPECT_FALSE(parser.Load("build.ninja", &err));
   EXPECT_EQ("loading 'build.ninja': No such file or directory", err);
 }
 
 TEST_F(ParserTest, MultipleOutputs) {
-  State local_state;
-  ManifestParser parser(&local_state, NULL);
+  State state;
+  ManifestParser parser(&state, NULL);
   string err;
   EXPECT_TRUE(parser.ParseTest("rule cc\n  command = foo\n  depfile = bar\n"
                                "build a.o b.o: cc c.cc\n",
@@ -855,8 +814,8 @@
 }
 
 TEST_F(ParserTest, MultipleOutputsWithDeps) {
-  State local_state;
-  ManifestParser parser(&local_state, NULL);
+  State state;
+  ManifestParser parser(&state, NULL);
   string err;
   EXPECT_FALSE(parser.ParseTest("rule cc\n  command = foo\n  deps = gcc\n"
                                "build a.o b.o: cc c.cc\n",
@@ -866,9 +825,9 @@
 }
 
 TEST_F(ParserTest, SubNinja) {
-  fs_.Create("test.ninja",
+  files_["test.ninja"] =
     "var = inner\n"
-    "build $builddir/inner: varref\n");
+    "build $builddir/inner: varref\n";
   ASSERT_NO_FATAL_FAILURE(AssertParse(
 "builddir = some_dir/\n"
 "rule varref\n"
@@ -877,9 +836,9 @@
 "build $builddir/outer: varref\n"
 "subninja test.ninja\n"
 "build $builddir/outer2: varref\n"));
-  ASSERT_EQ(1u, fs_.files_read_.size());
+  ASSERT_EQ(1u, files_read_.size());
 
-  EXPECT_EQ("test.ninja", fs_.files_read_[0]);
+  EXPECT_EQ("test.ninja", files_read_[0]);
   EXPECT_TRUE(state.LookupNode("some_dir/outer"));
   // Verify our builddir setting is inherited.
   EXPECT_TRUE(state.LookupNode("some_dir/inner"));
@@ -891,7 +850,7 @@
 }
 
 TEST_F(ParserTest, MissingSubNinja) {
-  ManifestParser parser(&state, &fs_);
+  ManifestParser parser(&state, this);
   string err;
   EXPECT_FALSE(parser.ParseTest("subninja foo.ninja\n", &err));
   EXPECT_EQ("input:1: loading 'foo.ninja': No such file or directory\n"
@@ -902,9 +861,9 @@
 
 TEST_F(ParserTest, DuplicateRuleInDifferentSubninjas) {
   // Test that rules are scoped to subninjas.
-  fs_.Create("test.ninja", "rule cat\n"
-                         "  command = cat\n");
-  ManifestParser parser(&state, &fs_);
+  files_["test.ninja"] = "rule cat\n"
+                         "  command = cat\n";
+  ManifestParser parser(&state, this);
   string err;
   EXPECT_TRUE(parser.ParseTest("rule cat\n"
                                 "  command = cat\n"
@@ -913,11 +872,11 @@
 
 TEST_F(ParserTest, DuplicateRuleInDifferentSubninjasWithInclude) {
   // Test that rules are scoped to subninjas even with includes.
-  fs_.Create("rules.ninja", "rule cat\n"
-                         "  command = cat\n");
-  fs_.Create("test.ninja", "include rules.ninja\n"
-                         "build x : cat\n");
-  ManifestParser parser(&state, &fs_);
+  files_["rules.ninja"] = "rule cat\n"
+                         "  command = cat\n";
+  files_["test.ninja"] = "include rules.ninja\n"
+                         "build x : cat\n";
+  ManifestParser parser(&state, this);
   string err;
   EXPECT_TRUE(parser.ParseTest("include rules.ninja\n"
                                 "subninja test.ninja\n"
@@ -925,19 +884,19 @@
 }
 
 TEST_F(ParserTest, Include) {
-  fs_.Create("include.ninja", "var = inner\n");
+  files_["include.ninja"] = "var = inner\n";
   ASSERT_NO_FATAL_FAILURE(AssertParse(
 "var = outer\n"
 "include include.ninja\n"));
 
-  ASSERT_EQ(1u, fs_.files_read_.size());
-  EXPECT_EQ("include.ninja", fs_.files_read_[0]);
+  ASSERT_EQ(1u, files_read_.size());
+  EXPECT_EQ("include.ninja", files_read_[0]);
   EXPECT_EQ("inner", state.bindings_.LookupVariable("var"));
 }
 
 TEST_F(ParserTest, BrokenInclude) {
-  fs_.Create("include.ninja", "build\n");
-  ManifestParser parser(&state, &fs_);
+  files_["include.ninja"] = "build\n";
+  ManifestParser parser(&state, this);
   string err;
   EXPECT_FALSE(parser.ParseTest("include include.ninja\n", &err));
   EXPECT_EQ("include.ninja:1: expected path\n"
@@ -965,61 +924,6 @@
   ASSERT_TRUE(edge->is_order_only(1));
 }
 
-TEST_F(ParserTest, ImplicitOutput) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(
-"rule cat\n"
-"  command = cat $in > $out\n"
-"build foo | imp: cat bar\n"));
-
-  Edge* edge = state.LookupNode("imp")->in_edge();
-  ASSERT_EQ(edge->outputs_.size(), 2);
-  EXPECT_TRUE(edge->is_implicit_out(1));
-}
-
-TEST_F(ParserTest, ImplicitOutputEmpty) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(
-"rule cat\n"
-"  command = cat $in > $out\n"
-"build foo | : cat bar\n"));
-
-  Edge* edge = state.LookupNode("foo")->in_edge();
-  ASSERT_EQ(edge->outputs_.size(), 1);
-  EXPECT_FALSE(edge->is_implicit_out(0));
-}
-
-TEST_F(ParserTest, ImplicitOutputDupe) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(
-"rule cat\n"
-"  command = cat $in > $out\n"
-"build foo baz | foo baq foo: cat bar\n"));
-
-  Edge* edge = state.LookupNode("foo")->in_edge();
-  ASSERT_EQ(edge->outputs_.size(), 3);
-  EXPECT_FALSE(edge->is_implicit_out(0));
-  EXPECT_FALSE(edge->is_implicit_out(1));
-  EXPECT_TRUE(edge->is_implicit_out(2));
-}
-
-TEST_F(ParserTest, ImplicitOutputDupes) {
-  ASSERT_NO_FATAL_FAILURE(AssertParse(
-"rule cat\n"
-"  command = cat $in > $out\n"
-"build foo foo foo | foo foo foo foo: cat bar\n"));
-
-  Edge* edge = state.LookupNode("foo")->in_edge();
-  ASSERT_EQ(edge->outputs_.size(), 1);
-  EXPECT_FALSE(edge->is_implicit_out(0));
-}
-
-TEST_F(ParserTest, NoExplicitOutput) {
-  ManifestParser parser(&state, NULL);
-  string err;
-  EXPECT_TRUE(parser.ParseTest(
-"rule cat\n"
-"  command = cat $in > $out\n"
-"build | imp : cat bar\n", &err));
-}
-
 TEST_F(ParserTest, DefaultDefault) {
   ASSERT_NO_FATAL_FAILURE(AssertParse(
 "rule cat\n  command = cat $in > $out\n"
@@ -1071,8 +975,8 @@
 }
 
 TEST_F(ParserTest, CRLF) {
-  State local_state;
-  ManifestParser parser(&local_state, NULL);
+  State state;
+  ManifestParser parser(&state, NULL);
   string err;
 
   EXPECT_TRUE(parser.ParseTest("# comment with crlf\r\n", &err));
diff -Naur ninja-1.9.0.orig/src/minidump-win32.cc ninja/src/minidump-win32.cc
--- ninja-1.9.0.orig/src/minidump-win32.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/minidump-win32.cc	2019-09-24 19:51:29.652001738 +0000
@@ -32,17 +32,17 @@
 /// Creates a windows minidump in temp folder.
 void CreateWin32MiniDump(_EXCEPTION_POINTERS* pep) {
   char temp_path[MAX_PATH];
-  GetTempPathA(sizeof(temp_path), temp_path);
+  GetTempPath(sizeof(temp_path), temp_path);
   char temp_file[MAX_PATH];
-  sprintf(temp_file, "%s\\ninja_crash_dump_%lu.dmp",
+  sprintf(temp_file, "%s\\ninja_crash_dump_%d.dmp",
           temp_path, GetCurrentProcessId());
 
   // Delete any previous minidump of the same name.
-  DeleteFileA(temp_file);
+  DeleteFile(temp_file);
 
   // Load DbgHelp.dll dynamically, as library is not present on all
   // Windows versions.
-  HMODULE dbghelp = LoadLibraryA("dbghelp.dll");
+  HMODULE dbghelp = LoadLibrary("dbghelp.dll");
   if (dbghelp == NULL) {
     Error("failed to create minidump: LoadLibrary('dbghelp.dll'): %s",
           GetLastErrorString().c_str());
diff -Naur ninja-1.9.0.orig/src/msvc_helper-win32.cc ninja/src/msvc_helper-win32.cc
--- ninja-1.9.0.orig/src/msvc_helper-win32.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/msvc_helper-win32.cc	2019-09-24 19:51:29.653283338 +0000
@@ -14,12 +14,22 @@
 
 #include "msvc_helper.h"
 
+#include <algorithm>
+#include <stdio.h>
+#include <string.h>
 #include <windows.h>
 
+#include "includes_normalize.h"
 #include "util.h"
 
 namespace {
 
+/// Return true if \a input ends with \a needle.
+bool EndsWith(const string& input, const string& needle) {
+  return (input.size() >= needle.size() &&
+          input.substr(input.size() - needle.size()) == needle);
+}
+
 string Replace(const string& input, const string& find, const string& replace) {
   string result = input;
   size_t start_pos = 0;
@@ -37,16 +47,86 @@
   return Replace(path, " ", "\\ ");
 }
 
+// static
+string CLParser::FilterShowIncludes(const string& line,
+                                    const string& deps_prefix) {
+  const string kDepsPrefixEnglish = "Note: including file: ";
+  const char* in = line.c_str();
+  const char* end = in + line.size();
+  const string& prefix = deps_prefix.empty() ? kDepsPrefixEnglish : deps_prefix;
+  if (end - in > (int)prefix.size() &&
+      memcmp(in, prefix.c_str(), (int)prefix.size()) == 0) {
+    in += prefix.size();
+    while (*in == ' ')
+      ++in;
+    return line.substr(in - line.c_str());
+  }
+  return "";
+}
+
+// static
+bool CLParser::IsSystemInclude(string path) {
+  transform(path.begin(), path.end(), path.begin(), ::tolower);
+  // TODO: this is a heuristic, perhaps there's a better way?
+  return (path.find("program files") != string::npos ||
+          path.find("microsoft visual studio") != string::npos);
+}
+
+// static
+bool CLParser::FilterInputFilename(string line) {
+  transform(line.begin(), line.end(), line.begin(), ::tolower);
+  // TODO: other extensions, like .asm?
+  return EndsWith(line, ".c") ||
+      EndsWith(line, ".cc") ||
+      EndsWith(line, ".cxx") ||
+      EndsWith(line, ".cpp");
+}
+
+string CLParser::Parse(const string& output, const string& deps_prefix) {
+  string filtered_output;
+
+  // Loop over all lines in the output to process them.
+  size_t start = 0;
+  while (start < output.size()) {
+    size_t end = output.find_first_of("\r\n", start);
+    if (end == string::npos)
+      end = output.size();
+    string line = output.substr(start, end - start);
+
+    string include = FilterShowIncludes(line, deps_prefix);
+    if (!include.empty()) {
+      include = IncludesNormalize::Normalize(include, NULL);
+      if (!IsSystemInclude(include))
+        includes_.insert(include);
+    } else if (FilterInputFilename(line)) {
+      // Drop it.
+      // TODO: if we support compiling multiple output files in a single
+      // cl.exe invocation, we should stash the filename.
+    } else {
+      filtered_output.append(line);
+      filtered_output.append("\n");
+    }
+
+    if (end < output.size() && output[end] == '\r')
+      ++end;
+    if (end < output.size() && output[end] == '\n')
+      ++end;
+    start = end;
+  }
+
+  return filtered_output;
+}
+
 int CLWrapper::Run(const string& command, string* output) {
   SECURITY_ATTRIBUTES security_attributes = {};
   security_attributes.nLength = sizeof(SECURITY_ATTRIBUTES);
   security_attributes.bInheritHandle = TRUE;
 
   // Must be inheritable so subprocesses can dup to children.
-  HANDLE nul =
-      CreateFileA("NUL", GENERIC_READ,
-                  FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
-                  &security_attributes, OPEN_EXISTING, 0, NULL);
+  HANDLE nul = CreateFile("NUL", GENERIC_READ,
+                          FILE_SHARE_READ | FILE_SHARE_WRITE |
+                          FILE_SHARE_DELETE,
+                          &security_attributes, OPEN_EXISTING, 0, NULL);
   if (nul == INVALID_HANDLE_VALUE)
     Fatal("couldn't open nul");
 
@@ -58,8 +138,8 @@
     Win32Fatal("SetHandleInformation");
 
   PROCESS_INFORMATION process_info = {};
-  STARTUPINFOA startup_info = {};
-  startup_info.cb = sizeof(STARTUPINFOA);
+  STARTUPINFO startup_info = {};
+  startup_info.cb = sizeof(STARTUPINFO);
   startup_info.hStdInput = nul;
   startup_info.hStdError = ::GetStdHandle(STD_ERROR_HANDLE);
   startup_info.hStdOutput = stdout_write;
diff -Naur ninja-1.9.0.orig/src/msvc_helper.h ninja/src/msvc_helper.h
--- ninja-1.9.0.orig/src/msvc_helper.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/msvc_helper.h	2019-09-24 19:51:29.654256138 +0000
@@ -13,10 +13,40 @@
 // limitations under the License.
 
 #include <string>
+#include <set>
+#include <vector>
 using namespace std;
 
 string EscapeForDepfile(const string& path);
 
+/// Visual Studio's cl.exe requires some massaging to work with Ninja;
+/// for example, it emits include information on stderr in a funny
+/// format when building with /showIncludes.  This class parses this
+/// output.
+struct CLParser {
+  /// Parse a line of cl.exe output and extract /showIncludes info.
+  /// If a dependency is extracted, returns a nonempty string.
+  /// Exposed for testing.
+  static string FilterShowIncludes(const string& line,
+                                   const string& deps_prefix);
+
+  /// Return true if a mentioned include file is a system path.
+  /// Filtering these out reduces dependency information considerably.
+  static bool IsSystemInclude(string path);
+
+  /// Parse a line of cl.exe output and return true if it looks like
+  /// it's printing an input filename.  This is a heuristic but it appears
+  /// to be the best we can do.
+  /// Exposed for testing.
+  static bool FilterInputFilename(string line);
+
+  /// Parse the full output of cl, returning the output (if any) that
+  /// should printed.
+  string Parse(const string& output, const string& deps_prefix);
+
+  set<string> includes_;
+};
+
 /// Wraps a synchronous execution of a CL subprocess.
 struct CLWrapper {
   CLWrapper() : env_block_(NULL) {}
diff -Naur ninja-1.9.0.orig/src/msvc_helper_main-win32.cc ninja/src/msvc_helper_main-win32.cc
--- ninja-1.9.0.orig/src/msvc_helper_main-win32.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/msvc_helper_main-win32.cc	2019-09-24 19:51:29.655434538 +0000
@@ -19,7 +19,6 @@
 #include <stdio.h>
 #include <windows.h>
 
-#include "clparser.h"
 #include "util.h"
 
 #include "getopt.h"
@@ -113,7 +112,7 @@
     PushPathIntoEnvironment(env);
   }
 
-  char* command = GetCommandLineA();
+  char* command = GetCommandLine();
   command = strstr(command, " -- ");
   if (!command) {
     Fatal("expected command line to end with \" -- command args\"");
@@ -128,9 +127,7 @@
 
   if (output_filename) {
     CLParser parser;
-    string err;
-    if (!parser.Parse(output, deps_prefix, &output, &err))
-      Fatal("%s\n", err.c_str());
+    output = parser.Parse(output, deps_prefix);
     WriteDepFileOrDie(output_filename, parser);
   }
 
diff -Naur ninja-1.9.0.orig/src/msvc_helper_test.cc ninja/src/msvc_helper_test.cc
--- ninja-1.9.0.orig/src/msvc_helper_test.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/msvc_helper_test.cc	2019-09-24 19:51:29.656432938 +0000
@@ -17,7 +17,94 @@
 #include "test.h"
 #include "util.h"
 
-TEST(EscapeForDepfileTest, SpacesInFilename) {
+TEST(CLParserTest, ShowIncludes) {
+  ASSERT_EQ("", CLParser::FilterShowIncludes("", ""));
+
+  ASSERT_EQ("", CLParser::FilterShowIncludes("Sample compiler output", ""));
+  ASSERT_EQ("c:\\Some Files\\foobar.h",
+            CLParser::FilterShowIncludes("Note: including file: "
+                                         "c:\\Some Files\\foobar.h", ""));
+  ASSERT_EQ("c:\\initspaces.h",
+            CLParser::FilterShowIncludes("Note: including file:    "
+                                         "c:\\initspaces.h", ""));
+  ASSERT_EQ("c:\\initspaces.h",
+            CLParser::FilterShowIncludes("Non-default prefix: inc file:    "
+                                         "c:\\initspaces.h",
+                    "Non-default prefix: inc file:"));
+}
+
+TEST(CLParserTest, FilterInputFilename) {
+  ASSERT_TRUE(CLParser::FilterInputFilename("foobar.cc"));
+  ASSERT_TRUE(CLParser::FilterInputFilename("foo bar.cc"));
+  ASSERT_TRUE(CLParser::FilterInputFilename("baz.c"));
+  ASSERT_TRUE(CLParser::FilterInputFilename("FOOBAR.CC"));
+
+  ASSERT_FALSE(CLParser::FilterInputFilename(
+                   "src\\cl_helper.cc(166) : fatal error C1075: end "
+                   "of file found ..."));
+}
+
+TEST(CLParserTest, ParseSimple) {
+  CLParser parser;
+  string output = parser.Parse(
+      "foo\r\n"
+      "Note: inc file prefix:  foo.h\r\n"
+      "bar\r\n",
+      "Note: inc file prefix:");
+
+  ASSERT_EQ("foo\nbar\n", output);
+  ASSERT_EQ(1u, parser.includes_.size());
+  ASSERT_EQ("foo.h", *parser.includes_.begin());
+}
+
+TEST(CLParserTest, ParseFilenameFilter) {
+  CLParser parser;
+  string output = parser.Parse(
+      "foo.cc\r\n"
+      "cl: warning\r\n",
+      "");
+  ASSERT_EQ("cl: warning\n", output);
+}
+
+TEST(CLParserTest, ParseSystemInclude) {
+  CLParser parser;
+  string output = parser.Parse(
+      "Note: including file: c:\\Program Files\\foo.h\r\n"
+      "Note: including file: d:\\Microsoft Visual Studio\\bar.h\r\n"
+      "Note: including file: path.h\r\n",
+      "");
+  // We should have dropped the first two includes because they look like
+  // system headers.
+  ASSERT_EQ("", output);
+  ASSERT_EQ(1u, parser.includes_.size());
+  ASSERT_EQ("path.h", *parser.includes_.begin());
+}
+
+TEST(CLParserTest, DuplicatedHeader) {
+  CLParser parser;
+  string output = parser.Parse(
+      "Note: including file: foo.h\r\n"
+      "Note: including file: bar.h\r\n"
+      "Note: including file: foo.h\r\n",
+      "");
+  // We should have dropped one copy of foo.h.
+  ASSERT_EQ("", output);
+  ASSERT_EQ(2u, parser.includes_.size());
+}
+
+TEST(CLParserTest, DuplicatedHeaderPathConverted) {
+  CLParser parser;
+  string output = parser.Parse(
+      "Note: including file: sub/foo.h\r\n"
+      "Note: including file: bar.h\r\n"
+      "Note: including file: sub\\foo.h\r\n",
+      "");
+  // We should have dropped one copy of foo.h.
+  ASSERT_EQ("", output);
+  ASSERT_EQ(2u, parser.includes_.size());
+}
+
+TEST(CLParserTest, SpacesInFilename) {
   ASSERT_EQ("sub\\some\\ sdk\\foo.h",
             EscapeForDepfile("sub\\some sdk\\foo.h"));
 }
diff -Naur ninja-1.9.0.orig/src/ninja.cc ninja/src/ninja.cc
--- ninja-1.9.0.orig/src/ninja.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/ninja.cc	2019-09-24 19:51:29.661400938 +0000
@@ -22,9 +22,6 @@
 #include "getopt.h"
 #include <direct.h>
 #include <windows.h>
-#elif defined(_AIX)
-#include "getopt.h"
-#include <unistd.h>
 #else
 #include <getopt.h>
 #include <unistd.h>
@@ -70,13 +67,6 @@
 
   /// Whether duplicate rules for one target should warn or print an error.
   bool dupe_edges_should_err;
-
-  /// Whether phony cycles should warn or print an error.
-  bool phony_cycle_should_err;
-
-  /// Whether a depfile with multiple targets on separate lines should
-  /// warn or print an error.
-  bool depfile_distinct_target_lines_should_err;
 };
 
 /// The Ninja main() loads up a series of data structures; various tools need
@@ -104,7 +94,7 @@
   DepsLog deps_log_;
 
   /// The type of functions that are the entry points to tools (subcommands).
-  typedef int (NinjaMain::*ToolFunc)(const Options*, int, char**);
+  typedef int (NinjaMain::*ToolFunc)(int, char**);
 
   /// Get the Node for a given command-line path, handling features like
   /// spell correction.
@@ -115,17 +105,17 @@
                               vector<Node*>* targets, string* err);
 
   // The various subcommands, run via "-t XXX".
-  int ToolGraph(const Options* options, int argc, char* argv[]);
-  int ToolQuery(const Options* options, int argc, char* argv[]);
-  int ToolDeps(const Options* options, int argc, char* argv[]);
-  int ToolBrowse(const Options* options, int argc, char* argv[]);
-  int ToolMSVC(const Options* options, int argc, char* argv[]);
-  int ToolTargets(const Options* options, int argc, char* argv[]);
-  int ToolCommands(const Options* options, int argc, char* argv[]);
-  int ToolClean(const Options* options, int argc, char* argv[]);
-  int ToolCompilationDatabase(const Options* options, int argc, char* argv[]);
-  int ToolRecompact(const Options* options, int argc, char* argv[]);
-  int ToolUrtle(const Options* options, int argc, char** argv);
+  int ToolGraph(int argc, char* argv[]);
+  int ToolQuery(int argc, char* argv[]);
+  int ToolDeps(int argc, char* argv[]);
+  int ToolBrowse(int argc, char* argv[]);
+  int ToolMSVC(int argc, char* argv[]);
+  int ToolTargets(int argc, char* argv[]);
+  int ToolCommands(int argc, char* argv[]);
+  int ToolClean(int argc, char* argv[]);
+  int ToolCompilationDatabase(int argc, char* argv[]);
+  int ToolRecompact(int argc, char* argv[]);
+  int ToolUrtle(int argc, char** argv);
 
   /// Open the build log.
   /// @return false on error.
@@ -158,7 +148,7 @@
     // Just checking n isn't enough: If an old output is both in the build log
     // and in the deps log, it will have a Node object in state_.  (It will also
     // have an in edge if one of its inputs is another output that's in the deps
-    // log, but having a deps edge product an output that's input to another deps
+    // log, but having a deps edge product an output thats input to another deps
     // edge is rare, and the first recompaction will delete all old outputs from
     // the deps log, and then a second recompaction will clear the build log,
     // which seems good enough for this corner case.)
@@ -205,21 +195,21 @@
 "if targets are unspecified, builds the 'default' target (see manual).\n"
 "\n"
 "options:\n"
-"  --version      print ninja version (\"%s\")\n"
-"  -v, --verbose  show all command lines while building\n"
+"  --version  print ninja version (\"%s\")\n"
 "\n"
 "  -C DIR   change to DIR before doing anything else\n"
 "  -f FILE  specify input build file [default=build.ninja]\n"
 "\n"
-"  -j N     run N jobs in parallel (0 means infinity) [default=%d on this system]\n"
-"  -k N     keep going until N jobs fail (0 means infinity) [default=1]\n"
+"  -j N     run N jobs in parallel [default=%d, derived from CPUs available]\n"
+"  -k N     keep going until N jobs fail [default=1]\n"
 "  -l N     do not start new jobs if the load average is greater than N\n"
 "  -n       dry run (don't run commands but act like they succeeded)\n"
+"  -v       show all command lines while building\n"
 "\n"
-"  -d MODE  enable debugging (use '-d list' to list modes)\n"
-"  -t TOOL  run a subtool (use '-t list' to list subtools)\n"
+"  -d MODE  enable debugging (use -d list to list modes)\n"
+"  -t TOOL  run a subtool (use -t list to list subtools)\n"
 "    terminates toplevel options; further flags are passed to the tool\n"
-"  -w FLAG  adjust warnings (use '-w list' to list warnings)\n",
+"  -w FLAG  adjust warnings (use -w list to list warnings)\n",
           kNinjaVersion, config.parallelism);
 }
 
@@ -236,11 +226,19 @@
   }
 }
 
+/// An implementation of ManifestParser::FileReader that actually reads
+/// the file.
+struct RealFileReader : public ManifestParser::FileReader {
+  virtual bool ReadFile(const string& path, string* content, string* err) {
+    return ::ReadFile(path, content, err) == 0;
+  }
+};
+
 /// Rebuild the build manifest, if necessary.
 /// Returns true if the manifest was rebuilt.
 bool NinjaMain::RebuildManifest(const char* input_file, string* err) {
   string path = input_file;
-  uint64_t slash_bits;  // Unused because this path is only used for lookup.
+  unsigned int slash_bits;  // Unused because this path is only used for lookup.
   if (!CanonicalizePath(&path, &slash_bits, err))
     return false;
   Node* node = state_.LookupNode(path);
@@ -254,24 +252,15 @@
   if (builder.AlreadyUpToDate())
     return false;  // Not an error, but we didn't rebuild.
 
-  if (!builder.Build(err))
-    return false;
-
-  // The manifest was only rebuilt if it is now dirty (it may have been cleaned
-  // by a restat).
-  if (!node->dirty()) {
-    // Reset the state to prevent problems like
-    // https://github.com/ninja-build/ninja/issues/874
-    state_.Reset();
-    return false;
-  }
-
-  return true;
+  // Even if the manifest was cleaned by a restat rule, claim that it was
+  // rebuilt.  Not doing so can lead to crashes, see
+  // https://github.com/martine/ninja/issues/874
+  return builder.Build(err);
 }
 
 Node* NinjaMain::CollectTarget(const char* cpath, string* err) {
   string path = cpath;
-  uint64_t slash_bits;
+  unsigned int slash_bits;  // Unused because this path is only used for lookup.
   if (!CanonicalizePath(&path, &slash_bits, err))
     return NULL;
 
@@ -298,8 +287,8 @@
     }
     return node;
   } else {
-    *err =
-        "unknown target '" + Node::PathDecanonicalized(path, slash_bits) + "'";
+    *err = "unknown target '" + path + "'";
+
     if (path == "clean") {
       *err += ", did you mean 'ninja -t clean'?";
     } else if (path == "help") {
@@ -330,7 +319,7 @@
   return true;
 }
 
-int NinjaMain::ToolGraph(const Options* options, int argc, char* argv[]) {
+int NinjaMain::ToolGraph(int argc, char* argv[]) {
   vector<Node*> nodes;
   string err;
   if (!CollectTargetsFromArgs(argc, argv, &nodes, &err)) {
@@ -347,7 +336,7 @@
   return 0;
 }
 
-int NinjaMain::ToolQuery(const Options* options, int argc, char* argv[]) {
+int NinjaMain::ToolQuery(int argc, char* argv[]) {
   if (argc == 0) {
     Error("expected a target to query");
     return 1;
@@ -386,20 +375,19 @@
 }
 
 #if defined(NINJA_HAVE_BROWSE)
-int NinjaMain::ToolBrowse(const Options* options, int argc, char* argv[]) {
-  RunBrowsePython(&state_, ninja_command_, options->input_file, argc, argv);
+int NinjaMain::ToolBrowse(int argc, char* argv[]) {
+  if (argc < 1) {
+    Error("expected a target to browse");
+    return 1;
+  }
+  RunBrowsePython(&state_, ninja_command_, argv[0]);
   // If we get here, the browse failed.
   return 1;
 }
-#else
-int NinjaMain::ToolBrowse(const Options*, int, char**) {
-  Fatal("browse tool not supported on this platform");
-  return 1;
-}
-#endif
+#endif  // _WIN32
 
 #if defined(_MSC_VER)
-int NinjaMain::ToolMSVC(const Options* options, int argc, char* argv[]) {
+int NinjaMain::ToolMSVC(int argc, char* argv[]) {
   // Reset getopt: push one argument onto the front of argv, reset optind.
   argc++;
   argv--;
@@ -474,7 +462,7 @@
   return 0;
 }
 
-int NinjaMain::ToolDeps(const Options* options, int argc, char** argv) {
+int NinjaMain::ToolDeps(int argc, char** argv) {
   vector<Node*> nodes;
   if (argc == 0) {
     for (vector<Node*>::const_iterator ni = deps_log_.nodes().begin();
@@ -503,7 +491,7 @@
     TimeStamp mtime = disk_interface.Stat((*it)->path(), &err);
     if (mtime == -1)
       Error("%s", err.c_str());  // Log and ignore Stat() errors;
-    printf("%s: #deps %d, deps mtime %" PRId64 " (%s)\n",
+    printf("%s: #deps %d, deps mtime %d (%s)\n",
            (*it)->path().c_str(), deps->node_count, deps->mtime,
            (!mtime || mtime > deps->mtime ? "STALE":"VALID"));
     for (int i = 0; i < deps->node_count; ++i)
@@ -514,7 +502,7 @@
   return 0;
 }
 
-int NinjaMain::ToolTargets(const Options* options, int argc, char* argv[]) {
+int NinjaMain::ToolTargets(int argc, char* argv[]) {
   int depth = 1;
   if (argc >= 1) {
     string mode = argv[0];
@@ -554,51 +542,21 @@
   }
 }
 
-enum PrintCommandMode { PCM_Single, PCM_All };
-void PrintCommands(Edge* edge, set<Edge*>* seen, PrintCommandMode mode) {
+void PrintCommands(Edge* edge, set<Edge*>* seen) {
   if (!edge)
     return;
   if (!seen->insert(edge).second)
     return;
 
-  if (mode == PCM_All) {
-    for (vector<Node*>::iterator in = edge->inputs_.begin();
-         in != edge->inputs_.end(); ++in)
-      PrintCommands((*in)->in_edge(), seen, mode);
-  }
+  for (vector<Node*>::iterator in = edge->inputs_.begin();
+       in != edge->inputs_.end(); ++in)
+    PrintCommands((*in)->in_edge(), seen);
 
   if (!edge->is_phony())
     puts(edge->EvaluateCommand().c_str());
 }
 
-int NinjaMain::ToolCommands(const Options* options, int argc, char* argv[]) {
-  // The clean tool uses getopt, and expects argv[0] to contain the name of
-  // the tool, i.e. "commands".
-  ++argc;
-  --argv;
-
-  PrintCommandMode mode = PCM_All;
-
-  optind = 1;
-  int opt;
-  while ((opt = getopt(argc, argv, const_cast<char*>("hs"))) != -1) {
-    switch (opt) {
-    case 's':
-      mode = PCM_Single;
-      break;
-    case 'h':
-    default:
-      printf("usage: ninja -t commands [options] [targets]\n"
-"\n"
-"options:\n"
-"  -s     only print the final command to build [target], not the whole chain\n"
-             );
-    return 1;
-    }
-  }
-  argv += optind;
-  argc -= optind;
-
+int NinjaMain::ToolCommands(int argc, char* argv[]) {
   vector<Node*> nodes;
   string err;
   if (!CollectTargetsFromArgs(argc, argv, &nodes, &err)) {
@@ -608,12 +566,12 @@
 
   set<Edge*> seen;
   for (vector<Node*>::iterator in = nodes.begin(); in != nodes.end(); ++in)
-    PrintCommands((*in)->in_edge(), &seen, mode);
+    PrintCommands((*in)->in_edge(), &seen);
 
   return 0;
 }
 
-int NinjaMain::ToolClean(const Options* options, int argc, char* argv[]) {
+int NinjaMain::ToolClean(int argc, char* argv[]) {
   // The clean tool uses getopt, and expects argv[0] to contain the name of
   // the tool, i.e. "clean".
   argc++;
@@ -671,65 +629,7 @@
   }
 }
 
-enum EvaluateCommandMode {
-  ECM_NORMAL,
-  ECM_EXPAND_RSPFILE
-};
-string EvaluateCommandWithRspfile(Edge* edge, EvaluateCommandMode mode) {
-  string command = edge->EvaluateCommand();
-  if (mode == ECM_NORMAL)
-    return command;
-
-  string rspfile = edge->GetUnescapedRspfile();
-  if (rspfile.empty())
-    return command;
-
-  size_t index = command.find(rspfile);
-  if (index == 0 || index == string::npos || command[index - 1] != '@')
-    return command;
-
-  string rspfile_content = edge->GetBinding("rspfile_content");
-  size_t newline_index = 0;
-  while ((newline_index = rspfile_content.find('\n', newline_index)) !=
-         string::npos) {
-    rspfile_content.replace(newline_index, 1, 1, ' ');
-    ++newline_index;
-  }
-  command.replace(index - 1, rspfile.length() + 1, rspfile_content);
-  return command;
-}
-
-int NinjaMain::ToolCompilationDatabase(const Options* options, int argc,
-                                       char* argv[]) {
-  // The compdb tool uses getopt, and expects argv[0] to contain the name of
-  // the tool, i.e. "compdb".
-  argc++;
-  argv--;
-
-  EvaluateCommandMode eval_mode = ECM_NORMAL;
-
-  optind = 1;
-  int opt;
-  while ((opt = getopt(argc, argv, const_cast<char*>("hx"))) != -1) {
-    switch(opt) {
-      case 'x':
-        eval_mode = ECM_EXPAND_RSPFILE;
-        break;
-
-      case 'h':
-      default:
-        printf(
-            "usage: ninja -t compdb [options] [rules]\n"
-            "\n"
-            "options:\n"
-            "  -x     expand @rspfile style response file invocations\n"
-            );
-        return 1;
-    }
-  }
-  argv += optind;
-  argc -= optind;
-
+int NinjaMain::ToolCompilationDatabase(int argc, char* argv[]) {
   bool first = true;
   vector<char> cwd;
 
@@ -755,11 +655,9 @@
         printf("\n  {\n    \"directory\": \"");
         EncodeJSONString(&cwd[0]);
         printf("\",\n    \"command\": \"");
-        EncodeJSONString(EvaluateCommandWithRspfile(*e, eval_mode).c_str());
+        EncodeJSONString((*e)->EvaluateCommand().c_str());
         printf("\",\n    \"file\": \"");
         EncodeJSONString((*e)->inputs_[0]->path().c_str());
-        printf("\",\n    \"output\": \"");
-        EncodeJSONString((*e)->outputs_[0]->path().c_str());
         printf("\"\n  }");
 
         first = false;
@@ -771,7 +669,7 @@
   return 0;
 }
 
-int NinjaMain::ToolRecompact(const Options* options, int argc, char* argv[]) {
+int NinjaMain::ToolRecompact(int argc, char* argv[]) {
   if (!EnsureBuildDirExists())
     return 1;
 
@@ -782,7 +680,7 @@
   return 0;
 }
 
-int NinjaMain::ToolUrtle(const Options* options, int argc, char** argv) {
+int NinjaMain::ToolUrtle(int argc, char** argv) {
   // RLE encoded.
   const char* urtle =
 " 13 ,3;2!2;\n8 ,;<11!;\n5 `'<10!(2`'2!\n11 ,6;, `\\. `\\9 .,c13$ec,.\n6 "
@@ -800,7 +698,7 @@
     if ('0' <= *p && *p <= '9') {
       count = count*10 + *p - '0';
     } else {
-      for (int i = 0; i < max(count, 1); ++i)
+      for (int i = 0; i < std::max(count, 1); ++i)
         printf("%c", *p);
       count = 0;
     }
@@ -812,8 +710,10 @@
 /// Returns a Tool, or NULL if Ninja should exit.
 const Tool* ChooseTool(const string& tool_name) {
   static const Tool kTools[] = {
+#if defined(NINJA_HAVE_BROWSE)
     { "browse", "browse dependency graph in a web browser",
       Tool::RUN_AFTER_LOAD, &NinjaMain::ToolBrowse },
+#endif
 #if defined(_MSC_VER)
     { "msvc", "build helper for MSVC cl.exe (EXPERIMENTAL)",
       Tool::RUN_AFTER_FLAGS, &NinjaMain::ToolMSVC },
@@ -871,10 +771,9 @@
 bool DebugEnable(const string& name) {
   if (name == "list") {
     printf("debugging modes:\n"
-"  stats        print operation counts/timing info\n"
-"  explain      explain what caused a command to execute\n"
-"  keepdepfile  don't delete depfiles after they're read by ninja\n"
-"  keeprsp      don't delete @response files on success\n"
+"  stats    print operation counts/timing info\n"
+"  explain  explain what caused a command to execute\n"
+"  keeprsp  don't delete @response files on success\n"
 #ifdef _WIN32
 "  nostatcache  don't batch stat() calls per directory and cache them\n"
 #endif
@@ -886,9 +785,6 @@
   } else if (name == "explain") {
     g_explaining = true;
     return true;
-  } else if (name == "keepdepfile") {
-    g_keep_depfile = true;
-    return true;
   } else if (name == "keeprsp") {
     g_keep_rsp = true;
     return true;
@@ -897,9 +793,8 @@
     return true;
   } else {
     const char* suggestion =
-        SpellcheckString(name.c_str(),
-                         "stats", "explain", "keepdepfile", "keeprsp",
-                         "nostatcache", NULL);
+        SpellcheckString(name.c_str(), "stats", "explain", "keeprsp",
+        "nostatcache", NULL);
     if (suggestion) {
       Error("unknown debug setting '%s', did you mean '%s'?",
             name.c_str(), suggestion);
@@ -915,10 +810,7 @@
 bool WarningEnable(const string& name, Options* options) {
   if (name == "list") {
     printf("warning flags:\n"
-"  dupbuild={err,warn}  multiple build lines for one target\n"
-"  phonycycle={err,warn}  phony build statement references itself\n"
-"  depfilemulti={err,warn}  depfile has multiple output paths on separate lines\n"
-    );
+"  dupbuild={err,warn}  multiple build lines for one target\n");
     return false;
   } else if (name == "dupbuild=err") {
     options->dupe_edges_should_err = true;
@@ -926,22 +818,9 @@
   } else if (name == "dupbuild=warn") {
     options->dupe_edges_should_err = false;
     return true;
-  } else if (name == "phonycycle=err") {
-    options->phony_cycle_should_err = true;
-    return true;
-  } else if (name == "phonycycle=warn") {
-    options->phony_cycle_should_err = false;
-    return true;
-  } else if (name == "depfilemulti=err") {
-    options->depfile_distinct_target_lines_should_err = true;
-    return true;
-  } else if (name == "depfilemulti=warn") {
-    options->depfile_distinct_target_lines_should_err = false;
-    return true;
   } else {
     const char* suggestion =
-        SpellcheckString(name.c_str(), "dupbuild=err", "dupbuild=warn",
-                         "phonycycle=err", "phonycycle=warn", NULL);
+        SpellcheckString(name.c_str(), "dupbuild=err", "dupbuild=warn", NULL);
     if (suggestion) {
       Error("unknown warning flag '%s', did you mean '%s'?",
             name.c_str(), suggestion);
@@ -1117,7 +996,6 @@
   const option kLongOptions[] = {
     { "help", no_argument, NULL, 'h' },
     { "version", no_argument, NULL, OPT_VERSION },
-    { "verbose", no_argument, NULL, 'v' },
     { NULL, 0, NULL, 0 }
   };
 
@@ -1136,12 +1014,9 @@
       case 'j': {
         char* end;
         int value = strtol(optarg, &end, 10);
-        if (*end != 0 || value < 0)
+        if (*end != 0 || value <= 0)
           Fatal("invalid -j parameter");
-
-        // We want to run N jobs in parallel. For N = 0, INT_MAX
-        // is close enough to infinite for most sane builds.
-        config->parallelism = value > 0 ? value : INT_MAX;
+        config->parallelism = value;
         break;
       }
       case 'k': {
@@ -1197,25 +1072,17 @@
   return -1;
 }
 
-NORETURN void real_main(int argc, char** argv) {
-  // Use exit() instead of return in this function to avoid potentially
-  // expensive cleanup when destructing NinjaMain.
+int real_main(int argc, char** argv) {
   BuildConfig config;
   Options options = {};
   options.input_file = "build.ninja";
-  options.dupe_edges_should_err = true;
 
   setvbuf(stdout, NULL, _IOLBF, BUFSIZ);
   const char* ninja_command = argv[0];
 
   int exit_code = ReadFlags(&argc, &argv, &options, &config);
   if (exit_code >= 0)
-    exit(exit_code);
-
-  if (options.depfile_distinct_target_lines_should_err) {
-    config.depfile_parser_options.depfile_distinct_target_lines_action_ =
-        kDepfileDistinctTargetLinesActionError;
-  }
+    return exit_code;
 
   if (options.working_dir) {
     // The formatting of this string, complete with funny quotes, is
@@ -1234,7 +1101,7 @@
     // None of the RUN_AFTER_FLAGS actually use a NinjaMain, but it's needed
     // by other tools.
     NinjaMain ninja(ninja_command, config);
-    exit((ninja.*options.tool->func)(&options, argc, argv));
+    return (ninja.*options.tool->func)(argc, argv);
   }
 
   // Limit number of rebuilds, to prevent infinite loops.
@@ -1242,54 +1109,45 @@
   for (int cycle = 1; cycle <= kCycleLimit; ++cycle) {
     NinjaMain ninja(ninja_command, config);
 
-    ManifestParserOptions parser_opts;
-    if (options.dupe_edges_should_err) {
-      parser_opts.dupe_edge_action_ = kDupeEdgeActionError;
-    }
-    if (options.phony_cycle_should_err) {
-      parser_opts.phony_cycle_action_ = kPhonyCycleActionError;
-    }
-    ManifestParser parser(&ninja.state_, &ninja.disk_interface_, parser_opts);
+    RealFileReader file_reader;
+    ManifestParser parser(&ninja.state_, &file_reader,
+                          options.dupe_edges_should_err);
     string err;
     if (!parser.Load(options.input_file, &err)) {
       Error("%s", err.c_str());
-      exit(1);
+      return 1;
     }
 
     if (options.tool && options.tool->when == Tool::RUN_AFTER_LOAD)
-      exit((ninja.*options.tool->func)(&options, argc, argv));
+      return (ninja.*options.tool->func)(argc, argv);
 
     if (!ninja.EnsureBuildDirExists())
-      exit(1);
+      return 1;
 
     if (!ninja.OpenBuildLog() || !ninja.OpenDepsLog())
-      exit(1);
+      return 1;
 
     if (options.tool && options.tool->when == Tool::RUN_AFTER_LOGS)
-      exit((ninja.*options.tool->func)(&options, argc, argv));
+      return (ninja.*options.tool->func)(argc, argv);
 
     // Attempt to rebuild the manifest before building anything else
     if (ninja.RebuildManifest(options.input_file, &err)) {
-      // In dry_run mode the regeneration will succeed without changing the
-      // manifest forever. Better to return immediately.
-      if (config.dry_run)
-        exit(0);
       // Start the build over with the new manifest.
       continue;
     } else if (!err.empty()) {
       Error("rebuilding '%s': %s", options.input_file, err.c_str());
-      exit(1);
+      return 1;
     }
 
     int result = ninja.RunBuild(argc, argv);
     if (g_metrics)
       ninja.DumpMetrics();
-    exit(result);
+    return result;
   }
 
   Error("manifest '%s' still dirty after %d tries\n",
       options.input_file, kCycleLimit);
-  exit(1);
+  return 1;
 }
 
 }  // anonymous namespace
@@ -1298,11 +1156,11 @@
 #if defined(_MSC_VER)
   // Set a handler to catch crashes not caught by the __try..__except
   // block (e.g. an exception in a stack-unwind-block).
-  std::set_terminate(TerminateHandler);
+  set_terminate(TerminateHandler);
   __try {
     // Running inside __try ... __except suppresses any Windows error
     // dialogs for errors such as bad_alloc.
-    real_main(argc, argv);
+    return real_main(argc, argv);
   }
   __except(ExceptionFilter(GetExceptionCode(), GetExceptionInformation())) {
     // Common error situations return exitCode=1. 2 was chosen to
@@ -1310,6 +1168,6 @@
     return 2;
   }
 #else
-  real_main(argc, argv);
+  return real_main(argc, argv);
 #endif
 }
diff -Naur ninja-1.9.0.orig/src/ninja_test.cc ninja/src/ninja_test.cc
--- ninja-1.9.0.orig/src/ninja_test.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/ninja_test.cc	2019-09-24 19:51:29.662462538 +0000
@@ -14,13 +14,9 @@
 
 #include <stdarg.h>
 #include <stdio.h>
-#include <stdlib.h>
 
 #ifdef _WIN32
 #include "getopt.h"
-#elif defined(_AIX)
-#include "getopt.h"
-#include <unistd.h>
 #else
 #include <getopt.h>
 #endif
diff -Naur ninja-1.9.0.orig/src/state.cc ninja/src/state.cc
--- ninja-1.9.0.orig/src/state.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/state.cc	2019-09-24 19:51:29.663748938 +0000
@@ -100,7 +100,7 @@
   return edge;
 }
 
-Node* State::GetNode(StringPiece path, uint64_t slash_bits) {
+Node* State::GetNode(StringPiece path, unsigned int slash_bits) {
   Node* node = LookupNode(path);
   if (node)
     return node;
@@ -134,13 +134,13 @@
   return result;
 }
 
-void State::AddIn(Edge* edge, StringPiece path, uint64_t slash_bits) {
+void State::AddIn(Edge* edge, StringPiece path, unsigned int slash_bits) {
   Node* node = GetNode(path, slash_bits);
   edge->inputs_.push_back(node);
   node->AddOutEdge(edge);
 }
 
-bool State::AddOut(Edge* edge, StringPiece path, uint64_t slash_bits) {
+bool State::AddOut(Edge* edge, StringPiece path, unsigned int slash_bits) {
   Node* node = GetNode(path, slash_bits);
   if (node->in_edge())
     return false;
@@ -159,12 +159,11 @@
   return true;
 }
 
-vector<Node*> State::RootNodes(string* err) const {
+vector<Node*> State::RootNodes(string* err) {
   vector<Node*> root_nodes;
   // Search for nodes with no output.
-  for (vector<Edge*>::const_iterator e = edges_.begin();
-       e != edges_.end(); ++e) {
-    for (vector<Node*>::const_iterator out = (*e)->outputs_.begin();
+  for (vector<Edge*>::iterator e = edges_.begin(); e != edges_.end(); ++e) {
+    for (vector<Node*>::iterator out = (*e)->outputs_.begin();
          out != (*e)->outputs_.end(); ++out) {
       if ((*out)->out_edges().empty())
         root_nodes.push_back(*out);
@@ -177,17 +176,15 @@
   return root_nodes;
 }
 
-vector<Node*> State::DefaultNodes(string* err) const {
+vector<Node*> State::DefaultNodes(string* err) {
   return defaults_.empty() ? RootNodes(err) : defaults_;
 }
 
 void State::Reset() {
   for (Paths::iterator i = paths_.begin(); i != paths_.end(); ++i)
     i->second->ResetState();
-  for (vector<Edge*>::iterator e = edges_.begin(); e != edges_.end(); ++e) {
+  for (vector<Edge*>::iterator e = edges_.begin(); e != edges_.end(); ++e)
     (*e)->outputs_ready_ = false;
-    (*e)->mark_ = Edge::VisitNone;
-  }
 }
 
 void State::Dump() {
diff -Naur ninja-1.9.0.orig/src/state.h ninja/src/state.h
--- ninja-1.9.0.orig/src/state.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/state.h	2019-09-24 19:51:29.664713738 +0000
@@ -23,7 +23,6 @@
 
 #include "eval_env.h"
 #include "hash_map.h"
-#include "util.h"
 
 struct Edge;
 struct Node;
@@ -33,7 +32,7 @@
 /// Pools are scoped to a State. Edges within a State will share Pools. A Pool
 /// will keep a count of the total 'weight' of the currently scheduled edges. If
 /// a Plan attempts to schedule an Edge which would cause the total weight to
-/// exceed the depth of the Pool, the Pool will enqueue the Edge instead of
+/// exceed the depth of the Pool, the Pool will enque the Edge instead of
 /// allowing the Plan to schedule it. The Pool will relinquish queued Edges when
 /// the total scheduled weight diminishes enough (i.e. when a scheduled edge
 /// completes).
@@ -94,12 +93,12 @@
 
   Edge* AddEdge(const Rule* rule);
 
-  Node* GetNode(StringPiece path, uint64_t slash_bits);
+  Node* GetNode(StringPiece path, unsigned int slash_bits);
   Node* LookupNode(StringPiece path) const;
   Node* SpellcheckNode(const string& path);
 
-  void AddIn(Edge* edge, StringPiece path, uint64_t slash_bits);
-  bool AddOut(Edge* edge, StringPiece path, uint64_t slash_bits);
+  void AddIn(Edge* edge, StringPiece path, unsigned int slash_bits);
+  bool AddOut(Edge* edge, StringPiece path, unsigned int slash_bits);
   bool AddDefault(StringPiece path, string* error);
 
   /// Reset state.  Keeps all nodes and edges, but restores them to the
@@ -111,8 +110,8 @@
 
   /// @return the root node(s) of the graph. (Root nodes have no output edges).
   /// @param error where to write the error message if somethings went wrong.
-  vector<Node*> RootNodes(string* error) const;
-  vector<Node*> DefaultNodes(string* error) const;
+  vector<Node*> RootNodes(string* error);
+  vector<Node*> DefaultNodes(string* error);
 
   /// Mapping of path -> Node.
   typedef ExternalStringHashMap<Node*>::Type Paths;
diff -Naur ninja-1.9.0.orig/src/string_piece.h ninja/src/string_piece.h
--- ninja-1.9.0.orig/src/string_piece.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/string_piece.h	2019-09-24 19:51:29.665361738 +0000
@@ -25,8 +25,6 @@
 /// externally.  It is useful for reducing the number of std::strings
 /// we need to allocate.
 struct StringPiece {
-  typedef const char* const_iterator;
-
   StringPiece() : str_(NULL), len_(0) {}
 
   /// The constructors intentionally allow for implicit conversions.
@@ -48,22 +46,6 @@
     return len_ ? string(str_, len_) : string();
   }
 
-  const_iterator begin() const {
-    return str_;
-  }
-
-  const_iterator end() const {
-    return str_ + len_;
-  }
-
-  char operator[](size_t pos) const {
-    return str_[pos];
-  }
-
-  size_t size() const {
-    return len_;
-  }
-
   const char* str_;
   size_t len_;
 };
diff -Naur ninja-1.9.0.orig/src/string_piece_util.cc ninja/src/string_piece_util.cc
--- ninja-1.9.0.orig/src/string_piece_util.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/string_piece_util.cc	1969-12-31 19:00:00.000000000 +0000
@@ -1,78 +0,0 @@
-// Copyright 2017 Google Inc. All Rights Reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "string_piece_util.h"
-
-#include <algorithm>
-#include <string>
-#include <vector>
-using namespace std;
-
-vector<StringPiece> SplitStringPiece(StringPiece input, char sep) {
-  vector<StringPiece> elems;
-  elems.reserve(count(input.begin(), input.end(), sep) + 1);
-
-  StringPiece::const_iterator pos = input.begin();
-
-  for (;;) {
-    const char* next_pos = find(pos, input.end(), sep);
-    if (next_pos == input.end()) {
-      elems.push_back(StringPiece(pos, input.end() - pos));
-      break;
-    }
-    elems.push_back(StringPiece(pos, next_pos - pos));
-    pos = next_pos + 1;
-  }
-
-  return elems;
-}
-
-string JoinStringPiece(const vector<StringPiece>& list, char sep) {
-  if (list.size() == 0){
-    return "";
-  }
-
-  string ret;
-
-  {
-    size_t cap = list.size() - 1;
-    for (size_t i = 0; i < list.size(); ++i) {
-      cap += list[i].len_;
-    }
-    ret.reserve(cap);
-  }
-
-  for (size_t i = 0; i < list.size(); ++i) {
-    if (i != 0) {
-      ret += sep;
-    }
-    ret.append(list[i].str_, list[i].len_);
-  }
-
-  return ret;
-}
-
-bool EqualsCaseInsensitiveASCII(StringPiece a, StringPiece b) {
-  if (a.len_ != b.len_) {
-    return false;
-  }
-
-  for (size_t i = 0; i < a.len_; ++i) {
-    if (ToLowerASCII(a.str_[i]) != ToLowerASCII(b.str_[i])) {
-      return false;
-    }
-  }
-
-  return true;
-}
diff -Naur ninja-1.9.0.orig/src/string_piece_util.h ninja/src/string_piece_util.h
--- ninja-1.9.0.orig/src/string_piece_util.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/string_piece_util.h	1969-12-31 19:00:00.000000000 +0000
@@ -1,34 +0,0 @@
-// Copyright 2017 Google Inc. All Rights Reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef NINJA_STRINGPIECE_UTIL_H_
-#define NINJA_STRINGPIECE_UTIL_H_
-
-#include <string>
-#include <vector>
-
-#include "string_piece.h"
-using namespace std;
-
-vector<StringPiece> SplitStringPiece(StringPiece input, char sep);
-
-string JoinStringPiece(const vector<StringPiece>& list, char sep);
-
-inline char ToLowerASCII(char c) {
-  return (c >= 'A' && c <= 'Z') ? (c + ('a' - 'A')) : c;
-}
-
-bool EqualsCaseInsensitiveASCII(StringPiece a, StringPiece b);
-
-#endif  // NINJA_STRINGPIECE_UTIL_H_
diff -Naur ninja-1.9.0.orig/src/string_piece_util_test.cc ninja/src/string_piece_util_test.cc
--- ninja-1.9.0.orig/src/string_piece_util_test.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/string_piece_util_test.cc	1969-12-31 19:00:00.000000000 +0000
@@ -1,129 +0,0 @@
-// Copyright 2017 Google Inc. All Rights Reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "string_piece_util.h"
-
-#include "test.h"
-
-TEST(StringPieceUtilTest, SplitStringPiece) {
-  {
-    string input("a:b:c");
-    vector<StringPiece> list = SplitStringPiece(input, ':');
-
-    EXPECT_EQ(list.size(), 3);
-
-    EXPECT_EQ(list[0], "a");
-    EXPECT_EQ(list[1], "b");
-    EXPECT_EQ(list[2], "c");
-  }
-
-  {
-    string empty("");
-    vector<StringPiece> list = SplitStringPiece(empty, ':');
-
-    EXPECT_EQ(list.size(), 1);
-
-    EXPECT_EQ(list[0], "");
-  }
-
-  {
-    string one("a");
-    vector<StringPiece> list = SplitStringPiece(one, ':');
-
-    EXPECT_EQ(list.size(), 1);
-
-    EXPECT_EQ(list[0], "a");
-  }
-
-  {
-    string sep_only(":");
-    vector<StringPiece> list = SplitStringPiece(sep_only, ':');
-
-    EXPECT_EQ(list.size(), 2);
-
-    EXPECT_EQ(list[0], "");
-    EXPECT_EQ(list[1], "");
-  }
-
-  {
-    string sep(":a:b:c:");
-    vector<StringPiece> list = SplitStringPiece(sep, ':');
-
-    EXPECT_EQ(list.size(), 5);
-
-    EXPECT_EQ(list[0], "");
-    EXPECT_EQ(list[1], "a");
-    EXPECT_EQ(list[2], "b");
-    EXPECT_EQ(list[3], "c");
-    EXPECT_EQ(list[4], "");
-  }
-}
-
-TEST(StringPieceUtilTest, JoinStringPiece) {
-  {
-    string input("a:b:c");
-    vector<StringPiece> list = SplitStringPiece(input, ':');
-
-    EXPECT_EQ("a:b:c", JoinStringPiece(list, ':'));
-    EXPECT_EQ("a/b/c", JoinStringPiece(list, '/'));
-  }
-
-  {
-    string empty("");
-    vector<StringPiece> list = SplitStringPiece(empty, ':');
-
-    EXPECT_EQ("", JoinStringPiece(list, ':'));
-  }
-
-  {
-    vector<StringPiece> empty_list;
-
-    EXPECT_EQ("", JoinStringPiece(empty_list, ':'));
-  }
-
-  {
-    string one("a");
-    vector<StringPiece> single_list = SplitStringPiece(one, ':');
-
-    EXPECT_EQ("a", JoinStringPiece(single_list, ':'));
-  }
-
-  {
-    string sep(":a:b:c:");
-    vector<StringPiece> list = SplitStringPiece(sep, ':');
-
-    EXPECT_EQ(":a:b:c:", JoinStringPiece(list, ':'));
-  }
-}
-
-TEST(StringPieceUtilTest, ToLowerASCII) {
-  EXPECT_EQ('a', ToLowerASCII('A'));
-  EXPECT_EQ('z', ToLowerASCII('Z'));
-  EXPECT_EQ('a', ToLowerASCII('a'));
-  EXPECT_EQ('z', ToLowerASCII('z'));
-  EXPECT_EQ('/', ToLowerASCII('/'));
-  EXPECT_EQ('1', ToLowerASCII('1'));
-}
-
-TEST(StringPieceUtilTest, EqualsCaseInsensitiveASCII) {
-  EXPECT_TRUE(EqualsCaseInsensitiveASCII("abc", "abc"));
-  EXPECT_TRUE(EqualsCaseInsensitiveASCII("abc", "ABC"));
-  EXPECT_TRUE(EqualsCaseInsensitiveASCII("abc", "aBc"));
-  EXPECT_TRUE(EqualsCaseInsensitiveASCII("AbC", "aBc"));
-  EXPECT_TRUE(EqualsCaseInsensitiveASCII("", ""));
-
-  EXPECT_FALSE(EqualsCaseInsensitiveASCII("a", "ac"));
-  EXPECT_FALSE(EqualsCaseInsensitiveASCII("/", "\\"));
-  EXPECT_FALSE(EqualsCaseInsensitiveASCII("1", "10"));
-}
diff -Naur ninja-1.9.0.orig/src/subprocess-posix.cc ninja/src/subprocess-posix.cc
--- ninja-1.9.0.orig/src/subprocess-posix.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/subprocess-posix.cc	2019-09-24 19:51:29.666592938 +0000
@@ -14,7 +14,6 @@
 
 #include "subprocess.h"
 
-#include <sys/select.h>
 #include <assert.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -23,9 +22,6 @@
 #include <stdio.h>
 #include <string.h>
 #include <sys/wait.h>
-#include <spawn.h>
-
-extern char** environ;
 
 #include "util.h"
 
@@ -54,74 +50,62 @@
 #endif  // !USE_PPOLL
   SetCloseOnExec(fd_);
 
-  posix_spawn_file_actions_t action;
-  int err = posix_spawn_file_actions_init(&action);
-  if (err != 0)
-    Fatal("posix_spawn_file_actions_init: %s", strerror(err));
-
-  err = posix_spawn_file_actions_addclose(&action, output_pipe[0]);
-  if (err != 0)
-    Fatal("posix_spawn_file_actions_addclose: %s", strerror(err));
-
-  posix_spawnattr_t attr;
-  err = posix_spawnattr_init(&attr);
-  if (err != 0)
-    Fatal("posix_spawnattr_init: %s", strerror(err));
-
-  short flags = 0;
-
-  flags |= POSIX_SPAWN_SETSIGMASK;
-  err = posix_spawnattr_setsigmask(&attr, &set->old_mask_);
-  if (err != 0)
-    Fatal("posix_spawnattr_setsigmask: %s", strerror(err));
-  // Signals which are set to be caught in the calling process image are set to
-  // default action in the new process image, so no explicit
-  // POSIX_SPAWN_SETSIGDEF parameter is needed.
-
-  if (!use_console_) {
-    // Put the child in its own process group, so ctrl-c won't reach it.
-    flags |= POSIX_SPAWN_SETPGROUP;
-    // No need to posix_spawnattr_setpgroup(&attr, 0), it's the default.
-
-    // Open /dev/null over stdin.
-    err = posix_spawn_file_actions_addopen(&action, 0, "/dev/null", O_RDONLY,
-          0);
-    if (err != 0) {
-      Fatal("posix_spawn_file_actions_addopen: %s", strerror(err));
-    }
+  pid_ = fork();
+  if (pid_ < 0)
+    Fatal("fork: %s", strerror(errno));
+
+  if (pid_ == 0) {
+    close(output_pipe[0]);
+
+    // Track which fd we use to report errors on.
+    int error_pipe = output_pipe[1];
+    do {
+      if (sigaction(SIGINT, &set->old_int_act_, 0) < 0)
+        break;
+      if (sigaction(SIGTERM, &set->old_term_act_, 0) < 0)
+        break;
+      if (sigprocmask(SIG_SETMASK, &set->old_mask_, 0) < 0)
+        break;
+
+      if (!use_console_) {
+        // Put the child in its own session and process group. It will be
+        // detached from the current terminal and ctrl-c won't reach it.
+        // Since this process was just forked, it is not a process group leader
+        // and setsid() will succeed.
+        if (setsid() < 0)
+          break;
+
+        // Open /dev/null over stdin.
+        int devnull = open("/dev/null", O_RDONLY);
+        if (devnull < 0)
+          break;
+        if (dup2(devnull, 0) < 0)
+          break;
+        close(devnull);
+
+        if (dup2(output_pipe[1], 1) < 0 ||
+            dup2(output_pipe[1], 2) < 0)
+          break;
+
+        // Now can use stderr for errors.
+        error_pipe = 2;
+        close(output_pipe[1]);
+      }
+      // In the console case, output_pipe is still inherited by the child and
+      // closed when the subprocess finishes, which then notifies ninja.
 
-    err = posix_spawn_file_actions_adddup2(&action, output_pipe[1], 1);
-    if (err != 0)
-      Fatal("posix_spawn_file_actions_adddup2: %s", strerror(err));
-    err = posix_spawn_file_actions_adddup2(&action, output_pipe[1], 2);
-    if (err != 0)
-      Fatal("posix_spawn_file_actions_adddup2: %s", strerror(err));
-    err = posix_spawn_file_actions_addclose(&action, output_pipe[1]);
-    if (err != 0)
-      Fatal("posix_spawn_file_actions_addclose: %s", strerror(err));
-    // In the console case, output_pipe is still inherited by the child and
-    // closed when the subprocess finishes, which then notifies ninja.
-  }
-#ifdef POSIX_SPAWN_USEVFORK
-  flags |= POSIX_SPAWN_USEVFORK;
-#endif
+      execl("/bin/sh", "/bin/sh", "-c", command.c_str(), (char *) NULL);
+    } while (false);
 
-  err = posix_spawnattr_setflags(&attr, flags);
-  if (err != 0)
-    Fatal("posix_spawnattr_setflags: %s", strerror(err));
-
-  const char* spawned_args[] = { "/bin/sh", "-c", command.c_str(), NULL };
-  err = posix_spawn(&pid_, "/bin/sh", &action, &attr,
-        const_cast<char**>(spawned_args), environ);
-  if (err != 0)
-    Fatal("posix_spawn: %s", strerror(err));
-
-  err = posix_spawnattr_destroy(&attr);
-  if (err != 0)
-    Fatal("posix_spawnattr_destroy: %s", strerror(err));
-  err = posix_spawn_file_actions_destroy(&action);
-  if (err != 0)
-    Fatal("posix_spawn_file_actions_destroy: %s", strerror(err));
+    // If we get here, something went wrong; the execl should have
+    // replaced us.
+    char* err = strerror(errno);
+    if (write(error_pipe, err, strlen(err)) < 0) {
+      // If the write fails, there's nothing we can do.
+      // But this block seems necessary to silence the warning.
+    }
+    _exit(1);
+  }
 
   close(output_pipe[1]);
   return true;
@@ -152,8 +136,7 @@
     if (exit == 0)
       return ExitSuccess;
   } else if (WIFSIGNALED(status)) {
-    if (WTERMSIG(status) == SIGINT || WTERMSIG(status) == SIGTERM
-        || WTERMSIG(status) == SIGHUP)
+    if (WTERMSIG(status) == SIGINT || WTERMSIG(status) == SIGTERM)
       return ExitInterrupted;
   }
   return ExitFailure;
@@ -184,8 +167,6 @@
     interrupted_ = SIGINT;
   else if (sigismember(&pending, SIGTERM))
     interrupted_ = SIGTERM;
-  else if (sigismember(&pending, SIGHUP))
-    interrupted_ = SIGHUP;
 }
 
 SubprocessSet::SubprocessSet() {
@@ -193,7 +174,6 @@
   sigemptyset(&set);
   sigaddset(&set, SIGINT);
   sigaddset(&set, SIGTERM);
-  sigaddset(&set, SIGHUP);
   if (sigprocmask(SIG_BLOCK, &set, &old_mask_) < 0)
     Fatal("sigprocmask: %s", strerror(errno));
 
@@ -204,8 +184,6 @@
     Fatal("sigaction: %s", strerror(errno));
   if (sigaction(SIGTERM, &act, &old_term_act_) < 0)
     Fatal("sigaction: %s", strerror(errno));
-  if (sigaction(SIGHUP, &act, &old_hup_act_) < 0)
-    Fatal("sigaction: %s", strerror(errno));
 }
 
 SubprocessSet::~SubprocessSet() {
@@ -215,8 +193,6 @@
     Fatal("sigaction: %s", strerror(errno));
   if (sigaction(SIGTERM, &old_term_act_, 0) < 0)
     Fatal("sigaction: %s", strerror(errno));
-  if (sigaction(SIGHUP, &old_hup_act_, 0) < 0)
-    Fatal("sigaction: %s", strerror(errno));
   if (sigprocmask(SIG_SETMASK, &old_mask_, 0) < 0)
     Fatal("sigprocmask: %s", strerror(errno));
 }
@@ -298,7 +274,11 @@
   }
 
   interrupted_ = 0;
+#ifdef __sgi
+  int ret = select(nfds, &set, 0, 0, 0);
+#else
   int ret = pselect(nfds, &set, 0, 0, 0, &old_mask_);
+#endif
   if (ret == -1) {
     if (errno != EINTR) {
       perror("ninja: pselect");
diff -Naur ninja-1.9.0.orig/src/subprocess-win32.cc ninja/src/subprocess-win32.cc
--- ninja-1.9.0.orig/src/subprocess-win32.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/subprocess-win32.cc	2019-09-24 19:51:29.668093738 +0000
@@ -59,8 +59,8 @@
   }
 
   // Get the write end of the pipe as a handle inheritable across processes.
-  HANDLE output_write_handle =
-      CreateFileA(pipe_name, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
+  HANDLE output_write_handle = CreateFile(pipe_name, GENERIC_WRITE, 0,
+                                          NULL, OPEN_EXISTING, 0, NULL);
   HANDLE output_write_child;
   if (!DuplicateHandle(GetCurrentProcess(), output_write_handle,
                        GetCurrentProcess(), &output_write_child,
@@ -80,10 +80,9 @@
   security_attributes.nLength = sizeof(SECURITY_ATTRIBUTES);
   security_attributes.bInheritHandle = TRUE;
   // Must be inheritable so subprocesses can dup to children.
-  HANDLE nul =
-      CreateFileA("NUL", GENERIC_READ,
-                  FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
-                  &security_attributes, OPEN_EXISTING, 0, NULL);
+  HANDLE nul = CreateFile("NUL", GENERIC_READ,
+          FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
+          &security_attributes, OPEN_EXISTING, 0, NULL);
   if (nul == INVALID_HANDLE_VALUE)
     Fatal("couldn't open nul");
 
@@ -124,10 +123,6 @@
       buf_ = "CreateProcess failed: The system cannot find the file "
           "specified.\n";
       return true;
-    } else if (error == ERROR_INVALID_PARAMETER) {
-      // This generally means that the command line was too long. Give extra
-      // context for this case.
-      Win32Fatal("CreateProcess", "is the command line too long?");
     } else {
       Win32Fatal("CreateProcess");    // pass all other errors to Win32Fatal
     }
@@ -260,7 +255,7 @@
 
   if (subproc->Done()) {
     vector<Subprocess*>::iterator end =
-        remove(running_.begin(), running_.end(), subproc);
+        std::remove(running_.begin(), running_.end(), subproc);
     if (running_.end() != end) {
       finished_.push(subproc);
       running_.resize(end - running_.begin());
diff -Naur ninja-1.9.0.orig/src/subprocess.h ninja/src/subprocess.h
--- ninja-1.9.0.orig/src/subprocess.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/subprocess.h	2019-09-24 19:51:29.668793738 +0000
@@ -26,14 +26,6 @@
 #include <signal.h>
 #endif
 
-// ppoll() exists on FreeBSD, but only on newer versions.
-#ifdef __FreeBSD__
-#  include <sys/param.h>
-#  if defined USE_PPOLL && __FreeBSD_version < 1002000
-#    undef USE_PPOLL
-#  endif
-#endif
-
 #include "exit_status.h"
 
 /// Subprocess wraps a single async subprocess.  It is entirely
@@ -106,7 +98,6 @@
 
   struct sigaction old_int_act_;
   struct sigaction old_term_act_;
-  struct sigaction old_hup_act_;
   sigset_t old_mask_;
 #endif
 };
diff -Naur ninja-1.9.0.orig/src/subprocess_test.cc ninja/src/subprocess_test.cc
--- ninja-1.9.0.orig/src/subprocess_test.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/subprocess_test.cc	2019-09-24 19:51:29.670092938 +0000
@@ -16,6 +16,8 @@
 
 #include "test.h"
 
+#include <string>
+
 #ifndef _WIN32
 // SetWithLots need setrlimit.
 #include <stdio.h>
@@ -120,35 +122,22 @@
   ASSERT_FALSE("We should have been interrupted");
 }
 
-TEST_F(SubprocessTest, InterruptChildWithSigHup) {
-  Subprocess* subproc = subprocs_.Add("kill -HUP $$");
-  ASSERT_NE((Subprocess *) 0, subproc);
-
-  while (!subproc->Done()) {
-    subprocs_.DoWork();
-  }
-
-  EXPECT_EQ(ExitInterrupted, subproc->Finish());
-}
-
-TEST_F(SubprocessTest, InterruptParentWithSigHup) {
-  Subprocess* subproc = subprocs_.Add("kill -HUP $PPID ; sleep 1");
-  ASSERT_NE((Subprocess *) 0, subproc);
-
-  while (!subproc->Done()) {
-    bool interrupted = subprocs_.DoWork();
-    if (interrupted)
-      return;
-  }
-
-  ASSERT_FALSE("We should have been interrupted");
-}
+// A shell command to check if the current process is connected to a terminal.
+// This is different from having stdin/stdout/stderr be a terminal. (For
+// instance consider the command "yes < /dev/null > /dev/null 2>&1".
+// As "ps" will confirm, "yes" could still be connected to a terminal, despite
+// not having any of the standard file descriptors be a terminal.
+static const char kIsConnectedToTerminal[] = "tty < /dev/tty > /dev/null";
 
 TEST_F(SubprocessTest, Console) {
   // Skip test if we don't have the console ourselves.
   if (isatty(0) && isatty(1) && isatty(2)) {
+    // Test that stdin, stdout and stderr are a terminal.
+    // Also check that the current process is connected to a terminal.
     Subprocess* subproc =
-        subprocs_.Add("test -t 0 -a -t 1 -a -t 2", /*use_console=*/true);
+        subprocs_.Add(std::string("test -t 0 -a -t 1 -a -t 2 && ") +
+                          std::string(kIsConnectedToTerminal),
+                      /*use_console=*/true);
     ASSERT_NE((Subprocess*)0, subproc);
 
     while (!subproc->Done()) {
@@ -159,6 +148,18 @@
   }
 }
 
+TEST_F(SubprocessTest, NoConsole) {
+  Subprocess* subproc =
+      subprocs_.Add(kIsConnectedToTerminal, /*use_console=*/false);
+  ASSERT_NE((Subprocess*)0, subproc);
+
+  while (!subproc->Done()) {
+    subprocs_.DoWork();
+  }
+
+  EXPECT_NE(ExitSuccess, subproc->Finish());
+}
+
 #endif
 
 TEST_F(SubprocessTest, SetWithSingle) {
@@ -182,7 +183,7 @@
     "cmd /c echo hi",
     "cmd /c time /t",
 #else
-    "id -u",
+    "whoami",
     "pwd",
 #endif
   };
@@ -214,7 +215,9 @@
   }
 }
 
-#if defined(USE_PPOLL)
+// OS X's process limit is less than 1025 by default
+// (|sysctl kern.maxprocperuid| is 709 on 10.7 and 10.8 and less prior to that).
+#if !defined(__APPLE__) && !defined(_WIN32)
 TEST_F(SubprocessTest, SetWithLots) {
   // Arbitrary big number; needs to be over 1024 to confirm we're no longer
   // hostage to pselect.
@@ -224,8 +227,7 @@
   rlimit rlim;
   ASSERT_EQ(0, getrlimit(RLIMIT_NOFILE, &rlim));
   if (rlim.rlim_cur < kNumProcs) {
-    printf("Raise [ulimit -n] above %u (currently %lu) to make this test go\n",
-           kNumProcs, rlim.rlim_cur);
+    printf("Raise [ulimit -n] well above %u (currently %lu) to make this test go\n", kNumProcs, rlim.rlim_cur);
     return;
   }
 
diff -Naur ninja-1.9.0.orig/src/test.cc ninja/src/test.cc
--- ninja-1.9.0.orig/src/test.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/test.cc	2019-09-24 19:51:29.671322538 +0000
@@ -21,7 +21,6 @@
 #include <algorithm>
 
 #include <errno.h>
-#include <stdlib.h>
 #ifdef _WIN32
 #include <windows.h>
 #else
@@ -95,9 +94,8 @@
   return state_.GetNode(path, 0);
 }
 
-void AssertParse(State* state, const char* input,
-                 ManifestParserOptions opts) {
-  ManifestParser parser(state, NULL, opts);
+void AssertParse(State* state, const char* input) {
+  ManifestParser parser(state, NULL);
   string err;
   EXPECT_TRUE(parser.ParseTest(input, &err));
   ASSERT_EQ("", err);
@@ -117,7 +115,7 @@
     for (vector<Node*>::const_iterator in_node = (*e)->inputs_.begin();
          in_node != (*e)->inputs_.end(); ++in_node) {
       const vector<Edge*>& out_edges = (*in_node)->out_edges();
-      EXPECT_NE(find(out_edges.begin(), out_edges.end(), *e),
+      EXPECT_NE(std::find(out_edges.begin(), out_edges.end(), *e),
                 out_edges.end());
     }
     // Check that the edge's outputs have the edge as in-edge.
@@ -166,17 +164,12 @@
   return true;  // success
 }
 
-FileReader::Status VirtualFileSystem::ReadFile(const string& path,
-                                               string* contents,
-                                               string* err) {
+string VirtualFileSystem::ReadFile(const string& path, string* err) {
   files_read_.push_back(path);
   FileMap::iterator i = files_.find(path);
-  if (i != files_.end()) {
-    *contents = i->second.contents;
-    return Okay;
-  }
-  *err = strerror(ENOENT);
-  return NotFound;
+  if (i != files_.end())
+    return i->second.contents;
+  return "";
 }
 
 int VirtualFileSystem::RemoveFile(const string& path) {
diff -Naur ninja-1.9.0.orig/src/test.h ninja/src/test.h
--- ninja-1.9.0.orig/src/test.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/test.h	2019-09-24 19:51:29.672319338 +0000
@@ -16,7 +16,6 @@
 #define NINJA_TEST_H_
 
 #include "disk_interface.h"
-#include "manifest_parser.h"
 #include "state.h"
 #include "util.h"
 
@@ -94,17 +93,17 @@
   if (!EXPECT_TRUE(a))  { g_current_test->AddAssertionFailure(); return; }
 #define ASSERT_FALSE(a) \
   if (!EXPECT_FALSE(a)) { g_current_test->AddAssertionFailure(); return; }
-#define ASSERT_NO_FATAL_FAILURE(a)                           \
-  {                                                          \
-    int fail_count = g_current_test->AssertionFailures();    \
-    a;                                                       \
-    if (fail_count != g_current_test->AssertionFailures()) { \
-      g_current_test->AddAssertionFailure();                 \
-      return;                                                \
-    }                                                        \
+#define ASSERT_NO_FATAL_FAILURE(a)                  \
+  {                                                 \
+    int f = g_current_test->AssertionFailures();    \
+    a;                                              \
+    if (f != g_current_test->AssertionFailures()) { \
+      g_current_test->AddAssertionFailure();        \
+      return;                                       \
+    }                                               \
   }
 
-// Support utilities for tests.
+// Support utilites for tests.
 
 struct Node;
 
@@ -123,8 +122,7 @@
   State state_;
 };
 
-void AssertParse(State* state, const char* input,
-                 ManifestParserOptions = ManifestParserOptions());
+void AssertParse(State* state, const char* input);
 void AssertHash(const char* expected, uint64_t actual);
 void VerifyGraph(const State& state);
 
@@ -147,7 +145,7 @@
   virtual TimeStamp Stat(const string& path, string* err) const;
   virtual bool WriteFile(const string& path, const string& contents);
   virtual bool MakeDir(const string& path);
-  virtual Status ReadFile(const string& path, string* contents, string* err);
+  virtual string ReadFile(const string& path, string* err);
   virtual int RemoveFile(const string& path);
 
   /// An entry for a single in-memory file.
diff -Naur ninja-1.9.0.orig/src/timestamp.h ninja/src/timestamp.h
--- ninja-1.9.0.orig/src/timestamp.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/timestamp.h	2019-09-24 19:51:29.673113738 +0000
@@ -15,19 +15,10 @@
 #ifndef NINJA_TIMESTAMP_H_
 #define NINJA_TIMESTAMP_H_
 
-#ifdef _WIN32
-#include "win32port.h"
-#else
-#ifndef __STDC_FORMAT_MACROS
-#define __STDC_FORMAT_MACROS
-#endif
-#include <inttypes.h>
-#endif
-
 // When considering file modification times we only care to compare
 // them against one another -- we never convert them to an absolute
-// real time.  On POSIX we use timespec (seconds&nanoseconds since epoch)
-// and on Windows we use a different value.  Both fit in an int64.
-typedef int64_t TimeStamp;
+// real time.  On POSIX we use time_t (seconds since epoch) and on
+// Windows we use a different value.  Both fit in an int.
+typedef int TimeStamp;
 
 #endif  // NINJA_TIMESTAMP_H_
diff -Naur ninja-1.9.0.orig/src/util.cc ninja/src/util.cc
--- ninja-1.9.0.orig/src/util.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/util.cc	2019-09-24 19:51:29.675668138 +0000
@@ -45,8 +45,6 @@
 #elif defined(__SVR4) && defined(__sun)
 #include <unistd.h>
 #include <sys/loadavg.h>
-#elif defined(_AIX)
-#include <libperfstat.h>
 #elif defined(linux) || defined(__GLIBC__)
 #include <sys/sysinfo.h>
 #endif
@@ -90,7 +88,7 @@
   fprintf(stderr, "\n");
 }
 
-bool CanonicalizePath(string* path, uint64_t* slash_bits, string* err) {
+bool CanonicalizePath(string* path, unsigned int* slash_bits, string* err) {
   METRIC_RECORD("canonicalize str");
   size_t len = path->size();
   char* str = 0;
@@ -102,15 +100,20 @@
   return true;
 }
 
-static bool IsPathSeparator(char c) {
 #ifdef _WIN32
-  return c == '/' || c == '\\';
-#else
-  return c == '/';
-#endif
+static unsigned int ShiftOverBit(int offset, unsigned int bits) {
+  // e.g. for |offset| == 2:
+  // | ... 9 8 7 6 5 4 3 2 1 0 |
+  // \_________________/   \_/
+  //        above         below
+  // So we drop the bit at offset and move above "down" into its place.
+  unsigned int above = bits & ~((1 << (offset + 1)) - 1);
+  unsigned int below = bits & ((1 << offset) - 1);
+  return (above >> 1) | below;
 }
+#endif
 
-bool CanonicalizePath(char* path, size_t* len, uint64_t* slash_bits,
+bool CanonicalizePath(char* path, size_t* len, unsigned int* slash_bits,
                       string* err) {
   // WARNING: this function is performance-critical; please benchmark
   // any changes you make to it.
@@ -120,7 +123,7 @@
     return false;
   }
 
-  const int kMaxPathComponents = 60;
+  const int kMaxPathComponents = 30;
   char* components[kMaxPathComponents];
   int component_count = 0;
 
@@ -129,13 +132,37 @@
   const char* src = start;
   const char* end = start + *len;
 
-  if (IsPathSeparator(*src)) {
 #ifdef _WIN32
+  unsigned int bits = 0;
+  unsigned int bits_mask = 1;
+  int bits_offset = 0;
+  // Convert \ to /, setting a bit in |bits| for each \ encountered.
+  for (char* c = path; c < end; ++c) {
+    switch (*c) {
+      case '\\':
+        bits |= bits_mask;
+        *c = '/';
+        // Intentional fallthrough.
+      case '/':
+        bits_mask <<= 1;
+        bits_offset++;
+    }
+  }
+  if (bits_offset > 32) {
+    *err = "too many path components";
+    return false;
+  }
+  bits_offset = 0;
+#endif
 
+  if (*src == '/') {
+#ifdef _WIN32
+    bits_offset++;
     // network path starts with //
-    if (*len > 1 && IsPathSeparator(*(src + 1))) {
+    if (*len > 1 && *(src + 1) == '/') {
       src += 2;
       dst += 2;
+      bits_offset++;
     } else {
       ++src;
       ++dst;
@@ -148,16 +175,24 @@
 
   while (src < end) {
     if (*src == '.') {
-      if (src + 1 == end || IsPathSeparator(src[1])) {
+      if (src + 1 == end || src[1] == '/') {
         // '.' component; eliminate.
         src += 2;
+#ifdef _WIN32
+        bits = ShiftOverBit(bits_offset, bits);
+#endif
         continue;
-      } else if (src[1] == '.' && (src + 2 == end || IsPathSeparator(src[2]))) {
+      } else if (src[1] == '.' && (src + 2 == end || src[2] == '/')) {
         // '..' component.  Back up if possible.
         if (component_count > 0) {
           dst = components[component_count - 1];
           src += 3;
           --component_count;
+#ifdef _WIN32
+          bits = ShiftOverBit(bits_offset, bits);
+          bits_offset--;
+          bits = ShiftOverBit(bits_offset, bits);
+#endif
         } else {
           *dst++ = *src++;
           *dst++ = *src++;
@@ -167,8 +202,11 @@
       }
     }
 
-    if (IsPathSeparator(*src)) {
+    if (*src == '/') {
       src++;
+#ifdef _WIN32
+      bits = ShiftOverBit(bits_offset, bits);
+#endif
       continue;
     }
 
@@ -177,32 +215,21 @@
     components[component_count] = dst;
     ++component_count;
 
-    while (src != end && !IsPathSeparator(*src))
+    while (*src != '/' && src != end)
       *dst++ = *src++;
+#ifdef _WIN32
+    bits_offset++;
+#endif
     *dst++ = *src++;  // Copy '/' or final \0 character as well.
   }
 
   if (dst == start) {
-    *dst++ = '.';
-    *dst++ = '\0';
+    *err = "path canonicalizes to the empty path";
+    return false;
   }
 
   *len = dst - start - 1;
 #ifdef _WIN32
-  uint64_t bits = 0;
-  uint64_t bits_mask = 1;
-
-  for (char* c = start; c < start + *len; ++c) {
-    switch (*c) {
-      case '\\':
-        bits |= bits_mask;
-        *c = '/';
-        NINJA_FALLTHROUGH;
-      case '/':
-        bits_mask <<= 1;
-    }
-  }
-
   *slash_bits = bits;
 #else
   *slash_bits = 0;
@@ -318,8 +345,13 @@
   // This makes a ninja run on a set of 1500 manifest files about 4% faster
   // than using the generic fopen code below.
   err->clear();
-  HANDLE f = ::CreateFileA(path.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL,
-                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
+  HANDLE f = ::CreateFile(path.c_str(),
+                          GENERIC_READ,
+                          FILE_SHARE_READ,
+                          NULL,
+                          OPEN_EXISTING,
+                          FILE_FLAG_SEQUENTIAL_SCAN,
+                          NULL);
   if (f == INVALID_HANDLE_VALUE) {
     err->assign(GetLastErrorString());
     return -ENOENT;
@@ -346,19 +378,9 @@
     return -errno;
   }
 
-  struct stat st;
-  if (fstat(fileno(f), &st) < 0) {
-    err->assign(strerror(errno));
-    fclose(f);
-    return -errno;
-  }
-
-  // +1 is for the resize in ManifestParser::Load
-  contents->reserve(st.st_size + 1);
-
   char buf[64 << 10];
   size_t len;
-  while (!feof(f) && (len = fread(buf, 1, sizeof(buf), f)) > 0) {
+  while ((len = fread(buf, 1, sizeof(buf), f)) > 0) {
     contents->append(buf, len);
   }
   if (ferror(f)) {
@@ -442,16 +464,12 @@
   return msg;
 }
 
-void Win32Fatal(const char* function, const char* hint) {
-  if (hint) {
-    Fatal("%s: %s (%s)", function, GetLastErrorString().c_str(), hint);
-  } else {
-    Fatal("%s: %s", function, GetLastErrorString().c_str());
-  }
+void Win32Fatal(const char* function) {
+  Fatal("%s: %s", function, GetLastErrorString().c_str());
 }
 #endif
 
-bool islatinalpha(int c) {
+static bool islatinalpha(int c) {
   // isalpha() is locale-dependent.
   return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
 }
@@ -484,6 +502,8 @@
   SYSTEM_INFO info;
   GetNativeSystemInfo(&info);
   return info.dwNumberOfProcessors;
+#elif defined(__sgi)
+  return sysconf(_SC_NPROC_ONLN);
 #else
   return sysconf(_SC_NPROCESSORS_ONLN);
 #endif
@@ -555,39 +575,26 @@
 
   return posix_compatible_load;
 }
-#elif defined(_AIX)
-double GetLoadAverage() {
-  perfstat_cpu_total_t cpu_stats;
-  if (perfstat_cpu_total(NULL, &cpu_stats, sizeof(cpu_stats), 1) < 0) {
-    return -0.0f;
-  }
-
-  // Calculation taken from comment in libperfstats.h
-  return double(cpu_stats.loadavg[0]) / double(1 << SBITS);
-}
-#elif defined(__UCLIBC__)
-double GetLoadAverage() {
-  struct sysinfo si;
-  if (sysinfo(&si) != 0)
-    return -0.0f;
-  return 1.0 / (1 << SI_LOAD_SHIFT) * si.loads[0];
-}
 #else
 double GetLoadAverage() {
   double loadavg[3] = { 0.0f, 0.0f, 0.0f };
+#ifdef __sgi
+  return -0.0f;
+#else
   if (getloadavg(loadavg, 3) < 0) {
     // Maybe we should return an error here or the availability of
     // getloadavg(3) should be checked when ninja is configured.
     return -0.0f;
   }
   return loadavg[0];
+#endif
 }
 #endif // _WIN32
 
 string ElideMiddle(const string& str, size_t width) {
   const int kMargin = 3;  // Space for "...".
   string result = str;
-  if (result.size() > width) {
+  if (result.size() + kMargin > width) {
     size_t elide_size = (width - kMargin) / 2;
     result = result.substr(0, elide_size)
       + "..."
diff -Naur ninja-1.9.0.orig/src/util.h ninja/src/util.h
--- ninja-1.9.0.orig/src/util.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/util.h	2019-09-24 19:51:29.676432938 +0000
@@ -34,20 +34,6 @@
 /// Log a fatal message and exit.
 NORETURN void Fatal(const char* msg, ...);
 
-// Have a generic fall-through for different versions of C/C++.
-#if defined(__cplusplus) && __cplusplus >= 201703L
-#define NINJA_FALLTHROUGH [[fallthrough]]
-#elif defined(__cplusplus) && __cplusplus >= 201103L && defined(__clang__)
-#define NINJA_FALLTHROUGH [[clang::fallthrough]]
-#elif defined(__cplusplus) && __cplusplus >= 201103L && defined(__GNUC__) && \
-    __GNUC__ >= 7
-#define NINJA_FALLTHROUGH [[gnu::fallthrough]]
-#elif defined(__GNUC__) && __GNUC__ >= 7 // gcc 7
-#define NINJA_FALLTHROUGH __attribute__ ((fallthrough))
-#else // C++11 on gcc 6, and all other cases
-#define NINJA_FALLTHROUGH
-#endif
-
 /// Log a warning message.
 void Warning(const char* msg, ...);
 
@@ -57,8 +43,8 @@
 /// Canonicalize a path like "foo/../bar.h" into just "bar.h".
 /// |slash_bits| has bits set starting from lowest for a backslash that was
 /// normalized to a forward slash. (only used on Windows)
-bool CanonicalizePath(string* path, uint64_t* slash_bits, string* err);
-bool CanonicalizePath(char* path, size_t* len, uint64_t* slash_bits,
+bool CanonicalizePath(string* path, unsigned int* slash_bits, string* err);
+bool CanonicalizePath(char* path, size_t* len, unsigned int* slash_bits,
                       string* err);
 
 /// Appends |input| to |*result|, escaping according to the whims of either
@@ -84,8 +70,6 @@
 /// Like SpellcheckStringV, but takes a NULL-terminated list.
 const char* SpellcheckString(const char* text, ...);
 
-bool islatinalpha(int c);
-
 /// Removes all Ansi escape codes (http://www.termsys.demon.co.uk/vtansi.htm).
 string StripAnsiEscapeCodes(const string& in);
 
@@ -119,7 +103,7 @@
 string GetLastErrorString();
 
 /// Calls Fatal() with a function name and GetLastErrorString.
-NORETURN void Win32Fatal(const char* function, const char* hint = NULL);
+NORETURN void Win32Fatal(const char* function);
 #endif
 
 #endif  // NINJA_UTIL_H_
diff -Naur ninja-1.9.0.orig/src/util_test.cc ninja/src/util_test.cc
--- ninja-1.9.0.orig/src/util_test.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/util_test.cc	2019-09-24 19:51:29.677508938 +0000
@@ -19,7 +19,7 @@
 namespace {
 
 bool CanonicalizePath(string* path, string* err) {
-  uint64_t unused;
+  unsigned int unused;
   return ::CanonicalizePath(path, &unused, err);
 }
 
@@ -91,22 +91,6 @@
   path = "/";
   EXPECT_TRUE(CanonicalizePath(&path, &err));
   EXPECT_EQ("", path);
-
-  path = "/foo/..";
-  EXPECT_TRUE(CanonicalizePath(&path, &err));
-  EXPECT_EQ("", path);
-
-  path = ".";
-  EXPECT_TRUE(CanonicalizePath(&path, &err));
-  EXPECT_EQ(".", path);
-
-  path = "./.";
-  EXPECT_TRUE(CanonicalizePath(&path, &err));
-  EXPECT_EQ(".", path);
-
-  path = "foo/..";
-  EXPECT_TRUE(CanonicalizePath(&path, &err));
-  EXPECT_EQ(".", path);
 }
 
 #ifdef _WIN32
@@ -177,7 +161,7 @@
 TEST(CanonicalizePath, SlashTracking) {
   string path;
   string err;
-  uint64_t slash_bits;
+  unsigned int slash_bits;
 
   path = "foo.h"; err = "";
   EXPECT_TRUE(CanonicalizePath(&path, &slash_bits, &err));
@@ -263,7 +247,7 @@
 TEST(CanonicalizePath, CanonicalizeNotExceedingLen) {
   // Make sure searching \/ doesn't go past supplied len.
   char buf[] = "foo/bar\\baz.h\\";  // Last \ past end.
-  uint64_t slash_bits;
+  unsigned int slash_bits;
   string err;
   size_t size = 13;
   EXPECT_TRUE(::CanonicalizePath(buf, &size, &slash_bits, &err));
@@ -274,62 +258,51 @@
 TEST(CanonicalizePath, TooManyComponents) {
   string path;
   string err;
-  uint64_t slash_bits;
+  unsigned int slash_bits;
 
-  // 64 is OK.
-  path = "a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./"
-         "a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./x.h";
+  // 32 is OK.
+  path = "a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./x.h";
   EXPECT_TRUE(CanonicalizePath(&path, &slash_bits, &err));
-  EXPECT_EQ(slash_bits, 0x0);
 
   // Backslashes version.
   path =
-      "a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\"
-      "a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\"
-      "a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\"
-      "a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\x.h";
-
+      "a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\."
+      "\\a\\.\\a\\.\\a\\.\\a\\.\\x.h";
   EXPECT_TRUE(CanonicalizePath(&path, &slash_bits, &err));
-  EXPECT_EQ(slash_bits, 0xffffffff);
+  EXPECT_EQ(slash_bits, 0xffff);
 
-  // 65 is OK if #component is less than 60 after path canonicalization.
+  // 33 is not.
   err = "";
-  path = "a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./"
-         "a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./x/y.h";
-  EXPECT_TRUE(CanonicalizePath(&path, &slash_bits, &err));
-  EXPECT_EQ(slash_bits, 0x0);
+  path =
+      "a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/./a/x.h";
+  EXPECT_FALSE(CanonicalizePath(&path, &slash_bits, &err));
+  EXPECT_EQ(err, "too many path components");
 
   // Backslashes version.
   err = "";
   path =
-      "a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\"
-      "a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\"
-      "a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\"
-      "a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\x\\y.h";
-  EXPECT_TRUE(CanonicalizePath(&path, &slash_bits, &err));
-  EXPECT_EQ(slash_bits, 0x1ffffffff);
+      "a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\.\\a\\."
+      "\\a\\.\\a\\.\\a\\.\\a\\.\\a\\x.h";
+  EXPECT_FALSE(CanonicalizePath(&path, &slash_bits, &err));
+  EXPECT_EQ(err, "too many path components");
+}
+#endif
 
+TEST(CanonicalizePath, EmptyResult) {
+  string path;
+  string err;
 
-  // 59 after canonicalization is OK.
-  err = "";
-  path = "a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/"
-         "a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/a/x/y.h";
-  EXPECT_EQ(58, std::count(path.begin(), path.end(), '/'));
-  EXPECT_TRUE(CanonicalizePath(&path, &slash_bits, &err));
-  EXPECT_EQ(slash_bits, 0x0);
+  EXPECT_FALSE(CanonicalizePath(&path, &err));
+  EXPECT_EQ("empty path", err);
 
-  // Backslashes version.
-  err = "";
-  path =
-      "a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\"
-      "a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\"
-      "a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\a\\"
-      "a\\a\\a\\a\\a\\a\\a\\a\\a\\x\\y.h";
-  EXPECT_EQ(58, std::count(path.begin(), path.end(), '\\'));
-  EXPECT_TRUE(CanonicalizePath(&path, &slash_bits, &err));
-  EXPECT_EQ(slash_bits, 0x3ffffffffffffff);
+  path = ".";
+  EXPECT_FALSE(CanonicalizePath(&path, &err));
+  EXPECT_EQ("path canonicalizes to the empty path", err);
+
+  path = "./.";
+  EXPECT_FALSE(CanonicalizePath(&path, &err));
+  EXPECT_EQ("path canonicalizes to the empty path", err);
 }
-#endif
 
 TEST(CanonicalizePath, UpDir) {
   string path, err;
@@ -353,7 +326,7 @@
   string path;
   string err;
   size_t len;
-  uint64_t unused;
+  unsigned int unused;
 
   path = "foo/. bar/.";
   len = strlen("foo/.");  // Canonicalize only the part before the space.
@@ -419,12 +392,10 @@
 TEST(ElideMiddle, NothingToElide) {
   string input = "Nothing to elide in this short string.";
   EXPECT_EQ(input, ElideMiddle(input, 80));
-  EXPECT_EQ(input, ElideMiddle(input, 38));
 }
 
 TEST(ElideMiddle, ElideInTheMiddle) {
   string input = "01234567890123456789";
   string elided = ElideMiddle(input, 10);
   EXPECT_EQ("012...789", elided);
-  EXPECT_EQ("01234567...23456789", ElideMiddle(input, 19));
 }
diff -Naur ninja-1.9.0.orig/src/version.cc ninja/src/version.cc
--- ninja-1.9.0.orig/src/version.cc	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/version.cc	2019-09-24 19:51:29.678152938 +0000
@@ -18,7 +18,7 @@
 
 #include "util.h"
 
-const char* kNinjaVersion = "1.9.0";
+const char* kNinjaVersion = "1.6.0";
 
 void ParseVersion(const string& version, int* major, int* minor) {
   size_t end = version.find('.');
diff -Naur ninja-1.9.0.orig/src/win32port.h ninja/src/win32port.h
--- ninja-1.9.0.orig/src/win32port.h	2019-01-30 13:58:59.000000000 +0000
+++ ninja/src/win32port.h	2019-09-24 19:51:29.678637738 +0000
@@ -15,13 +15,6 @@
 #ifndef NINJA_WIN32PORT_H_
 #define NINJA_WIN32PORT_H_
 
-#if defined(__MINGW32__) || defined(__MINGW64__)
-#ifndef __STDC_FORMAT_MACROS
-#define __STDC_FORMAT_MACROS
-#endif
-#include <inttypes.h>
-#endif
-
 typedef signed short int16_t;
 typedef unsigned short uint16_t;
 /// A 64-bit integer type
@@ -30,7 +23,6 @@
 
 // printf format specifier for uint64_t, from C99.
 #ifndef PRIu64
-#define PRId64 "I64d"
 #define PRIu64 "I64u"
 #define PRIx64 "I64x"
 #endif
